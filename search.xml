<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>排序算法比较与梳理</title>
    <url>/2020/03/15/sort01/</url>
    <content><![CDATA[<h2 id="各类排序算法"><a href="#各类排序算法" class="headerlink" title="各类排序算法"></a>各类排序算法</h2><p><img src="/img/01sort/sort.png" alt="排序算法复杂度"></p>
<a id="more"></a>

<h2 id="排序算法一般分类"><a href="#排序算法一般分类" class="headerlink" title="排序算法一般分类"></a>排序算法一般分类</h2><p><img src="/img/01sort/sort1.png" alt="排序算法分类"></p>
<p>相关概念：</p>
<ul>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li>时间复杂度：对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。</li>
<li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>比较两个相邻的元素，将值大的元素交换至右端。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>依次比较两个相邻的数，将小数放到前面，大数放到后面</p>
<p>第一趟：首先比较第 1 个数和第 2 个数，将小数放前，大数放后。然后比较第 2 个数和第 3 个数，将小数放前，大数放后，如此一直继续下去，直到比较最后两个数，将小数放前，大数放后。然后重复第一趟步骤，直到所有排序完成。</p>
<p>第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较。</p>
<p>第二趟完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较。</p>
<p>依此类推……<br><img src="/img/01sort/bubblesort.gif" alt="冒泡排序"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        bubbleSort(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; array.length-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"排序后的数组为:"</span> + Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>排序后的数组为: [1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h3><p><em>冒泡排序的优点</em>：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。</p>
<p>用时间复杂度来说： 如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：<code>Cmin=n-1</code>;<code>Mmin=0</code>;所以，冒泡排序最好的时间复杂度为<code>O(n)</code>。如果很不幸我们的数据是反序的，则需要进行 n - 1 趟排序。每趟排序要进行 n - i 次比较(1 ≤ i ≤ n - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值。</p>
<ul>
<li>冒泡排序的最坏时间复杂度为：O(n^2)</li>
<li>冒泡排序的最好时间复杂夫为：O(n)</li>
<li>冒泡排序的平均时间复杂度：O(n)</li>
<li>冒泡排序是一种稳定的排序算法</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>从一个数组中随机选出一个数N，通过一趟排序将数组分割成三个部分，1、小于N的区域 2、等于N的区域 3、大于N的区域，然后再按照此方法对小于区的和大于区分别递归进行，从而达到整个数据变成有序数组。<br><img src="/img/01sort/quickSort.gif" alt="快速排序"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如下图：<br>假设最开始的基准数据为数组的第一个元素23，则首先用一个临时变量去存储基准数据，即 tmp=23，然后分别从数组的两端扫描数组，设两个指示标志：low 指向起始位置，high 指向末尾。<br><img src="/img/01sort/quicksort1.png" alt="快速排序"><br>首先从后半部分开始，如果扫描到的值大于基准数据就让 high - 1，如果发现有元素比该基准数据的值小，比如上面的 18 &lt;= tmp ，就让high位置的值赋值给low位置，结果如下：<br><img src="/img/01sort/quicksort2.png" alt="快速排序"><br>然后开始从前往后扫描，如果扫描到的值小于基准数据就让 low+1，如果发现有元素大于基准数据的值，比如上图 46 &gt;= tmp，就再将 low 位置的值赋值给 high 位置的值，指针移动并且数据交换后的结果如下：<br><img src="/img/01sort/quicksort3.png" alt="快速排序"><br>然后再开始从前往后遍历，直到 low=high 结束循环，此时 low 或者 high 的下标就是基准数据23在该数组中的正确索引位置，如下图所示：<br><img src="/img/01sort/quicksort5.png" alt="快速排序"><br>这样一遍遍的走下来，可以很清楚的知道，快排的本质就是把比基准数据小的都放到基准数的左边，比基准数大的数都放到基准数的右边，这样就找到了该数据在数组中的正确位置。<br>然后采用递归的方式分别对前半部分和后半部分排序，最终结果就是自然有序的了。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        quickSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="comment">//找到基准数据位置</span></span><br><span class="line">            <span class="keyword">int</span> index = getIndex(array,low,high);</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            quickSort(array,<span class="number">0</span>,index-<span class="number">1</span>);</span><br><span class="line">            quickSort(array,index+<span class="number">1</span>,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取基准数据位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="comment">//一般取第一个数作为基准数据</span></span><br><span class="line">        <span class="keyword">int</span> tmp = array[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; array[high] &gt;= tmp)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则high处元素小于基准数据，将high处赋值给low处数据</span></span><br><span class="line">            array[low] = array[high];</span><br><span class="line">            <span class="comment">//赋值完后，需要从前面开始扫描数组</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; array[low] &lt;= tmp)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">             array[high] = array[low];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整个循环结束时high=low,但是该位置处不等于基准元素</span></span><br><span class="line">        array[low] = tmp;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-1"><a href="#特点分析-1" class="headerlink" title="特点分析"></a>特点分析</h3><p>最好情况下快排每次能恰好均分序列，那么时间复杂度就是 O(nlogn)，最坏情况下，快排每次划分都只能将序列分为一个元素和其它元素两部分，这时候的快排退化成冒泡排序，时间复杂度为 O(n^2)。</p>
<ul>
<li>平均时间复杂度是 O(nlogn)</li>
<li>最坏时间复杂度是 O(n^2)</li>
<li>对于大的，乱序排列的数组来说快排一般是已知的最快的已知排序</li>
<li>快排是一种不稳定排序</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为 O(n^2)。是稳定的排序方法。<br><img src="/img/01sort/insertionSort.gif" alt="插入排序"></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>将一个数据插入到<em>已经排好序的有序数据</em>中</p>
<ul>
<li>将要排序的是一个乱的数组 int[] arrays = {3, 2, 1, 3, 3}</li>
<li>在未知道数组元素的情况下，我们只能把数组的第一个元素作为已经排好序的有序数据，也就是说，把{3}看成是已经排好序的有序数据</li>
</ul>
<p>第一趟排序：<br>用数组的第二个数与第一个数(<em>看成是已有序的数据</em>)比较</p>
<ul>
<li>如果比第一个数大，那就不管他</li>
<li>如果比第一个数小，将第一个数往后退一步，将第二个数插入第一个数去</li>
</ul>
<p>第二趟排序：<br>用数组的第三个数与已是有序的数据 {2,3} (刚才在第一趟排的)比较</p>
<ul>
<li>如果比 2 大，那就不管它</li>
<li>如果比 2 小，那就将 2 退一个位置，让第三个数和1比较</li>
</ul>
<p>在第二步中：</p>
<ul>
<li><p>如果第三个数比 1 大，那么将第三个数插入到 2 的位置上</p>
</li>
<li><p>如果第三个数比 1 小，那么将 1 后退一步，将第三个数插入到 1 的位置上</p>
</li>
</ul>
<p>…<br>后面依此类推</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        insertSort(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j-<span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                    arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//插入新的元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-2"><a href="#特点分析-2" class="headerlink" title="特点分析"></a>特点分析</h3><ul>
<li>最坏时间复杂度为O(n^2)</li>
<li>最好时间复杂度为O(n)</li>
<li>平均时间复杂度为O(n^2)</li>
<li>插入排序是一种稳定的排序算法。</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。<br><img src="/img/01sort/selectionSort.gif" alt="选择排序"></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>举例：数组 int[] arr = {5,2,8,4,9,1}<br><em>第一趟排序<em>： 原始数据：<code>5 2 8 4 9 1</code><br>最小数据1，把1放在首位，也就是1和5互换位置，<br>排序结果：<code>1 2 8 4 9 5</code><br>*第二趟排序</em>：<br>第1以外的数据<code>{2 8 4 9 5}</code>进行比较，2最小，<br>排序结果：<code>1 2 8 4 9 5</code><br><em>第三趟排序</em>：<br>除1、2以外的数据<code>{8 4 9 5}</code>进行比较，4最小，8和4交换<br>排序结果：<code>1 2 4 8 9 5</code><br>*第四趟排序</em> :<br>除第<code>1、2、4</code>以外的其他数据<code>{8 9 5}</code>进行比较，5最小，8和5交换<br>排序结果：<code>1 2 4 5 9 8</code><br><em>第五趟排序</em>：<br>除第<code>1、2、4、5</code>以外的其他数据<code>{9 8}</code>进行比较，8最小，8和9交换<br>排序结果：<code>1 2 4 5 8 9</code></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        selectionSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length -<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &lt; array[k])&#123;</span><br><span class="line">                    k = j; <span class="comment">//记下目前找到的最小值所在的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(i != k)&#123;  <span class="comment">//交换a[i]和a[k]</span></span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                array[i] = array[k];</span><br><span class="line">                array[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-3"><a href="#特点分析-3" class="headerlink" title="特点分析"></a>特点分析</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是 O(n^2) 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<ul>
<li><p>最坏时间复杂度为O(n^2)</p>
</li>
<li><p>平均时间复杂度为O(n^2)</p>
</li>
<li><p>选择排序是一种不稳定的排序</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>堆排序是对简单选择排序的改进，简单选择排序是从 n 个记录中找出一个最小的记录，需要比较 n - 1 次。但是这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。<br>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。<br><img src="/img/01sort/heap-sort.png" alt="堆排序"></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的 n - 1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次最大值。如此反复执行，就能得到一个有序序列了。<br><img src="/img/01sort/849589-20171015231308699-356134237.gif" alt="堆排序"><br>实现思路：</p>
</li>
<li><p>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区；</p>
</li>
<li><p>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1] &lt;= R[n]；</p>
</li>
<li><p>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区 (Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n - 1，则整个排序过程完成。</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;50, 10, 90, 30, 70, 40, 80, 60, 20&#125;;</span><br><span class="line">        System.out.println(&quot;排序之前：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 堆排序</span><br><span class="line">        heapSort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;排序之后：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 堆排序</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void heapSort(int[] arr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将待排序的序列构建成一个大顶堆</span><br><span class="line">        for (int i &#x3D; arr.length &#x2F; 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            heapAdjust(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 逐步将每个最大值的根节点与末尾元素交换，并且再调整二叉树，使其成为大顶堆</span><br><span class="line">        for (int i &#x3D; arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            swap(arr, 0, i); &#x2F;&#x2F; 将堆顶记录和当前未经排序子序列的最后一个记录交换</span><br><span class="line">            heapAdjust(arr, 0, i); &#x2F;&#x2F; 交换之后，需要重新检查堆是否符合大顶堆，不符合则要调整</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构建堆的过程</span><br><span class="line">     *</span><br><span class="line">     * @param arr 需要排序的数组</span><br><span class="line">     * @param i   需要构建堆的根节点的序号</span><br><span class="line">     * @param n   数组的长度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void heapAdjust(int[] arr, int i, int n) &#123;</span><br><span class="line">        int child;</span><br><span class="line">        int father;</span><br><span class="line">        for (father &#x3D; arr[i]; leftChild(i) &lt; n; i &#x3D; child) &#123;</span><br><span class="line">            child &#x3D; leftChild(i);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果左子树小于右子树，则需要比较右子树和父节点</span><br><span class="line">            if (child !&#x3D; n - 1 &amp;&amp; arr[child] &lt; arr[child + 1]) &#123;</span><br><span class="line">                child++; &#x2F;&#x2F; 序号增1，指向右子树</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果父节点小于孩子结点，则需要交换</span><br><span class="line">            if (father &lt; arr[child]) &#123;</span><br><span class="line">                arr[i] &#x3D; arr[child];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break; &#x2F;&#x2F; 大顶堆结构未被破坏，不需要调整</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] &#x3D; father;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取到左孩子结点</span><br><span class="line">    private static int leftChild(int i) &#123;</span><br><span class="line">        return 2 * i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 交换元素位置</span><br><span class="line">    private static void swap(int[] arr, int index1, int index2) &#123;</span><br><span class="line">        int tmp &#x3D; arr[index1];</span><br><span class="line">        arr[index1] &#x3D; arr[index2];</span><br><span class="line">        arr[index2] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">排序之前：</span><br><span class="line">50 10 90 30 70 40 80 60 20 </span><br><span class="line">排序之后：</span><br><span class="line">10 20 30 40 50 60 70 80 90</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-4"><a href="#特点分析-4" class="headerlink" title="特点分析"></a>特点分析</h3><p>堆排序时间复杂度：O(nlogn)<br>堆排序对原始记录的排序状态并不敏感，其在性能上要远远好过于冒泡、简单选择、直接插入排序。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>归并排序（merge sort）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。<br><img src="/img/01sort/guibingSort.gif" alt="归并排序"></p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>比如我们对<code>[8,4,5,7,1,3,6,2]</code>这个数组进行归并排序，我们首先利用分治思想的“分”将数组拆分。<br><img src="/img/01sort/mergesort0.png" alt="归并排序"><br>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为<code>log2n</code>。<br>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将<code>[4,5,7,8]</code>和<code>[1,2,3,6]</code>两个已经有序的子序列，合并为最终序列<code>[1,2,3,4,5,6,7,8]</code>，来看下实现步骤。<br><img src="/img/01sort/mergesort2.png" alt="归并排序"></p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        int[] array &#x3D; &#123;2,4,1,5,67,2,45,78,3,9&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sort(int []arr)&#123;</span><br><span class="line">        int []temp &#x3D; new int[arr.length];&#x2F;&#x2F;在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span><br><span class="line">        sort(arr,0,arr.length-1,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void sort(int[] arr,int left,int right,int []temp)&#123;</span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            int mid &#x3D; (left+right)&#x2F;2;</span><br><span class="line">            sort(arr,left,mid,temp);&#x2F;&#x2F;左边归并排序，使得左子序列有序</span><br><span class="line">            sort(arr,mid+1,right,temp);&#x2F;&#x2F;右边归并排序，使得右子序列有序</span><br><span class="line">            merge(arr,left,mid,right,temp);&#x2F;&#x2F;将两个有序子数组合并操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123;</span><br><span class="line">        int i &#x3D; left;&#x2F;&#x2F;左序列指针</span><br><span class="line">        int j &#x3D; mid+1;&#x2F;&#x2F;右序列指针</span><br><span class="line">        int t &#x3D; 0;&#x2F;&#x2F;临时数组指针</span><br><span class="line">        while (i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;</span><br><span class="line">            if(arr[i]&lt;&#x3D;arr[j])&#123;</span><br><span class="line">                temp[t++] &#x3D; arr[i++];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                temp[t++] &#x3D; arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&lt;&#x3D;mid)&#123;&#x2F;&#x2F;将左边剩余元素填充进temp中</span><br><span class="line">            temp[t++] &#x3D; arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;&#x3D;right)&#123;&#x2F;&#x2F;将右序列剩余元素填充进temp中</span><br><span class="line">            temp[t++] &#x3D; arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;将temp中的元素全部拷贝到原数组中</span><br><span class="line">        while(left &lt;&#x3D; right)&#123;</span><br><span class="line">            arr[left++] &#x3D; temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-5"><a href="#特点分析-5" class="headerlink" title="特点分析"></a>特点分析</h3></li>
<li><p>归并排序是一种稳定排序</p>
</li>
<li><p>Java中的<code>Arrays.sort()</code>采用了一种名为TimSort的排序算法，就是归并排序的优化版本</p>
</li>
<li><p>每次合并操作的时间复杂度为O(n)，完全二叉树的深度为<code>|log2n|</code>，总的平均时间复杂度为O(nlogn)<br>归并排序的最好、最坏、平均时间复杂度都为O(nlongn)</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为 O(n+k)，其中 k 是整数的范围。基于比较的排序算法时间复杂度最小是 O(nlogn) 的。注意：计数排序对于实数的排序是不可行的（下面会解释）。该算法于1954年由 Harold H. Seward 提出。 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br><img src="/img/01sort/counting-sort.gif" alt="归并排序"></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>实现思路：</p>
</li>
<li><p>找出待排序的数组中最大和最小的元素；</p>
</li>
<li><p>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</p>
</li>
<li><p>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</p>
</li>
<li><p>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ttt;</span><br><span class="line"> </span><br><span class="line">public class CountingSort &#123;</span><br><span class="line">    public static int[] countingSort(int[] theArray) &#123;</span><br><span class="line">    	int[] lastArray &#x3D; new int[theArray.length];</span><br><span class="line">        for(int i &#x3D; 0; i &lt; theArray.length; i++) &#123;</span><br><span class="line">        	int count &#x3D; 0;</span><br><span class="line">        	for(int j &#x3D; 0; j &lt; theArray.length; j++) &#123;</span><br><span class="line">        		if(theArray[i] &gt; theArray[j]) &#123;</span><br><span class="line">        			count++;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	lastArray[count] &#x3D; theArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    	return lastArray;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	int []theArray &#x3D; &#123;6, 4, 5, 1, 8, 7, 2, 3&#125;;</span><br><span class="line">        System.out.print(&quot;之前的排序：&quot;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; theArray.length; i++) &#123;</span><br><span class="line">            System.out.print(theArray[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int []resultArray &#x3D; countingSort(theArray);</span><br><span class="line">        </span><br><span class="line">        System.out.print(&quot;计数排序：&quot;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; resultArray.length; i++) &#123;</span><br><span class="line">            System.out.print(resultArray[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>之前的排序：6 4 5 1 8 7 2 3 计数排序：1 2 3 4 5 6 7 8</code></p>
</li>
</ul>
<h3 id="特点分析-6"><a href="#特点分析-6" class="headerlink" title="特点分析"></a>特点分析</h3><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>实现思路：</p>
<ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void bucketSort(int[] arr)&#123;</span><br><span class="line">    </span><br><span class="line">    int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max &#x3D; Math.max(max, arr[i]);</span><br><span class="line">        min &#x3D; Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;桶数</span><br><span class="line">    int bucketNum &#x3D; (max - min) &#x2F; arr.length + 1;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr &#x3D; new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将每个元素放入桶</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        int num &#x3D; (arr[i] - min) &#x2F; (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;对每个桶进行排序</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(bucketArr.toString());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-7"><a href="#特点分析-7" class="headerlink" title="特点分析"></a>特点分析</h3>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3>数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。<br><img src="/img/01sort/radix-sort.gif" alt="基数排序"><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3>实现思路：</li>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RadixSort &#123;</span><br><span class="line">    private static void radixSort(int[] array,int d)&#123;</span><br><span class="line">        int n&#x3D;1;&#x2F;&#x2F;代表位数对应的数：1,10,100...</span><br><span class="line">        int k&#x3D;0;&#x2F;&#x2F;保存每一位排序后的结果用于下一位的排序输入</span><br><span class="line">        int length&#x3D;array.length;</span><br><span class="line">        int[][] bucket&#x3D;new int[10][length];&#x2F;&#x2F;排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span><br><span class="line">        int[] order&#x3D;new int[length];&#x2F;&#x2F;用于保存每个桶里有多少个数字</span><br><span class="line">        while(n&lt;d)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int num:array) &#x2F;&#x2F;将数组array里的每个数字放在相应的桶里</span><br><span class="line">            &#123;</span><br><span class="line">                int digit&#x3D;(num&#x2F;n)%10;</span><br><span class="line">                bucket[digit][order[digit]]&#x3D;num;</span><br><span class="line">                order[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i&#x3D;0;i&lt;length;i++)&#x2F;&#x2F;将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span><br><span class="line">            &#123;</span><br><span class="line">                if(order[i]!&#x3D;0)&#x2F;&#x2F;这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span><br><span class="line">                &#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;order[i];j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        array[k]&#x3D;bucket[i][j];</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                order[i]&#x3D;0;&#x2F;&#x2F;将桶里计数器置0，用于下一次位排序</span><br><span class="line">            &#125;</span><br><span class="line">            n*&#x3D;10;</span><br><span class="line">            k&#x3D;0;&#x2F;&#x2F;将k置0，用于下一轮保存位排序结果</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] A&#x3D;new int[]&#123;73,22, 93, 43, 55, 14, 28, 65, 39, 81&#125;;</span><br><span class="line">        radixSort(A, 100);</span><br><span class="line">        for(int num:A)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-8"><a href="#特点分析-8" class="headerlink" title="特点分析"></a>特点分析</h3>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n) 的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n) 的时间复杂度。假如待排数据可以分为 d个关键字，则基数排序的时间复杂度将是 <code>O(d*2n)</code> ，当然 d 要远远小于 n，因此基本上还是线性级别的。<br>基数排序的空间复杂度为<code>O(n+k)</code>，其中 k 为桶的数量。一般来说 n&gt;&gt;k，因此额外空间需要大概 n 个左右。</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><img src="/img/01sort/shell-sort.gif" alt="希尔排序"></p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void ShellSort(int num[]) &#123;</span><br><span class="line">    int temp;</span><br><span class="line">    &#x2F;&#x2F;默认步长为数组长度除以2</span><br><span class="line">    int step &#x3D; num.length;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        step &#x3D; step &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F;确定分组数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; step; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;对分组数据进行直接插入排序</span><br><span class="line">            for ( int j &#x3D; i + step; j &lt; num.length; j &#x3D; j + step) &#123;</span><br><span class="line">                temp&#x3D;num[j];</span><br><span class="line">                int k;</span><br><span class="line">                for( k&#x3D;j-step;k&gt;&#x3D;0;k&#x3D;k-step)&#123;</span><br><span class="line">                    if(num[k]&gt;temp)&#123;</span><br><span class="line">                        num[k+step]&#x3D;num[k];</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num[k+step]&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (step &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-9"><a href="#特点分析-9" class="headerlink" title="特点分析"></a>特点分析</h3>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：链表</title>
    <url>/2020/03/20/offer01/</url>
    <content><![CDATA[<h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><blockquote>
<p>题目描述：输入一个链表，输出该链表中倒数第k个节点。</p>
</blockquote>
<p>虽然最直观的思路往往不是最优解，但是我们在做算法题的时候还是需要从最直观的解法出发，不断优化现有思路或者参考他人解法来获取新的idea来解决问题，这样才能达到思维层面上的进步。<br>就这题而言，最直观的解法显然是先遍历链表，找到链表的长度length,然后再找到第length-k+1位置处的节点，就是需要的倒数第k个节点。那么可以很快的写出下面代码：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 解题思路一：找到链表的长度n，再从头开始找n-k+1的链表的位置就是第k个节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;边界条件</span><br><span class="line">    if(head &#x3D;&#x3D; null || k &lt; 1)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int index &#x3D; 1;</span><br><span class="line">    ListNode pNext &#x3D; head;</span><br><span class="line">    while(pNext !&#x3D; null)&#123;</span><br><span class="line">        pNext &#x3D; pNext.next;</span><br><span class="line">        index ++;</span><br><span class="line">    &#125;</span><br><span class="line">    int len &#x3D; index;</span><br><span class="line">    &#x2F;&#x2F;如果倒数第k个节点不存在的边界条件</span><br><span class="line">    if(k &gt; len)&#123;</span><br><span class="line">       return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;找到第n-k+1个节点的值返回</span><br><span class="line">    int count &#x3D; 1;</span><br><span class="line">    ListNode pn &#x3D; head;</span><br><span class="line">     while(count &lt;&#x3D; len-k+1)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        pn &#x3D; pn.next;</span><br><span class="line">        if(count &#x3D;&#x3D; len-k+1)&#123;</span><br><span class="line">           return pn;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做完之后，结果当然是可以通过的，但是需要优化的地方也很明显，那就是上述解法遍历了两次链表，这显然是造成了冗余，那么优化的方向就是只遍历一次就可以获取我们需要的结果，根据这个思路，我们实际上可以想到双指针思路，这个在链表题目中经常遇到的思路显然也适合这里。</p>
<p>于是我们可以使用双指针，第一个指针先遍历链表到第k-1个节点位置，然后当第一个指针到第k个节点位置时，第二个指针开始从第一个节点处遍历，这样当第一个指针遍历到最后一个节点时，第二个指针的位置刚好是第length-k+1的位置，也就是倒数第k个节点的位置。这样一次遍历就可以完成我们需要的结果。</p>
<p>然后就不假思索的写出以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode FindKthToTail1(ListNode head,int k)&#123;</span><br><span class="line">  if(head &#x3D;&#x3D; null || k &lt; 1)&#123;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode pFast &#x3D; head;</span><br><span class="line">  ListNode pLow &#x3D; head;</span><br><span class="line">  int index &#x3D; 1;</span><br><span class="line">  while(pFast.next !&#x3D; null)&#123;</span><br><span class="line">     pFast &#x3D; pFast.next;</span><br><span class="line">     if(index &gt;&#x3D; k)&#123;</span><br><span class="line">         pLow &#x3D; pLow.next;</span><br><span class="line">      &#125;</span><br><span class="line">     index++;</span><br><span class="line">   &#125;</span><br><span class="line">    return pLow;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>然后就发现只能通过测试用例的50%，为什么呢，呵呵……其实稍微注意一点应该能看到，在最开始的思路中我们是判断过边界条件k &lt; length的，而下面这种做法显然是没有判断这个边界条件的。。。这就导致如果k是大于链表的长度的，那么就会出现NullPointerException，然而上面的方法是不会抛出空指针异常的，但是跟预期的null结果也是不一样的。这就需要我们处理一下这个问题。<br>那么怎么处理呢？反正不能再遍历链表了，不然跟第一种方法相比就没啥区别，于是我们可以想到一种巧妙的解法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public ListNode FindKthToTail1(ListNode head,int k) &#123;</span><br><span class="line">   if(head &#x3D;&#x3D; null || k &lt; 1)&#123;</span><br><span class="line">        return null;</span><br><span class="line">   &#125;</span><br><span class="line">   ListNode p1 &#x3D; head;</span><br><span class="line">   &#x2F;&#x2F;两个指针移动的代码不放在一起，先让第一个指针走k步</span><br><span class="line">   while(p1 !&#x3D; null &amp;&amp; k-- &gt; 0)&#123;</span><br><span class="line">        p1 &#x3D; p1.next;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;然后在这里就可以加上判空条件了</span><br><span class="line">   &#x2F;&#x2F;如果这时候k不等于0，那么只能说明k有问题了，直接返回null</span><br><span class="line">    if(k &gt; 0) return null;</span><br><span class="line">    ListNode p2 &#x3D; head;</span><br><span class="line">    while(p1 !&#x3D; null)&#123;</span><br><span class="line">        p1 &#x3D; p1.next;</span><br><span class="line">        p2 &#x3D; p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">      return p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h3><blockquote>
<p>题目描述：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
</blockquote>
<p>这个题没什么直观性思路，主要是看知不知道方法，我们需要获取以下几个思路并证明：</p>
<ol>
<li>设置快慢指针，假如有环，他们最后一定相遇。</li>
<li>两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇于环入口。<br>先证明一下：设置快慢指针fast和low，fast每次走两步，low每次走一步。假如有环，两者一定会相遇（因为low一旦进环，可看作fast在后面追赶low的过程，每次两者都接近一步，最后一定能追上）。<br>设：<br>链表头到环入口长度为–a<br>环入口到相遇点长度为–b<br>相遇点到环入口长度为–c<br>则：相遇时<br><code>快指针路程=a+(b+c)k+b</code>，k&gt;=1 其中b+c为环的长度，k为绕环的圈数（k&gt;=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。<br><code>慢指针路程=a+b</code><br>快指针走的路程是慢指针的两倍，所以：<br><code>（a+b）\*2=a+(b+c)k+b</code><br>化简可得：<br><code>a=(k-1)(b+c)+c</code> 这个式子的意思是： <em>链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度</em>。其中<code>k&gt;=1</code>,所以<code>k-1&gt;=0</code>圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode EntryNodeOfLoop(ListNode pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead &#x3D;&#x3D; null || pHead.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow &#x3D; pHead;</span><br><span class="line">        ListNode fast &#x3D; pHead;</span><br><span class="line">        while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next.next;</span><br><span class="line">            &#x2F;&#x2F;到相遇点</span><br><span class="line">            if(slow &#x3D;&#x3D; fast)&#123;</span><br><span class="line">                fast &#x3D; pHead;</span><br><span class="line">                while(slow !&#x3D; fast)&#123;</span><br><span class="line">                    slow &#x3D; slow.next;</span><br><span class="line">                    fast &#x3D; fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if(slow &#x3D;&#x3D; fast)&#123;</span><br><span class="line">                    return slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><blockquote>
<p>题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<p>这个题目的话思路就比较简单，借助一个栈来解决问题的话就只需要遍历一次链表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if(listNode &#x3D;&#x3D; null)&#123;</span><br><span class="line">         return list;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    while(listNode !&#x3D; null)&#123;</span><br><span class="line">       stack.push(listNode.val);</span><br><span class="line">       listNode &#x3D; listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">       list.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中的重复节点"><a href="#删除链表中的重复节点" class="headerlink" title="删除链表中的重复节点"></a>删除链表中的重复节点</h3><blockquote>
<p>删除链表中的重复节点</p>
</blockquote>
<p>这个题的话，我们需要处理两个问题：</p>
<ol>
<li>判断多节点重复问题</li>
<li>将重复节点的前一个不重复节点的next指向下一个不重复的节点<br>如果上面两个问题能解决的话，那么这个问题就迎刃而解了。<br>为了解决第一个问题，比较好的思路应该是递归查找，即如果有两个节点重复了，那么我们在这两个节点重复的基础上继续往下查找看是否重复，这样找到所有重复的节点后，我们就可以解决第二个问题了，那么整个问题就可以解决了。<br>基于上述思路，我们可以写出如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode deleteDuplication(ListNode pHead)&#123;</span><br><span class="line">   &#x2F;&#x2F;边界条件</span><br><span class="line">   if(pHead &#x3D;&#x3D; null || pHead.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">       return pHead;</span><br><span class="line">   &#125;</span><br><span class="line">   ListNode next &#x3D; pHead.next;</span><br><span class="line">   if(pHead.val &#x3D;&#x3D; next.val)&#123;</span><br><span class="line">       &#x2F;&#x2F;保证重复的节点的前一个节点与后面比重复节点的值要大的节点相连</span><br><span class="line">       &#x2F;&#x2F;判断多节点重复</span><br><span class="line">       while(next !&#x3D; null &amp;&amp; pHead.val &#x3D;&#x3D; next.val)&#123;</span><br><span class="line">           &#x2F;&#x2F;跳过值与当前节点相同的全部节点，找到第一个值不同的节点</span><br><span class="line">           next &#x3D; next.next;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;从第一个与当前不同的节点开始递归</span><br><span class="line">       return deleteDuplication(next);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;当前节点不是重复节点</span><br><span class="line">        pHead.next &#x3D; deleteDuplication(pHead.next); &#x2F;&#x2F;保留当前节点，从下一个节点开始递归</span><br><span class="line">        return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：位操作</title>
    <url>/2020/03/25/offer04/</url>
    <content><![CDATA[<h3 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a>位1的个数</h3><blockquote>
<p>题目描述： 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数。</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题的解法比较多，有位移法、位操作法、查表法、二次查表法等方法。甚至在java的工具类下面有一个bitCount()方法可以直接返回一个整数的二进制表达式中1的个数。<br>但是一般如果面试题中遇到这题，往往还是考察对位操作的使用。</p>
<a id="more"></a>
<p>观察一下 n 与 n-1 这两个数的二进制表示：对于 n-1这个数的二进制来说，相对于n的二进制，它的最末位的一个 1 会变成 0，最末位一个 1之后的0 会全部变成 1，其它位相同不变。<br>比如<code>n = 8888</code>，其二进制为 <code>10001010111000</code><br>则 <code>n - 1 = 8887</code> ，其二进制为<code>10001010110111</code><br>通过按位与操作后：<code>n &amp; (n-1) = 10001010110000</code><br>也就是说：通过<code>n&amp;(n-1)</code>这个操作，可以起到消除最后一个1的作用。所以可以通过执行 <code>n&amp;(n-1)</code> 操作来消除 n 末尾的 1 ，消除了多少次，就说明有多少个 1 。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">    int cnt &#x3D; 0;</span><br><span class="line">    while (n !&#x3D; 0) &#123;</span><br><span class="line">       cnt++;</span><br><span class="line">       n &amp;&#x3D; (n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者可以直接用jdk自带函数解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int NumberOf11(int n) &#123;</span><br><span class="line">   return Integer.bitCount(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h3><blockquote>
<p>题目描述：给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先，先来分析一下 2 的次方数的二进制写法：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">4</th>
<th align="center">8</th>
<th align="center">16</th>
<th align="center">···</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">10</td>
<td align="center">100</td>
<td align="center">1000</td>
<td align="center">10000</td>
<td align="center">···</td>
</tr>
</tbody></table>
<p>仔细观察，可以看出 2 的次方数都只有一个 1 ，剩下的都是 0 。根据这个特点，只需要每次判断最低位是否为 1 ，然后向右移位，最后统计 1 的个数即可判断是否是 2 的次方数。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isPowerOfTwo(int n)&#123;</span><br><span class="line">    int cnt &#x3D; 0;</span><br><span class="line">    while(n &gt; 0)&#123;</span><br><span class="line">        cnt +&#x3D; (n &amp; 1);</span><br><span class="line">        n &gt;&gt;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt &#x3D;&#x3D; 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该题还有一种巧妙的解法。再观察上面的表格，如果一个数是 2 的次方数的话，那么它的二进数必然是最高位为1，其它都为 0 ，那么如果此时我们减 1 的话，则最高位会降一位，其余为 0 的位现在都为变为 1，那么我们把两数相与，就会得到 0。<br>比如 2 的 3 次方为 8，二进制位 1000 ，那么 8 - 1 = 7，其中 7 的二进制位0111。<br>利用这个性质，只需一行代码就可以搞定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isPowerOfTwo(int n)&#123;</span><br><span class="line">    return (n &gt; 0) &amp;&amp; (!(n &amp; (n - 1)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数字的范围按位与"><a href="#数字的范围按位与" class="headerlink" title="数字的范围按位与"></a>数字的范围按位与</h3><blockquote>
<p>题目描述：给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
</blockquote>
<p>比如：输入<code>[26,30]</code><br>输出：24</p>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先，将<code>[ 26 , 30 ]</code> 的范围数字用二进制表示出来：<br>11010　　11011　　11100　　11101　　11110<br>而输出 24 的二进制是 11000 。<br>可以发现，只要找到二进制的 左边公共部分 即可。<br>所以，可以先建立一个 32 位都是 1 的 mask，然后每次向左移一位，比较 m 和 n 是否相同，不同再继续左移一位，直至相同，然后把 m 和 mask 相与就是最终结果。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int rangeBitwiseAnd(int m,int n)&#123;</span><br><span class="line">        int d &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        while ((m &amp; d) !&#x3D; (n &amp; d)) &#123;</span><br><span class="line">            d &lt;&lt;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return m &amp; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重复的DNA序列"><a href="#重复的DNA序列" class="headerlink" title="重复的DNA序列"></a>重复的DNA序列</h3><blockquote>
<p>题目描述：所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。编写一个函数来查找 DNA 分子中所有出现超过一次的 10 个字母长的序列（子串）</p>
</blockquote>
<p>例如：<br>输入:<code>s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</code><br>输出:<code>[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]</code></p>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先，依旧先将 A , C , G , T 的 ASCII 码用二进制来表示：<br>A: 0100 0001　　C: 0100 0011　　G: 0100 0111　　T: 0101 0100<br>通过观察发现每个字符的后三位都不相同，因此可以用末尾的三位来区分这四个字符。<br>题目要求是查找 10 个字母长的序列，这里我们将每个字符用三位来区分的话，10 个字符就需要 30 位 ，在32位机上也 OK 。<br>为了提取出后 30 位，需要使用 mask ，取值为 0x7ffffff（二进制表示含有 27 个 1） ，先用此 mask 可取出整个序列的后 27 位，然后再向左平移三位可取出 10 个字母长的序列 （ 30 位）。<br>为了保存子串的频率，这里使用哈希表。<br>首先当取出第十个字符时，将其存在哈希表里，和该字符串出现频率映射，之后每向左移三位替换一个字符，查找新字符串在哈希表里出现次数，如果之前刚好出现过一次，则将当前字符串存入返回值的数组并将其出现次数加一，如果从未出现过，则将其映射到 1。<br>举个栗子：<br>根据题意，第一个操作：首先取出前九个字符 AAAAACCCC ，根据上面的分析，用三位来表示一个字符，所以这九个字符可以用二进制表示为 001001001001001011011011011，<br>第二个操作：开始遍历字符串，下一个进来的是 C ，则当前字符为 AAAAACCCCC ，二进制表示为001001001001001011011011011011，然后将其存入哈希表中。然后再读入下一个字符 A，则此时字符串为AAAACCCCCA，依旧使用二进制进行表示。<br>以此类推，当某个序列之前已经出现过了，只需要将其存入结果 res 中即可 。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if (s.size() &lt;&#x3D; 10) return res;</span><br><span class="line">        int mask &#x3D; 0x7ffffff, cur &#x3D; 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; m;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;</span><br><span class="line">            cur &#x3D; (cur &lt;&lt; 3) | (s[i] &amp; 7);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 9; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            cur &#x3D; ((cur &amp; mask) &lt;&lt; 3) | (s[i] &amp; 7);</span><br><span class="line">            if (m.count(cur)) &#123;</span><br><span class="line">                if (m[cur] &#x3D;&#x3D; 1) res.push_back(s.substr(i - 9, 10));</span><br><span class="line">                ++m[cur]; </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                m[cur] &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>位操作</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：树</title>
    <url>/2020/03/23/offer03/</url>
    <content><![CDATA[<h3 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h3><blockquote>
<p>题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>其中树的结构代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TreeLinkNode &#123;</span><br><span class="line">   int val;</span><br><span class="line">   TreeLinkNode left &#x3D; null;</span><br><span class="line">   TreeLinkNode right &#x3D; null;</span><br><span class="line">   TreeLinkNode next &#x3D; null; &#x2F;&#x2F;指向父节点</span><br><span class="line"></span><br><span class="line">   TreeLinkNode(int val) &#123;</span><br><span class="line">       this.val &#x3D; val;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先，注明了是中序遍历的下一个节点，那么需要先研究中序遍历树的特征。比如如下二叉树：<br><img src="/img/03offer/tree-example.png" alt="tree-example"><br>显然中序遍历结果为：9 5 8 2 1 3 6 7 3 4 10<br>那么将凌乱的思路整理一下，其实我们再想一想，其实我们只需要抓住一个关键点进行突破就可以了，那就是给定的节点是否有右子树，分为两种情况：</p>
<ol>
<li>若给定的节点有右子树，如上图的节点5，那么显然5的下一个节点的值应该是8，也就是其右子树的最后一层的左子节点的值。这个实现可以使用递归获取值即可，那么这个问题就轻而易举的解决了。</li>
<li>另外一种情况就是给定的节点没有右子树，这个情况就比较复杂了，也很难想到（所以为啥要刷算法题，毕竟算法又不是你发明的…解决问题的思路还是得学一学的）。最简单的情况就是上面的左下角的9，显然9是没有右子树的，那么它的下一个节点实际上就是它的父节点5；最复杂的情况，就是2的右子节点1，它也没有右子树，但是它的下一个节点应该是根节点3。<br>所以针对上面的第二种情况，最终需要将这两种简单和复杂情况合并，那么有没有这种方法呢？<br>那么当然是可以有的，由于题目特别说明这个树的节点是包含指向父节点的指针的，那么根据这个特性，我们可以再思考一下：<br>实际上只要循环找到当前节点的父节点的左子节点等于当前节点，那么这个问题就被KO了<br>局部代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (pNode.next !&#x3D; null) &#123;</span><br><span class="line">     TreeLinkNode parent &#x3D; pNode.next;</span><br><span class="line">     if (parent.left &#x3D;&#x3D; pNode) &#123;</span><br><span class="line">         return parent;</span><br><span class="line">     &#125;</span><br><span class="line">     pNode &#x3D; pNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中pNode是给定的节点，我们最终是要找pNode的下一个节点。<br>根据上述代码，对于节点9，上面显然可以得其下一个节点是5，结果正确。<br>对于节点1，根据上面循环往上找，最终确实找到了其下一个节点是3，结果正确。<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4>综合上述思路，最终可以整理代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public TreeLinkNode GetNext(TreeLinkNode pNode) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果有右子树，则找右子树的最左节点</span><br><span class="line">   if (pNode.right !&#x3D; null) &#123;</span><br><span class="line">       TreeLinkNode node &#x3D; pNode.right;</span><br><span class="line">        while (node.left !&#x3D; null) &#123;</span><br><span class="line">             node &#x3D; node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F;没有右子树，向上找第一个左链接指向的树包含该节点的祖先节点</span><br><span class="line">       while (pNode.next !&#x3D; null) &#123;</span><br><span class="line">          TreeLinkNode parent &#x3D; pNode.next;</span><br><span class="line">          if (parent.left &#x3D;&#x3D; pNode) &#123;</span><br><span class="line">              return parent;</span><br><span class="line">          &#125;</span><br><span class="line">          pNode &#x3D; pNode.next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><blockquote>
<p>题目描述：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题其实思路上难度不是很大，只要画个图，就可以看明白一半。<br><img src="/img/03offer/tree-sym.png" alt="tree-sym"><br>如上图就属于题目描述的对称二叉树的一种，那么显然，只需要我们确定一个根节点下的左子节点的值和右子节点的值是否相同就可以，只要有一个不同，那么就不是对称二叉树。具体过程可以使用递归来完成。</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isSymmetrical(TreeNode pRoot) &#123;</span><br><span class="line">    if(pRoot &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">     return isSym(pRoot,pRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否相等</span><br><span class="line">private boolean isSym(TreeNode root1,TreeNode root2)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果递归中root1为null，root2不为null，那么说明不对称</span><br><span class="line">    &#x2F;&#x2F;如果root1&#x3D;root2&#x3D;null，那么说明递归完成后没有返回false说明完全对称，即返回true</span><br><span class="line">   if(root1 &#x3D;&#x3D; null)&#123;</span><br><span class="line">      return root2 &#x3D;&#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;由于上面先判断了root1&#x3D;&#x3D;null，所以如果进入了这一步，说明root1 !&#x3D; null</span><br><span class="line">    &#x2F;&#x2F;但是root2先到null了，这说明存在不对称的部分，直接返回false</span><br><span class="line">   if(root2 &#x3D;&#x3D; null)&#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;判断值是否相同</span><br><span class="line">   if(root1.val !&#x3D; root2.val)&#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;递归调用</span><br><span class="line">   return isSym(root1.left,root2.right) &amp;&amp; isSym(root1.right,root2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h3><blockquote>
<p>题目描述：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题本质上就是层序遍历，不过一般我们只使用了前序遍历、中序遍历、后序遍历，对于层序遍历，涉及的不是很多。并且这个题还需要将输出结果转换成ArrayList存储的形式，即每行的结果都是一个ArrayList，这是这个题目稍微需要拐弯的地方。<br>那么对于树，其实绝大多数情况下都可以使用递归来解决问题。这个题需要解决的问题有：</p>
<ol>
<li>先确定这颗二叉树的深度，即有多少行，这样才可以创建ArrayList的个数</li>
<li>剩下的添加节点完全可以使用递归实现<h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    depth(pRoot, 1, list);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void depth(TreeNode root, int depth, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list) &#123;</span><br><span class="line">   if (root &#x3D;&#x3D; null) return;</span><br><span class="line">   if (depth &gt; list.size())&#123;</span><br><span class="line">       list.add(new ArrayList&lt;&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   list.get(depth - 1).add(root.val);</span><br><span class="line"></span><br><span class="line">   depth(root.left, depth + 1, list);  </span><br><span class="line">   depth(root.right, depth + 1, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="二叉搜索树的第k个节点"><a href="#二叉搜索树的第k个节点" class="headerlink" title="二叉搜索树的第k个节点"></a>二叉搜索树的第k个节点</h3><blockquote>
<p>题目描述：给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p>
</blockquote>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>对于一颗二叉搜索树而言，其实际结构就是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   7</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">2  4 6  8</span><br></pre></td></tr></table></figure>
<p>这种情况下有一个非常好的特点，那就是二叉搜索树的中序遍历的结果恰好是按照大小顺序排列的。</p>
<h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><p>基于上述结论，实际上可以立马写出如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：中序遍历二叉搜索树</span><br><span class="line">TreeNode KthNode(TreeNode pRoot, int k) &#123;</span><br><span class="line">   if(pRoot &#x3D;&#x3D; null) return null;</span><br><span class="line"></span><br><span class="line">   ArrayList&lt;TreeNode&gt; arr &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">   midSeek(pRoot,arr);</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F;获取节点的个数，并与k比较</span><br><span class="line">   if(k &lt;&#x3D; 0 || k &gt; arr.size())&#123;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return arr.get(k-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">private void midSeek(TreeNode pRoot,ArrayList&lt;TreeNode&gt; arr)&#123;</span><br><span class="line">     if(pRoot.left !&#x3D; null)&#123;</span><br><span class="line">        midSeek(pRoot.left,arr);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     arr.add(pRoot);</span><br><span class="line">    </span><br><span class="line">     if(pRoot.right !&#x3D; null)&#123;</span><br><span class="line">        midSeek(pRoot.right,arr);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上面代码实际上有一些冗余，并不是最优解，因为是先将中序遍历结果全部找出来，再挑第k个值。那么按照老套路，是不是可以想个办法，在中序遍历的时候就直接一次性找出第k个值呢？答案是显然可以的。<br>优化后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   int index &#x3D; 0; &#x2F;&#x2F;计数器</span><br><span class="line">    TreeNode KthNode(TreeNode root, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root !&#x3D; null)&#123; &#x2F;&#x2F;中序遍历寻找第k个</span><br><span class="line">            TreeNode node &#x3D; KthNode(root.left,k);</span><br><span class="line">            if(node !&#x3D; null)</span><br><span class="line">                return node;</span><br><span class="line">            index ++;</span><br><span class="line">            if(index &#x3D;&#x3D; k)</span><br><span class="line">                return root;</span><br><span class="line">            node &#x3D; KthNode(root.right,k);</span><br><span class="line">            if(node !&#x3D; null)</span><br><span class="line">                return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：数组</title>
    <url>/2020/03/28/offer05/</url>
    <content><![CDATA[<h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><blockquote>
<p>题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>数组类题目解题往往是存在直观解法的，因为不管是一维数组还是二维数组，都可以直接通过双重for循环之类方法进行直接求解，但是这种解法的时间复杂度都是很高的，为此，在算法类题目中涉及到数组，往往不会使用多重循环求解。</p>
<a id="more"></a>

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度为O(n^2)</span><br><span class="line">public static boolean duplicate(int[] numbers, int length, int[] duplication) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; length; j++) &#123;</span><br><span class="line">           if(numbers[i] &#x3D;&#x3D; numbers[j])&#123;</span><br><span class="line">               duplication[0] &#x3D; numbers[i];</span><br><span class="line">               return true;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个双重for循环可以直接搞定，但是问题来了，上面解法时间复杂度显然为O(n^2)，这种复杂度对于海量数据求解来说，是很不可取的。<br>那么我们可以再次进行优化一下，我们可以对数组进行排序，这样算法复杂度会降低，于是可以以下面代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度为O(nlogn)</span><br><span class="line">public static boolean duplicate(int[] numbers, int length, int[] duplication) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; length ; i++)&#123;</span><br><span class="line">        list.add(numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list); &#x2F;&#x2F;时间复杂度为O(NlogN)</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; list.size() ; i++)&#123;</span><br><span class="line">        if(i+1 &lt; list.size())&#123;</span><br><span class="line">            if(list.get(i) &#x3D;&#x3D; list.get(i+1))&#123;</span><br><span class="line">               duplication[0] &#x3D; list.get(i);</span><br><span class="line">               return true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上述还不是最优解，假如我们要求时间复杂度为O(n)，空间复杂度为O(1)，在这个前提下，我们需要再寻求一种最优解。<br>那么我们需要注意到题目中有一个条件是<em>长度为n的数组里面所有数字都在0~n-1范围内</em>，这个条件肯定不是白给的，上面两种解题思路都没有用到这个条件，那么这个条件肯定就是解题的关键。<br>根据上面思路，如果这个数组中没有重复的数字，那么当数组排序后，数字i将出现在下标为i的位置，但是由于数组中一定有重复的数字，那么有些位置可能存在多个数字，同时有些位置可能没有数字。<br>比如对于数组<code>[2,3,1,0,2,5,3]</code></p>
<ol>
<li>首先从头到尾扫描这个数组，当扫描到下标为i 的数字时，比较这个数字（比如为m）是不是等于i</li>
<li>如果是，那么接着扫描下一个数字</li>
<li>如果不是，那么拿这个数字跟第m个数字进行比较。</li>
<li>如果这个数字跟第m个数字相等，那么这个数字就是其中一个重复数字，结束寻找</li>
<li>如果不等，将把第i个数字和第m个数字交换，即把m放到属于它的位置</li>
<li>重复上述过程，直到发现一个重复的数字。<br>根据上述思路，我们可以写出最终优化的代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean duplicate(int[] numbers,int length,int[] duplication) &#123;</span><br><span class="line">      &#x2F;&#x2F;考虑边界条件</span><br><span class="line">      if(numbers &#x3D;&#x3D; null || length &lt;&#x3D; 0)&#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i &#x3D; 0; i &lt; length-1; i++)&#123;</span><br><span class="line">          while (numbers[i] !&#x3D; i)&#123;</span><br><span class="line">              if(numbers[i] &#x3D;&#x3D; numbers[numbers[i]])&#123;</span><br><span class="line">                  duplication[0] &#x3D; numbers[i];</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">              swap(numbers,i,numbers[i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void swap(int[] nums,int i,int j)&#123;</span><br><span class="line">      int temp &#x3D; nums[i];</span><br><span class="line">      nums[j] &#x3D; nums[i];</span><br><span class="line">      nums[i] &#x3D; temp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="二维数组的查找"><a href="#二维数组的查找" class="headerlink" title="二维数组的查找"></a>二维数组的查找</h3><blockquote>
<p>题目描述：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>那么显然同上一题，这个题还是可以通过双重for循环直接解决，并且代码十分简洁。但是还是那个问题，最直观的解法往往不是最优解，题目给了那么多条件，仅仅通过一个双重for循环完成，时间复杂度是非常高的。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>根据题目条件，实际上不难想出另外一种解法：<br>比如对于如下二维数组，我们要查找数字7：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2  8  9</span><br><span class="line">2  4  9  12</span><br><span class="line">4  7  10 13</span><br><span class="line">6  8  11 15</span><br></pre></td></tr></table></figure>
<p>由于数组从左到右递增，从上到下递增，我们可以试图先选一个边角的值，比如右上角的9，这个值比它左边的值都要大，比它下面的值都要小。<br>那么这个值比要找的7要大，说明7不可能在9这一列了，于是我们把这一列去掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2  8</span><br><span class="line">2  4  9</span><br><span class="line">4  7  10</span><br><span class="line">6  8  11</span><br></pre></td></tr></table></figure>
<p>继续选取右上角的值，我们发现8还是比7要大，于是8这一列的值也可以删掉了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2</span><br><span class="line">2  4</span><br><span class="line">4  7</span><br><span class="line">6  8</span><br></pre></td></tr></table></figure>
<p>然后选取右上角的值2，由于2比7小，那么说明2所在的一行不可能包括7，那么把这一行删掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2  4</span><br><span class="line">4  7</span><br><span class="line">6  8</span><br></pre></td></tr></table></figure>
<p>由于右上角的4比7要小，那么同样可以删掉这一行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4  7</span><br><span class="line">6  8</span><br></pre></td></tr></table></figure>
<p>最终右上角的值就是我们要找的值，那么这种办法实际上避免了双重循环的冗余度，可以很快的找到是否包括需要查找的值。并且在数据量越大的时候，越能体会到这种算法的时间优越性。这就是算法的实用性所在。<br>基于上述思路，代码实现可以如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">    boolean flag &#x3D; false;</span><br><span class="line">    if(array !&#x3D; null &amp;&amp; array.length &gt; 0 &amp;&amp; array[0].length &gt; 0)&#123;</span><br><span class="line">        int row &#x3D; 0 ;</span><br><span class="line">        int columns &#x3D; array[0].length;</span><br><span class="line">        int column &#x3D;  columns - 1;</span><br><span class="line">        while(row &lt; array.length &amp;&amp; column &gt;&#x3D; 0)&#123;</span><br><span class="line">            if(array[row][column] &#x3D;&#x3D; target)&#123;</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(array[row][column] &gt; target)&#123;</span><br><span class="line">                &#x2F;&#x2F;如果右上角元素的值比目标值要大，就删除最后一列</span><br><span class="line">                column--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;如果右上角元素的值比目标值要小，就删除最上面一行</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h3><blockquote>
<p>题目描述：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果没有不能使用除法的限制，那么这个题目可以直接使用公式解出来，即将<code>(A[0]*A[1]*...*A[n-1])/A[i]</code>即可得到结果。<br>既然不能用除法，那么只能寻找其他思路。</p>
<ol>
<li>直接按题目要求连乘，显然时间复杂度为O(n^2)</li>
<li>有吗？<br>当然有，我们基于题目算法可以构建矩阵如下：<br><img src="/img/03offer/array-multi.png" alt="array-multi"><br>其中B[i]的值可以看作下图的矩阵中每行的乘积。<br>下三角用连乘可以很容求得，上三角，从下向上也是连乘。<br>因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] multiply(int[] A) &#123;</span><br><span class="line">        int length &#x3D; A.length;</span><br><span class="line">        int[] B &#x3D; new int[length];</span><br><span class="line">        if(length !&#x3D; 0 )&#123;</span><br><span class="line">            B[0] &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F;计算下三角连乘</span><br><span class="line">            for(int i &#x3D; 1; i &lt; length; i++)&#123;</span><br><span class="line">                B[i] &#x3D; B[i-1] * A[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            int temp &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F;计算上三角</span><br><span class="line">            for(int j &#x3D; length-2; j &gt;&#x3D; 0; j--)&#123;</span><br><span class="line">                temp *&#x3D; A[j+1];</span><br><span class="line">                B[j] *&#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：递归与循环</title>
    <url>/2020/03/21/offer02/</url>
    <content><![CDATA[<h3 id="斐波拉契数列"><a href="#斐波拉契数列" class="headerlink" title="斐波拉契数列"></a>斐波拉契数列</h3><blockquote>
<p>题目描述：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p>
</blockquote>
<p>斐波拉契数列应该是很多学生大一学习C语言时解决的一个问题，我记得那时候好像是用递归算法去解决的，然鹅稍微懂一些数据结构的小伙伴应该都知道，斐波拉契数列是最好不使用递归算法的，为什么呢，因为递归计算斐波拉契数列的时候重复计算项很多，而且越到后面计算量越来越爆炸，最后会导致运行超时，比如栈溢出等exception，如果我们使用递归，代码确实简洁了，比如下面：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int Fibonacci(int n)&#123;</span><br><span class="line">    if(n &lt; 1)  return 0;</span><br><span class="line">    if(n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是比如我们想求解第10项数据的时候，我们以f(10)表示第10项斐波拉契结果，那么用递归运行时会出现下面结构：<br><img src="/img/02offer/fib.png" alt="fib"><br>不难看出，重复的节点会随着n的增大而急剧增大，事实上也是，用递归方法计算的时间复杂度是以n的指数方式递增的，不妨可以使用递归计算一下Fibonacci的第100项，看看会慢到什么程度。<br>所以实用解法肯定不是这种啦。<br>而改进方法，实际上目的就是为了避免上面的重复计算，那么我们实际上用一个数列保存已经计算过的数。于是我们可以写出如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">   if(n &lt; 1)&#123;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2)&#123;</span><br><span class="line">       return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   if(n &#x3D;&#x3D; 3)&#123;</span><br><span class="line">       return 2;</span><br><span class="line">   &#125;</span><br><span class="line">   int fib1 &#x3D; 1;</span><br><span class="line">   int fib2 &#x3D; 2;</span><br><span class="line">   int result &#x3D; 0;</span><br><span class="line">   for(int i &#x3D; 3 ; i &lt; n ; i++)&#123;</span><br><span class="line">       result &#x3D; fib1 + fib2;</span><br><span class="line">       fib1 &#x3D; fib2;</span><br><span class="line">       fib2 &#x3D; result;</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就可以简约的搞定问题了！</p>
<h3 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h3><blockquote>
<p>题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<p>首先我们可以从最简单的情况开始考虑，如果只有一级台阶，那显然只能跳一次。如果有两级台阶，那么就有两种跳法：一种是每次跳一级；另一种是一次跳两级。<br>然后我们将这种情况一般化，假如有n级台阶，可以把跳n级台阶的跳法看作是n的函数f(n)。当n&gt;2时，第一次跳的时候就有两种选择：<br>第一次跳一级，那么跳法数目等于后面的n-1级台阶的跳法数目，即为f(n-1)。<br>第一次跳两级，那么跳法数目等于后面的n-2级台阶的跳法数目，即为f(n-2)。<br>因此，n级台阶的不同跳法数目的总数为f(n)=f(n-1)+f(n-2)，到这里应该可以看出，说到底这个问题就是一个包装的斐波拉契数列问题。<br>那么代码其实跟上面的没啥区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public int JumpFloor(int target) &#123;</span><br><span class="line">    if(target &lt;&#x3D; 2)&#123;</span><br><span class="line">       return target;</span><br><span class="line">    &#125;</span><br><span class="line">    int pre1 &#x3D; 1;</span><br><span class="line">    int pre2 &#x3D; 2;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 2;i &lt; target; i++)&#123;</span><br><span class="line">        result &#x3D; pre1 + pre2;</span><br><span class="line">        pre1 &#x3D; pre2;</span><br><span class="line">        pre2 &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="变态青蛙跳台阶"><a href="#变态青蛙跳台阶" class="headerlink" title="变态青蛙跳台阶"></a>变态青蛙跳台阶</h3><blockquote>
<p>题目描述：这次这只青蛙很变态，一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>这个其实问题更不大，这本质上就是一个简单的数学问题，我们可以根据上面那个问题归纳这个问题：<br>跳n级台阶时，这时候跳法就很多了：<br>第一次跳一级，那么剩下的就是f(n-1)<br>第一次跳两级，那么剩下的就是f(n-2)<br>第一次跳三级，那么剩下的就是f(n-3)<br>….<br>第一次跳n-1级，那么剩下就是f(1).<br>那么实际上就是f(n)=f(n-1)+f(n-2)+f(n-3)+…+f(1)，又因为f(n-1)=f(n-2)+f(n-3)+…+f(1)<br>，所以f(n)=2f(n-1)。<br>到这里应该可以看出来了吧？这不就是一个等比数列吗，并且f(1)=1。<br>那么实际上f(n)=2^(n-1)，完事！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int JumpFloorII1(int target)&#123;</span><br><span class="line">   return (int)java.util.Math.pow(2,target-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h3><blockquote>
<p>题目描述：我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？</p>
</blockquote>
<p>这个就借用<code>牛客网答题者csdong</code>的回答，很简单易懂：<br><img src="/img//02offer/juxing.png" alt="juxing"></p>
<p>所以跟上面的还是没区别。。。依然是老瓶装新酒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int RectCover(int target) &#123;</span><br><span class="line">   if(target &lt;&#x3D; 2)&#123;</span><br><span class="line">       return target;</span><br><span class="line">   &#125;</span><br><span class="line">   int pre1 &#x3D; 1,pre2 &#x3D; 2;</span><br><span class="line">   int result &#x3D; 0;</span><br><span class="line">   for(int i &#x3D; 3; i &lt;&#x3D; target;i++)&#123;</span><br><span class="line">        result &#x3D; pre1 + pre2;</span><br><span class="line">        pre1 &#x3D; pre2;</span><br><span class="line">        pre2 &#x3D; result;</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>递归与循环</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：时间效率</title>
    <url>/2020/04/01/offer06/</url>
    <content><![CDATA[<h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><blockquote>
<p>题目描述：HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>第一次看到这个题的时候，最直观的思路应该是想办法枚举所有子数组并求其和，但是一个长度为n的数组，枚举的子数组共有n(n+1)/2个，因此最快也需要O(n^2)时间。在算法题目中，凡是面对这种复杂度的解法，往往是不考虑这种解法的。</p>
<a id="more"></a>
<p>以下解法均以数组<code>aray = {1，-2，3，10，-4，7，2，-5}</code>为例，该数组的最大和数组为<code>{3,10,-4,7,2}</code>，最大和为18。</p>
<h4 id="解法一：分析数组的规律"><a href="#解法一：分析数组的规律" class="headerlink" title="解法一：分析数组的规律"></a>解法一：分析数组的规律</h4><p>可以先试着从头到尾累加数组中的每个数字。初始化和为0，第一次加上1，此时和为1。第二步加上-2，和变成了-1，如果再加上第三个数字3，我们注意到此前累加的和是-1，加上3后和为2，累加和的结果比3本身还要小。也就是说，从第一个数字开始的子数组的和比从第三个数字开始的子数组的和要小。因此，我们完全没有必要考虑从第一个数字开始的子数组，并且之前累加的和也可以抛弃。<br>然后我们从第三个数字开始累加，此时的和为3，第四步加10后和为13。第五步加上-4后和为9，这时我们发现由于-4是一个负数，那么累加之后的结果比原来的和还要小，因此我们需要把之前得到的累加和13保存下来，因为它有可能是最大子数组的和。然后第六步加上数字7得到和为16比保存的13要大，因此把最大子数组的和从13更新为16，然后再加2得到和为18，那么继续更新最大子数组的和为18。依此类推，最终结果为18。<br>那么我们用表总结一下上述过程：</p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>操作</strong></th>
<th><strong>累加的子数组和</strong></th>
<th><strong>最大的子数组和</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>加1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>加-2</td>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>抛弃前面的和-1，加3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>加10</td>
<td>13</td>
<td>13</td>
</tr>
<tr>
<td>5</td>
<td>加-4</td>
<td>9</td>
<td>13</td>
</tr>
<tr>
<td>6</td>
<td>加7</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>7</td>
<td>加2</td>
<td>18</td>
<td>18</td>
</tr>
<tr>
<td>8</td>
<td>加-5</td>
<td>13</td>
<td>18</td>
</tr>
</tbody></table>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">    if (array.length &#x3D;&#x3D; 0 || array &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int curSum &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;设置一个32位int型整数的最小值(-2)^32，保证第一次一定可以更新最大值</span><br><span class="line">    int greatestSum &#x3D; 0x80000000;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果加的值小于0，保持之前的最大值</span><br><span class="line">        if (curSum &lt;&#x3D; 0) &#123;</span><br><span class="line">            curSum &#x3D; array[i]; &#x2F;&#x2F;记录当前最大值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F;当array[i]为正数时，加上之前的最大值并更新最大值。</span><br><span class="line">            curSum +&#x3D; array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;更新最大值</span><br><span class="line">        if (curSum &gt; greatestSum) &#123;</span><br><span class="line">            greatestSum &#x3D; curSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return greatestSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h4><p>这个题显然还可以使用DP来做，但是DP的状态转移方程比较难想到。<br>f(i)：以<code>array[i]</code>为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变 。<br>那么可以列出转移方程：<code>f(i) = max( f(i-1)+array[i] ，array[i] )</code><br>res：所有子数组的和的最大值 ，那么<code>res=max(res, f(i))</code>。<br>比如对于<code>aray = {1，-2，3，10，-4，7，2，-5}</code>：<br>初始状态：<code>f(0)=1</code>，<code>res=1</code>。</p>
<ol>
<li>当i=1时，<code>f(1)=max(f(0)-2,-2)=-1</code>，那么<code>res=max(1,-2)=1</code>。</li>
<li>当i=2时，f(2)=<code>max(f(1)+3,3)=3</code>，那么<code>res=max(1,3)=3</code>。</li>
<li>当i=3时，f(3)=<code>max(f(2)+10,10)=13</code>，那么<code>res=max(3,13)=13</code>。</li>
<li>当i=4时，<code>f(4)=max(f(3)-4,-4)=9</code>，那么<code>res=max(13,9)=13</code>。</li>
<li>当i=5时，f(5)=<code>max(f(4)+7,7)=16</code>，那么<code>res=max(16,13)=16</code>。</li>
<li>当i=6时，f(6)=<code>max(f(5)+2,2)=18</code>，那么res=<code>max(18,16)=18</code>。</li>
<li>当i=7时，f(7)=<code>max(f(6)-5,-5)=13</code>，那么<code>res=max(13,18)=18</code>。<br>因此最终结果为18。<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int FindGreatestSumOfSubArray1(int[] array) &#123;</span><br><span class="line">    int res &#x3D; array[0]; &#x2F;&#x2F;记录当前所有子数组的和的最大值</span><br><span class="line">    int max &#x3D; array[0];   &#x2F;&#x2F;包含array[i]的连续数组最大值</span><br><span class="line">    for (int i &#x3D; 1; i &lt; array.length; i++) &#123;</span><br><span class="line">        max &#x3D; Math.max(max + array[i], array[i]);</span><br><span class="line">        res &#x3D; Math.max(max, res);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述两种思路的时间复杂度均为O(n)。</li>
</ol>
<h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h3><blockquote>
<p>题目描述：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题最直观的思路，也是能够直接解决问题的解法就是直接对数组进行排序，然后取最小的前k个数就可以了。这种思路的平均时间复杂度为O(nlong)，并且不适合用于海量数据，面试的时候会提示有更快的解法。<br>还有一种思路就是用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，然后新数入堆。这种思路下时间复杂度为O(nlogk)，并且可以处理海量数据。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="解法一：对数组进行排序实现"><a href="#解法一：对数组进行排序实现" class="headerlink" title="解法一：对数组进行排序实现"></a>解法一：对数组进行排序实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123;</span><br><span class="line">    if(input &#x3D;&#x3D; null || input.length &lt;&#x3D; 0 || k &lt;&#x3D; 0 || k &gt; input.length)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; array &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; input.length ; i++)&#123;</span><br><span class="line">        array.add(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(array);</span><br><span class="line">    ArrayList&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; k ; i++)&#123;</span><br><span class="line">        result.add(array.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二：基于最大堆实现"><a href="#解法二：基于最大堆实现" class="headerlink" title="解法二：基于最大堆实现"></a>解法二：基于最大堆实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution1(int[] input, int k) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    int length &#x3D; input.length;</span><br><span class="line">    if(k &gt; length || k &lt; 1)&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;基于最大堆实现</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap &#x3D; new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            return o2.compareTo(o1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (maxHeap.size() !&#x3D; k) &#123;</span><br><span class="line">            maxHeap.offer(input[i]);</span><br><span class="line">        &#125; else if (maxHeap.peek() &gt; input[i]) &#123;</span><br><span class="line">            Integer temp &#x3D; maxHeap.poll();</span><br><span class="line">            temp &#x3D; null;</span><br><span class="line">            maxHeap.offer(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (Integer integer : maxHeap) &#123;</span><br><span class="line">        result.add(integer);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h3><blockquote>
<p>题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>刚看到这个题的时候，最直观的思路应该还是使用排序，这样时间复杂度为O(nlogn)，但是还是那句话，最直观的思路往往不是面试官满意的算法。<br>首先在思路上可以想到，能够使用HashMap，由于HashMap不能存储相同的键，那么把数组中的数字作为键，如果相同，则其值加1，这样最后直接判断HashMap中的键对应的值是否超过了数组的一半即可，并且这种解法时间复杂度为O(n)。<br>除去HashMap之外，针对数组本身，我们还可以想到一种O(n)的解法，那就是只遍历一次数组，在这次遍历中找到其中重复次数最多的数字，然后跟数组长度的一半进行比较。这种解法的时间复杂度也为O(n)。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="解法一：对数组进行排序"><a href="#解法一：对数组进行排序" class="headerlink" title="解法一：对数组进行排序"></a>解法一：对数组进行排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">    Arrays.sort(array);</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">        if(array[i]&#x3D;&#x3D;array[array.length&#x2F;2])&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(count&gt;array.length&#x2F;2)&#123;</span><br><span class="line">        return array[array.length&#x2F;2];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二：使用HashMap"><a href="#解法二：使用HashMap" class="headerlink" title="解法二：使用HashMap"></a>解法二：使用HashMap</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int MoreThanHalfNum_Solution(int[] array) &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">        if(!map.containsKey(array[i]))&#123;</span><br><span class="line">            map.put(array[i],1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int count &#x3D; map.get(array[i]);</span><br><span class="line">            map.put(array[i],++count);</span><br><span class="line">            if(map.get(array[i]) &gt; array.length&#x2F;2)&#123;</span><br><span class="line">                return array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法三：-基于数组本身的特点"><a href="#解法三：-基于数组本身的特点" class="headerlink" title="解法三： 基于数组本身的特点"></a>解法三： 基于数组本身的特点</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">    if(array &#x3D;&#x3D; null || array.length &lt;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    int len &#x3D; array.length;</span><br><span class="line">    int times &#x3D; 1;</span><br><span class="line">    int res &#x3D; array[0];</span><br><span class="line">    &#x2F;&#x2F; 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1</span><br><span class="line">    for(int i &#x3D; 1; i &lt; len; i++)&#123;</span><br><span class="line">        if(times &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            &#x2F;&#x2F; 更新result的值为当前元素，并置次数为1</span><br><span class="line">            res &#x3D; array[i];</span><br><span class="line">            times &#x3D; 1;</span><br><span class="line">        &#125;else if(array[i] &#x3D;&#x3D; res)</span><br><span class="line">            times++;</span><br><span class="line">        else</span><br><span class="line">            times--;</span><br><span class="line">    &#125;</span><br><span class="line">    times &#x3D; 0;</span><br><span class="line">    for(int num : array)</span><br><span class="line">        if(num &#x3D;&#x3D; res)</span><br><span class="line">            times++;</span><br><span class="line">    return (times &gt; len &#x2F; 2)? res : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="整数中1出现的次数"><a href="#整数中1出现的次数" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h3><blockquote>
<p>题目描述：输入一个整数n，求<code>1~n</code>中这n个整数的十进制表示中1出现的次数。例如：输入12，则1~12的整数中1出现的数字有1、10、11和12，1一共出现了5次。</p>
</blockquote>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>设N = abcde ,其中abcde分别为十进制中各位上的数字。 如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字、百位以下（低位）的数字、百位以上（高位）的数字。</p>
<ol>
<li>如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：<code>100~199</code>，<code>1100~1199</code>,<code>2100~2199</code>，，…，<code>11100~11199</code>，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。</li>
<li>如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：<code>100~199</code>，<code>1100~1199</code>,<code>2100~2199</code>，，….，<code>11100~11199</code>，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：<code>12100~12113</code>,一共114个，等于低位数字（113）+1。</li>
<li>如果百位上数字大于1（<code>2~9</code>），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：<code>100~199</code>,<code>1100~1199</code>，<code>2100~2199</code>，…，<code>11100~11199</code>,<code>12100~12199</code>,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int NumberOf1Between1AndN_Solution(int n) &#123;</span><br><span class="line">    int count &#x3D; 0;&#x2F;&#x2F;1的个数</span><br><span class="line">    int i &#x3D; 1;&#x2F;&#x2F;当前位</span><br><span class="line">    int current &#x3D; 0,after &#x3D; 0,before &#x3D; 0;</span><br><span class="line">    while((n&#x2F;i)!&#x3D; 0)&#123;           </span><br><span class="line">        current &#x3D; (n&#x2F;i)%10; &#x2F;&#x2F;高位数字</span><br><span class="line">        before &#x3D; n&#x2F;(i*10); &#x2F;&#x2F;当前位数字</span><br><span class="line">        after &#x3D; n-(n&#x2F;i)*i; &#x2F;&#x2F;低位数字</span><br><span class="line">        &#x2F;&#x2F;如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数</span><br><span class="line">        if (current &#x3D;&#x3D; 0)</span><br><span class="line">            count +&#x3D; before*i;</span><br><span class="line">        &#x2F;&#x2F;如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1</span><br><span class="line">        else if(current &#x3D;&#x3D; 1)</span><br><span class="line">            count +&#x3D; before * i + after + 1;</span><br><span class="line">        &#x2F;&#x2F;如果大于1,出现1的次数由高位决定,&#x2F;&#x2F;（高位数字+1）* 当前位数</span><br><span class="line">        else&#123;</span><br><span class="line">            count +&#x3D; (before + 1) * i;</span><br><span class="line">        &#125;    </span><br><span class="line">        &#x2F;&#x2F;前移一位</span><br><span class="line">        i &#x3D; i*10;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><blockquote>
<p>题目描述：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题目拿到手会有一个直接思路，那就是直接获取所有可能的结果，然后排序获取其中最小的数就可以了，这种暴力解法肯定是零分解法，所以直接pass掉这种思路。<br>其实再仔细想一想，问题实际上并不复杂，要找到这个数组排序的最小值，我们只需要对这个数组进行遍历的时候，找到相邻值进行相加，然后以升序重新排列这个数组即可，最后再按照排序后的结果依次相加即可得到最终的结果。</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String PrintMinNumber(int [] numbers) &#123;</span><br><span class="line">    if(numbers &#x3D;&#x3D; null || numbers.length &lt; 1)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int number : numbers) &#123;</span><br><span class="line">        list.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            String str1 &#x3D; o1 + &quot;&quot; + o2;</span><br><span class="line">            String str2 &#x3D; o2 + &quot;&quot; + o1;</span><br><span class="line">            return str1.compareTo(str2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">    for(int i : list)&#123;</span><br><span class="line">        sb.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：时间效率和空间效率的平衡</title>
    <url>/2020/04/04/offer07/</url>
    <content><![CDATA[<h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><blockquote>
<p>题目描述：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>所谓一个数m是另一个数n的因子，是指n能被m整除，也就是n % m == 0。根据丑数的定义，丑数只能被2、3、5整除，也就是说，如果一个数能被2整除，就连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就连续除以5。如果最后得到的是1，那么这个数就是丑数，否则就不是。</p>
<a id="more"></a>
<p>那么实际上我们可以写出一个函数来判断一个数是不是丑数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean isUglyNumber(int number)&#123;</span><br><span class="line">    while(number % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    while(number % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">    while(number % 5 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return number &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后题目让我们输出从小到大的第N个丑数，这很简单，我们只要对从小到大每个数做一次判断，判断其是否是丑数，如果是，那么统计丑数的次数加1，这样到第N个数就是我们需要的结果了。<br>那么显然你能看出来，这种方法虽然可行，但是效率上来说是十分低下的，因为里面有太多的冗余，那么我们能不能想出更好的办法呢？<br>答案是显然的，由于丑数只包含质因子2、3、5，那么丑数跟丑数相乘的结果肯定是丑数，即一个丑数P = 2^x * 3 ^ y * 5 ^ z，我们可以从2、3、5出发，作为基准数。然后再乘以基准数，就得到4、6、10，6、9、15，10、15、25九个丑数，但是这种乘出来的结果有重复，并且结果是无序的，那么我们只需要处理这个问题就可以。<br>这个问题的处理需要思考一下，实际上1、2、3、4、5、6都是丑数，首先可以想到利用HashSet去重解决问题，但是结果是无序的，这就需要我们重新想办法。<br>其实每次我们只用比较3个数：用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的数。也就是比较(2x , 3y, 5z) ，x&gt;=y&gt;=z的，那么最终就可以依次按照顺序排列了。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="第一种解题思路：暴力解法"><a href="#第一种解题思路：暴力解法" class="headerlink" title="第一种解题思路：暴力解法"></a>第一种解题思路：暴力解法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;判断每个数是不是丑数,效率非常低</span><br><span class="line">public int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">    if(index &lt;&#x3D; 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(index &lt; 7) return index;</span><br><span class="line">    int number &#x3D; 0;</span><br><span class="line">    int uglyFound &#x3D; 0;</span><br><span class="line">    while(uglyFound &lt; index)&#123;</span><br><span class="line">        number++;</span><br><span class="line"></span><br><span class="line">        if(isUglyNumber(number))&#123;</span><br><span class="line">            uglyFound++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isUglyNumber(int number)&#123;</span><br><span class="line">    while(number % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    while(number % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">    while(number % 5 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return number &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二种解法：时间复杂度O-n"><a href="#第二种解法：时间复杂度O-n" class="headerlink" title="第二种解法：时间复杂度O(n)"></a>第二种解法：时间复杂度O(n)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int GetUglyNumber_Solution(int n) &#123;</span><br><span class="line">    if (n &lt;&#x3D; 0) return 0;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;第一个丑数是1</span><br><span class="line">    list.add(1);</span><br><span class="line">    &#x2F;&#x2F;以2 3 5 作为基准数</span><br><span class="line">    int i2 &#x3D; 0, i3 &#x3D; 0, i5 &#x3D; 0;</span><br><span class="line">    while (list.size() &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        int m2 &#x3D; list.get(i2) * 2;</span><br><span class="line">        int m3 &#x3D; list.get(i3) * 3;</span><br><span class="line">        int m5 &#x3D; list.get(i5) * 5;</span><br><span class="line">        int min &#x3D; Math.min(m2, Math.min(m3, m5));</span><br><span class="line">        list.add(min);</span><br><span class="line">        if (min &#x3D;&#x3D; m2) i2++;</span><br><span class="line">        if (min &#x3D;&#x3D; m3) i3++;</span><br><span class="line">        if (min &#x3D;&#x3D; m5) i5++;</span><br><span class="line">    &#125;</span><br><span class="line">    return list.get(list.size() - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h3><blockquote>
<p>题目描述：在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题目比较简单，可以使用Map存储结构解决问题，键为字符，值为字符出现的次数，最终输出第一个值为1的键就行，那么由于有顺序，所以需要使用LinkedHashMap结构进行存储。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line">    if(str &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] cs &#x3D; str.toCharArray();</span><br><span class="line">    Map&lt;Character,Integer&gt; map &#x3D; new LinkedHashMap&lt;&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; cs.length; i++)&#123;</span><br><span class="line">        if(!map.containsKey(cs[i]))&#123;</span><br><span class="line">            map.put(cs[i],1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int val &#x3D; map.get(cs[i]);</span><br><span class="line">            map.put(cs[i],val+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(Map.Entry&lt;Character,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">        if(entry.getValue() &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            return str.indexOf(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><blockquote>
<p>题目描述：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题目有点难度，最终实现是归并排序的改进，把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，合并数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时；则前面数组array[i]~array[mid]都是大于array[j]的，count += mid+1 - i，参考剑指offer书上解析。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int InversePairs(int [] array) &#123;</span><br><span class="line">    if(array&#x3D;&#x3D;null||array.length&#x3D;&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] copy &#x3D; new int[array.length];</span><br><span class="line">    for(int i&#x3D;0;i&lt;array.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[i] &#x3D; array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int count &#x3D; InversePairsCore(array,copy,0,array.length-1);&#x2F;&#x2F;数值过大求余</span><br><span class="line">    return count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int InversePairsCore(int[] array,int[] copy,int low,int high) &#123;</span><br><span class="line">    if(low&#x3D;&#x3D;high)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid &#x3D; (low+high)&gt;&gt;1;</span><br><span class="line">    int leftCount &#x3D; InversePairsCore(array,copy,low,mid)%1000000007;</span><br><span class="line">    int rightCount &#x3D; InversePairsCore(array,copy,mid+1,high)%1000000007;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    int i&#x3D;mid;</span><br><span class="line">    int j&#x3D;high;</span><br><span class="line">    int locCopy &#x3D; high;</span><br><span class="line">    while(i&gt;&#x3D;low&amp;&amp;j&gt;mid)</span><br><span class="line">    &#123;</span><br><span class="line">        if(array[i]&gt;array[j])</span><br><span class="line">        &#123;</span><br><span class="line">            count +&#x3D; j-mid;</span><br><span class="line">            copy[locCopy--] &#x3D; array[i--];</span><br><span class="line">            if(count&gt;&#x3D;1000000007)&#x2F;&#x2F;数值过大求余</span><br><span class="line">            &#123;</span><br><span class="line">                count%&#x3D;1000000007;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            copy[locCopy--] &#x3D; array[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(;i&gt;&#x3D;low;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[locCopy--]&#x3D;array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(;j&gt;mid;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[locCopy--]&#x3D;array[j];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int s&#x3D;low;s&lt;&#x3D;high;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        array[s] &#x3D; copy[s];</span><br><span class="line">    &#125;</span><br><span class="line">    return (leftCount+rightCount+count)%1000000007;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h3><blockquote>
<p>题目描述：输入两个单向链表，找出它们的第一个公共结点。</p>
</blockquote>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先我们需要知道具有公共节点的链表有什么特性。<br><img src="img/03offer/offer-list.png" alt="offer-list"><br>可以看到，这两个单向链表从公共节点开始，后面的节点都是相同的。<br>很多人第一反应是暴力解法，就是第一个链表上顺序遍历每个节点，每遍历一个节点，就在第二个链表上顺序遍历每个节点。这样的找法的时间复杂度是O(mn)，其中链表的长度分别为m、n。<br>那么显然需要换一种思路了，这种两个链表的题目，其实很多时候都用的双指针解法思路，即一个指针先走多少步，达到某个条件的时候另外一个指针就开始遍历，这样只用遍历一次链表就可以完成，这是常用的解决办法，当然也适用于本题。我们可以先遍历获取两个链表的长度，然后再根据长的链表进行遍历，先让第一个指针走长度差步，然后第二个节点开始走，当两个节点走到第一个相同节点就是第一个公共节点。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">    ListNode current1 &#x3D; pHead1;&#x2F;&#x2F; 链表1</span><br><span class="line">    ListNode current2 &#x3D; pHead2;&#x2F;&#x2F; 链表2</span><br><span class="line">    if (pHead1 &#x3D;&#x3D; null || pHead2 &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    int length1 &#x3D; getLength(current1);</span><br><span class="line">    int length2 &#x3D; getLength(current2);</span><br><span class="line">    &#x2F;&#x2F; 两链表的长度差</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果链表1的长度大于链表2的长度</span><br><span class="line">    if (length1 &gt;&#x3D; length2) &#123;</span><br><span class="line">        int len &#x3D; length1 - length2;</span><br><span class="line">        &#x2F;&#x2F; 先遍历链表1，遍历的长度就是两链表的长度差</span><br><span class="line">        while (len &gt; 0) &#123;</span><br><span class="line">            current1 &#x3D; current1.next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果链表2的长度大于链表1的长度</span><br><span class="line">    else if (length1 &lt; length2) &#123;</span><br><span class="line">        int len &#x3D; length2 - length1;</span><br><span class="line">        &#x2F;&#x2F; 先遍历链表1，遍历的长度就是两链表的长度差</span><br><span class="line">        while (len &gt; 0) &#123;</span><br><span class="line">            current2 &#x3D; current2.next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;开始齐头并进，直到找到第一个公共结点</span><br><span class="line">    while (current1 !&#x3D; current2) &#123;</span><br><span class="line">        current1 &#x3D; current1.next;</span><br><span class="line">        current2 &#x3D; current2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return current1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 求指定链表的长度</span><br><span class="line">public static int getLength(ListNode pHead) &#123;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    ListNode current &#x3D; pHead;</span><br><span class="line">    while (current !&#x3D; null) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        current &#x3D; current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二：同样思路，使用HashMap实现"><a href="#解法二：同样思路，使用HashMap实现" class="headerlink" title="解法二：同样思路，使用HashMap实现"></a>解法二：同样思路，使用HashMap实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">    ListNode current1 &#x3D; pHead1;</span><br><span class="line">    ListNode current2 &#x3D; pHead2;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;ListNode, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    while (current1 !&#x3D; null) &#123;</span><br><span class="line">        hashMap.put(current1, null);</span><br><span class="line">        current1 &#x3D; current1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (current2 !&#x3D; null) &#123;</span><br><span class="line">        if (hashMap.containsKey(current2))</span><br><span class="line">            return current2;</span><br><span class="line">        current2 &#x3D; current2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>时间效率</tag>
        <tag>空间效率</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的锁分类</title>
    <url>/2020/05/01/lock/</url>
    <content><![CDATA[<p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。而我们在实际运用前，也需要对各种锁的分类要理解清楚，这样才能在项目中正确的使用锁。</p>
<p><img src="/img/lock/7f749fc8.png" alt=""></p>
<a id="more"></a>

<h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h2><p>乐观锁和悲观锁只是一种概念，并不是锁的具体实现，两者主要区别主要是看待线程同步的不同角度。<br>从概念上说，对同一个共享数据而言，悲观锁总是认为自己在使用数据的时候一定会有其它线程来竞争（主要是指修改数据），所以在获取这个共享数据的时候悲观锁会先加锁，确保这个数据不会被其它线程竞争而修改。在Java中，synchronized和Lock的实现类都属于悲观锁。<br>而乐观锁则恰好相反，乐观锁在使用共享数据的时候，总是认为其它线程不会来跟自己竞争（修改数据），所以不会先对数据加锁，而是在更新数据的时候去尝试判断有没有其它线程修改了数据，如果这个数据没有被其它线程修改，那么当前线程修改数据成功，否则当前线程修改失败，然后根据具体实现方式执行不同的操作（例如报错或者自旋等待重试等）。Java中乐观锁采用的最多的就是CAS（Compare And Swap）算法。<br>简而言之，悲观锁就是一定要先加锁再执行操作，乐观锁是先执行操作，如果失败了再采取一定的补救措施。</p>
<p><img src="/img/lock/sad-happy-lock.png" alt=""></p>
<p>那么两者可以分别运用在什么场景呢？</p>
<p>根据从上面的概念我们可以发现：</p>
<ul>
<li>悲观锁适合<strong>写操作多</strong>的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合<strong>读操作多</strong>的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ------------------------- 悲观锁的调用方式 -------------------------</span><br><span class="line">&#x2F;&#x2F; synchronized</span><br><span class="line">public synchronized void testMethod() &#123;</span><br><span class="line">	&#x2F;&#x2F; 操作同步资源</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ReentrantLock</span><br><span class="line">private ReentrantLock lock &#x3D; new ReentrantLock(); &#x2F;&#x2F; 需要保证多个线程使用的是同一个锁</span><br><span class="line">public void modifyPublicResources() &#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	&#x2F;&#x2F; 操作同步资源</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ------------------------- 乐观锁的调用方式 -------------------------</span><br><span class="line">private AtomicInteger atomicInteger &#x3D; new AtomicInteger();  &#x2F;&#x2F; 需要保证多个线程使用的是同一个AtomicInteger</span><br><span class="line">atomicInteger.incrementAndGet(); &#x2F;&#x2F;执行自增1</span><br></pre></td></tr></table></figure>

<p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 <code>CAS</code>的技术原理来解惑。</p>
<p><code>CAS</code>全称 <code>Compare And Swap</code>（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。<code>java.util.concurrent</code>包中的原子类就是通过<code>CAS</code>来实现了乐观锁。</p>
<p>CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>要写入的新值 B</li>
</ul>
<p>当且仅当 <code>V</code> 的值等于 <code>A</code> 时，<code>CAS</code>通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>
<p>之前提到<code>java.util.concurrent</code>包中的原子类，就是通过<code>CAS</code>来实现了乐观锁，那么我们进入原子类<code>AtomicInteger</code>的源码，看一下<code>AtomicInteger</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6214790243416807050L;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; setup to use Unsafe.compareAndSwapInt for updates</span><br><span class="line">    private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile int value;</span><br></pre></td></tr></table></figure>

<p>根据定义我们可以看出各属性的作用：</p>
<ul>
<li><code>unsafe</code>： 获取并操作内存的数据</li>
<li><code>valueOffset</code>： 存储<code>value</code>在<code>AtomicInteger</code>中的偏移量</li>
<li><code>value</code>： 存储<code>AtomicInteger</code>的<code>int</code>值，该属性需要借助<code>volatile</code>关键字保证其在线程间是可见的</li>
</ul>
<p>接下来，我们查看<code>AtomicInteger</code>的自增函数<code>incrementAndGet()</code>的源码时，发现自增函数底层调用的是<code>unsafe.getAndAddInt()</code>。但是由于<code>JDK</code>本身只有<code>Unsafe.class</code>，只通过<code>class</code>文件中的参数名，并不能很好的了解方法的作用，所以我们通过<code>OpenJDK 8</code> 来查看<code>Unsafe</code>的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ------------------------- JDK 8 -------------------------</span><br><span class="line">&#x2F;&#x2F; AtomicInteger 自增方法</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Unsafe.class</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">  int var5;</span><br><span class="line">  do &#123;</span><br><span class="line">      var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ------------------------- OpenJDK 8 -------------------------</span><br><span class="line">&#x2F;&#x2F; Unsafe.java</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">   int v;</span><br><span class="line">   do &#123;</span><br><span class="line">       v &#x3D; getIntVolatile(o, offset);</span><br><span class="line">   &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<code>OpenJDK 8</code>的源码我们可以看出，<code>getAndAddInt()</code>循环获取给定对象<code>o</code>中的偏移量处的值<code>v</code>，然后判断内存值是否等于<code>v</code>。如果相等则将内存值设置为 <code>v + delta</code>，否则返回<code>false</code>，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在<code>compareAndSwapInt()</code>中，在<code>JNI</code>里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>
<p>后续<code>JDK</code>通过CPU的<code>cmpxchg</code>指令，去比较寄存器中的 <code>A</code> 和 内存中的值 <code>V</code>。如果相等，就把要写入的新值 <code>B</code> 存入内存中。如果不相等，就将内存值 <code>V</code> 赋值给寄存器中的值 <code>A</code>。然后通过<code>Java</code>代码中的<code>while</code>循环再次调用<code>cmpxchg</code>指令进行重试，直到设置成功为止。</p>
<p><code>CAS</code>虽然很高效，但是它也存在三大问题，这里也简单说一下：</p>
<ol>
<li><code>ABA</code>问题。<code>CAS</code>需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么<code>CAS</code>进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加1，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。从<code>JDK1.5</code>开始提供了<code>AtomicStampedReference</code>类来解决ABA问题，具体操作封装在<code>compareAndSet()</code>中。<code>compareAndSet()</code>首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>
<li>循环时间长开销大。<code>CAS</code>操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li>
<li>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，<code>CAS</code>能够保证原子操作，但是对多个共享变量操作时，<code>CAS</code>是无法保证操作的原子性的。<code>JDK1.5</code>开始提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行<code>CAS</code>操作。</li>
</ol>
<h2 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁/适应性自旋锁"></a>自旋锁/适应性自旋锁</h2><p>在介绍自旋锁前，需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p>
<p>阻塞或唤醒一个<code>Java</code>线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p><img src="/img/lock/452a3363.png" alt="452a3363"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用<code>-XX:PreBlockSpin</code>来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁的实现原理同样也是<code>CAS</code>，<code>AtomicInteger</code>中调用<code>unsafe</code>进行自增操作的源码中的<code>do-while</code>循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">  int var5;</span><br><span class="line">  do &#123;</span><br><span class="line">      var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自旋锁在<code>JDK1.4.2</code>中引入，使用<code>-XX:+UseSpinning</code>来开启。<code>JDK1.6</code>中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>在自旋锁中 另有三种常见的锁形式:<code>TicketLock</code>、<code>CLHlock</code>和<code>MCSlock</code>，可以自行Google查阅相关资料介绍。</p>
<h2 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁/偏向锁/轻量级锁/重量级锁"></a>无锁/偏向锁/轻量级锁/重量级锁</h2><p>这四种锁状态放在一起的原因是它们都是专门针对<code>synchronized</code>所做出的优化。在介绍这四种锁状态之前还需要介绍一些额外的知识。<br>首先为什么<code>synchronized</code>能实现线程同步？</p>
<p>在回答这个问题之前我们需要了解两个重要的概念：</p>
<ul>
<li>Java对象头</li>
<li>Monitor</li>
</ul>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p><code>synchronized</code>是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？<br>我们以<code>Hotspot</code>虚拟机为例，<code>Hotspot</code>的对象头主要包括两部分数据：<code>Mark Word</code>（标记字段）、<code>Klass Pointer</code>（类型指针）。</p>
<p><strong>Mark Word</strong>：默认存储对象的<code>HashCode</code>、分代年龄以及锁标志位信息。这些信息都是与对象自身定义无关的数据，所以<code>Mark Word</code>被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间<code>Mark Word</code>里存储的数据会随着锁标志位的变化而变化。<br><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p><code>Monitor</code>可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者<code>Monitor</code>锁。</p>
<p><code>Monitor</code>是线程私有的数据结构，每一个线程都有一个可用<code>monitor record</code>列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个<code>monitor</code>关联，同时<code>monitor</code>中有一个<code>Owner</code>字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p>现在话题回到<code>synchronized</code>，<code>synchronized</code>通过<code>Monitor</code>来实现线程同步，<code>Monitor</code>是依赖于底层的操作系统的<code>Mutex Lock</code>（互斥锁）来实现的线程同步。</p>
<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是<code>synchronized</code>最初实现同步的方式，这就是<code>JDK1.6</code>之前<code>synchronized</code>效率低的原因。这种依赖于操作系统<code>Mutex Lock</code>所实现的锁我们称之为“重量级锁”，<code>JDK1.6</code>中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<p>通过上面的介绍，我们对<code>synchronized</code>的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的<code>Mark Word</code>内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">存储内容</th>
<th align="center">2位(bit)表示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无锁</td>
<td align="center">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">偏向锁</td>
<td align="center">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">指向栈中锁记录的指针</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">指向互斥量（重量级锁）的指针</td>
<td align="center">10</td>
</tr>
</tbody></table>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在<code>Mark Word</code>里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过<code>CAS</code>操作来加锁和解锁，而是检测<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次<code>CAS</code>原子指令，而偏向锁只需要在置换<code>ThreadID</code>的时候依赖一次<code>CAS</code>原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在<code>JDK1.6</code>及以后的<code>JVM</code>里是默认启用的。可以通过<code>JVM</code>参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，关闭之后程序默认会进入轻量级锁状态。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝，然后拷贝对象头中的<code>Mark Word</code>复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用<code>CAS</code>操作尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针，并将<code>Lock Record</code>里的<code>owner</code>指针指向对象的<code>Mark Word</code>。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象<code>Mark Word</code>的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>升级为重量级锁时，锁标志的状态值变为“10”，此时<code>Mark Word</code>中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>整体的锁状态升级流程如下：</p>
<p><img src="/img/lock/8afdf6f2.png" alt=""></p>
<p>综上，偏向锁通过对比<code>Mark Word</code>解决加锁问题，避免执行<code>CAS</code>操作。而轻量级锁是通过用<code>CAS</code>操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p>
<p><img src="/img/lock/a23d746a.png" alt="a23d746a"></p>
<p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p>
<p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p>
<p><img src="/img/lock/4499559e.png" alt="4499559e"></p>
<p>接下来我们通过<code>ReentrantLock</code>的源码来讲解公平锁和非公平锁。</p>
<p><img src="/img/lock/6edea205.png" alt="6edea205"></p>
<p>根据代码可知，<code>ReentrantLock</code>里面有一个内部类<code>Sync</code>，<code>Sync</code>继承<code>AQS</code>（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在<code>Sync</code>中实现的。它有公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>两个子类。<code>ReentrantLock</code>默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p>
<p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p>
<p><img src="/img/lock/bc6fe583.png" alt="bc6fe583"></p>
<p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的<code>lock()</code>方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：<code>hasQueuedPredecessors()</code>。</p>
<p><img src="/img/lock/bd0036bb.png" alt="bd0036bb"></p>
<p>再进入<code>hasQueuedPredecessors()</code>，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回<code>true</code>，否则返回<code>false</code>。</p>
<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>
<h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁/不可重入锁"></a>可重入锁/不可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。<code>Java</code>中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Widget &#123;</span><br><span class="line">    public synchronized void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;方法1执行...&quot;);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doOthers() &#123;</span><br><span class="line">        System.out.println(&quot;方法2执行...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，类中的两个方法都是被内置锁<code>synchronized</code>修饰的，<code>doSomething()</code>方法中调用<code>doOthers()</code>方法。因为内置锁是可重入的，所以同一个线程在调用<code>doOthers()</code>时可以直接获得当前对象的锁，进入<code>doOthers()</code>进行操作。</p>
<p>如果是一个不可重入锁，那么当前线程在调用<code>doOthers()</code>之前需要将执行<code>doSomething()</code>时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p>
<p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p>
<p><img src="/img/lock/58fc5bc9.png" alt="58fc5bc9"></p>
<p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p>
<p><img src="/img/lock/ea597a0c.png" alt="ea597a0c"></p>
<p>之前我们说过<code>ReentrantLock</code>和<code>synchronized</code>都是重入锁，那么我们通过重入锁<code>ReentrantLock</code>以及非可重入锁<code>NonReentrantLock</code>的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p>
<p>首先<code>ReentrantLock</code>和<code>NonReentrantLock</code>都继承父类<code>AQS</code>，其父类<code>AQS</code>中维护了一个同步状态<code>status</code>来计数重入次数，<code>status</code>初始值为0。</p>
<p>当线程尝试获取锁时，可重入锁先尝试获取并更新<code>status</code>值，如果<code>status == 0</code>表示没有其他线程在执行同步代码，则把<code>status</code>置为1，当前线程开始执行。如果<code>status != 0</code>，则判断当前线程是否是获取到这个锁的线程，如果是的话执行<code>status+1</code>，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前<code>status</code>的值，如果<code>status != 0</code>的话会导致其获取锁失败，当前线程阻塞。</p>
<p>释放锁时，可重入锁同样先获取当前<code>status</code>的值，在当前线程是持有锁的线程的前提下。如果<code>status-1 == 0</code>，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将<code>status</code>置为0，将锁释放。</p>
<p><img src="/img/lock/32536e7a.png" alt="32536e7a"></p>
<h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h2><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过<code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>的源码来介绍独享锁和共享锁。</p>
<p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。<code>JDK</code>中的<code>synchronized</code>和<code>JUC</code>中<code>Lock</code>的实现类就是互斥锁。</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>独享锁与共享锁也是通过<code>AQS</code>来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p>下图为<code>ReentrantReadWriteLock</code>的部分源码：</p>
<p><img src="/img/lock/762a042b.png" alt="762a042b"></p>
<p>我们看到<code>ReentrantReadWriteLock</code>有两把锁：<code>ReadLock</code>和<code>WriteLock</code>，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现<code>ReadLock</code>和<code>WriteLock</code>是靠内部类<code>Sync</code>实现的锁。<code>Sync</code>是<code>AQS</code>的一个子类，这种结构在<code>CountDownLatch</code>、<code>ReentrantLock</code>、<code>Semaphore</code>里面也都存在。</p>
<p>在<code>ReentrantReadWriteLock</code>里面，读锁和写锁的锁主体都是<code>Sync</code>，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以<code>ReentrantReadWriteLock</code>的并发性相比一般的互斥锁有了很大提升。</p>
<p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及<code>AQS</code>的时候我们也提到了<code>state</code>字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>
<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中<code>state</code>就是持有锁的数量。但是在<code>ReentrantReadWriteLock</code>中有读、写两把锁，所以需要在一个整型变量<code>state</code>上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将<code>state</code>变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p>
<p><img src="/img/lock/8793e00a.png" alt=""></p>
<p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">	Thread current &#x3D; Thread.currentThread();</span><br><span class="line">	int c &#x3D; getState(); &#x2F;&#x2F; 取到当前锁的个数</span><br><span class="line">	int w &#x3D; exclusiveCount(c); &#x2F;&#x2F; 取写锁的个数w</span><br><span class="line">	if (c !&#x3D; 0) &#123; &#x2F;&#x2F; 如果已经有线程持有了锁(c!&#x3D;0)</span><br><span class="line">    &#x2F;&#x2F; (Note: if c !&#x3D; 0 and w &#x3D;&#x3D; 0 then shared count !&#x3D; 0)</span><br><span class="line">		if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread()) &#x2F;&#x2F; 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span><br><span class="line">			return false;</span><br><span class="line">		if (w + exclusiveCount(acquires) &gt; MAX_COUNT)    &#x2F;&#x2F; 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span><br><span class="line">      throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">		&#x2F;&#x2F; Reentrant acquire</span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#x2F;&#x2F; 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span><br><span class="line">		return false;</span><br><span class="line">	setExclusiveOwnerThread(current); &#x2F;&#x2F; 如果c&#x3D;0，w&#x3D;0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（  int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li>
<li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li>
<li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li>
<li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li>
<li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li>
</ul>
<p><code>tryAcquire()</code>除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与<code>ReentrantLock</code>的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>
<p>接着是读锁的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (exclusiveCount(c) !&#x3D; 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line">        return -1;                                   &#x2F;&#x2F; 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span><br><span class="line">    int r &#x3D; sharedCount(c);</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        if (r &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            firstReader &#x3D; current;</span><br><span class="line">            firstReaderHoldCount &#x3D; 1;</span><br><span class="line">        &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">                cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();</span><br><span class="line">            else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到在<code>tryAcquireShared(int unused)</code>方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠<code>CAS</code>保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是<code>1&lt;&lt;16</code>。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>
<p>此时，我们再回头看一下互斥锁<code>ReentrantLock</code>中公平锁和非公平锁的加锁源码：</p>
<p><img src="/img/lock/8b7878ec.png" alt="8b7878ec"></p>
<p>我们发现在<code>ReentrantLock</code>虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用<code>lock</code>方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用<code>CAS</code>更新<code>state</code>成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定<code>ReentrantLock</code>无论读操作还是写操作，添加的锁都是都是独享锁。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li>《Java并发编程的艺术》</li>
<li><a href="https://blog.csdn.net/u013256816/article/details/51204385" target="_blank" rel="noopener">Java中的锁</a></li>
<li><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java”锁”事</a></li>
<li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS原理剖析</a></li>
<li><a href="https://juejin.im/post/5b42c2546fb9a04f8751eabc" target="_blank" rel="noopener">Java并发——关键字synchronized解析</a></li>
<li><a href="https://blog.csdn.net/qq_19431333/article/details/70568478" target="_blank" rel="noopener">深入理解读写锁—ReadWriteLock源码分析</a></li>
<li><a href="https://www.cnblogs.com/twoheads/p/9635309.html" target="_blank" rel="noopener">【JUC】JDK1.8源码分析之ReentrantReadWriteLock</a></li>
<li><a href="https://my.oschina.net/adan1/blog/158107" target="_blank" rel="noopener">Java多线程（十）之ReentrantReadWriteLock深入分析</a></li>
<li><a href="https://mrdear.cn/2018/06/23/java/java--readwritelock" target="_blank" rel="noopener">Java–读写锁的实现原理</a></li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的双重检查锁</title>
    <url>/2020/04/06/doubleCheckedLocking/</url>
    <content><![CDATA[<h2 id="Java中的双重检查锁-Double-Checked-Locking"><a href="#Java中的双重检查锁-Double-Checked-Locking" class="headerlink" title="Java中的双重检查锁 Double Checked Locking"></a>Java中的双重检查锁 Double Checked Locking</h2><p>在实现单例模式中，如果没有考虑多线程并发的情况下，初学者很容易写出下面的错误单例模式代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton()&#123;</span><br><span class="line">    private static Singleton uniqueSingleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private Singleton getInstance()&#123;</span><br><span class="line">        if(null &#x3D;&#x3D; uniqueSingleton)&#123;</span><br><span class="line">            uniqueSingleton &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>很显然，在多线程的情况下，这样写可能会导致<code>uniqueSingleton</code>被创建出多个实例，比如下面的情况考虑有两个线程同时调用<code>getInstance()</code>方法时：</p>
<table>
<thead>
<tr>
<th align="center">Time</th>
<th align="center">Thread A 记为线程A</th>
<th align="center">Thread B 记为线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T1</td>
<td align="center">检查到<code>uniqueSingleton</code>为空</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T2</td>
<td align="center"></td>
<td align="center">检查到<code>uniqueSingleton</code>为空</td>
</tr>
<tr>
<td align="center">T3</td>
<td align="center"></td>
<td align="center">初始化对象A</td>
</tr>
<tr>
<td align="center">T4</td>
<td align="center"></td>
<td align="center">返回对象A</td>
</tr>
<tr>
<td align="center">T5</td>
<td align="center">初始化对象B</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T6</td>
<td align="center">返回对象B</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>用文字表述如下：</p>
<p>如果线程A和B同时执行了<code>getInstance()</code>方法，然后以如下方式执行：</p>
<ol>
<li>线程A进入if判断，此时<code>instance</code>为<code>null</code>，因此可以进入if内</li>
<li>线程B进入if判断，此时A还没有创建<code>instance</code>，因此<code>instance</code>也为<code>null</code>，因此线程B也进入了if内</li>
<li>线程B初始化了一个对象并返回</li>
<li>线程B也初始化了一个对象并返回</li>
</ol>
<p>因此此时一个对象实际上还是可以被创建多次，并没有达到单例的效果。</p>
<hr>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>那么出现这种情况，第一反应肯定是加锁，因此可以将上述代码更改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton()&#123;</span><br><span class="line">    private static Singleton uniqueSingleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;加锁</span><br><span class="line">    private synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(null &#x3D;&#x3D; uniqueSingleton)&#123;</span><br><span class="line">            uniqueSingleton &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然解决了问题，但是因为用到了<code>synchronized</code>会导致比较大的开销，并且加锁实际中只需要在第一次初始化的时候用到，之后的调用并不需要再进行加锁，因此这种方法实际上需要改进。</p>
<h3 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h3><p>双重检查锁是对上述加锁问题的一种优化，先判断对象是否已经被初始化，再决定是否加锁。</p>
<h5 id="错误的双重检查锁"><a href="#错误的双重检查锁" class="headerlink" title="错误的双重检查锁"></a>错误的双重检查锁</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton uniqueSingleton;</span><br><span class="line">    </span><br><span class="line">    private SIngleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public Singleton getInstance()&#123;</span><br><span class="line">        if(null &#x3D;&#x3D; uniqueSingleton)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(null &#x3D;&#x3D; uniqueSingleton)&#123;</span><br><span class="line">                    uniqueSingleton &#x3D; new Singleton(); &#x2F;&#x2F;错误示范</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这样写的话，运行顺序就变成了：</p>
<p>1.检查变量是否被初始化（不去获得锁），如果已经被初始化就直接返回</p>
<p>2.获得锁</p>
<p>3.再次检查变量是否已经被初始化，如果还没有初始化就初始化一个对象</p>
<p>执行双重检查是因为，如果多个线程同时通过了第一次检查，并且其中的一个线程首先通过了第二次检查并实例化了对象，那么剩余通过了第一次检查的线程就不会再去实例化对象。</p>
<p>这样，除了初始化的时候会出现加锁的情况，后续的调用都会避免加锁而直接返回，解决了性能消耗的问题。</p>
<h5 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h5><p>上述的写法看似解决了问题，实际上有个很大的隐患。实例化对象的那一行代码，实际上可以分解为三个步骤：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将对象指向刚分配的内存空间</li>
</ol>
<p>但是有些编译器为了提升性能，会采用指令重排序，因此可能会将第二步和第三步进行重排序（在某些<strong>JIT</strong>编译器中这种情况是会真实发生的），顺序就变成了：</p>
<ol>
<li>分配内存空间</li>
<li>将对象指向刚分配的内存空间</li>
<li>初始化对象</li>
</ol>
<p>而当考虑重排序后，两个线程发生了以下的调用：</p>
<table>
<thead>
<tr>
<th align="center">Time</th>
<th align="center">Thread A 线程A</th>
<th align="center">Thread B 线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T1</td>
<td align="center">检查到<code>uniqueSingleton</code>为空</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T2</td>
<td align="center">获得锁</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T3</td>
<td align="center">再次检查到<code>uniqueSingleton</code>为空</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T4</td>
<td align="center">为<code>uniqueSingleton</code>分配内存空间</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T5</td>
<td align="center">将<code>uniqueSingleton</code>指向内存空间</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T6</td>
<td align="center"></td>
<td align="center">检查到<code>uniqueSingleton</code>不为空</td>
</tr>
<tr>
<td align="center">T7</td>
<td align="center"></td>
<td align="center">访问<code>uniqueSingleton</code>（此时对象还未完成初始化）</td>
</tr>
<tr>
<td align="center">T8</td>
<td align="center">初始化<code>uniqueSingleton</code></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>文字表述如下：</p>
<ol>
<li>A、B线程同时进入了第一个if判断</li>
<li>A首先初始化<code>synchronized</code>块，由于<code>uniqueSingleton</code>为null，所以它执行了<code>uniqueSingleton = new Singleton();</code></li>
<li>由于JVM内部的优化机制，JVM先划出一些分配给Singleton实例的空白内存，并赋值给instance成员，注意此时JVM还没有开始初始化这个实例，然后A离开了这个<code>synchronized</code>块。<ol>
<li>B进入<code>synchronized</code>块，由于<code>uniqueSingleton</code>此时不是null，因此它马上离开了<code>synchronized</code>块 并将结果返回给调用该方法的程序。</li>
</ol>
</li>
<li>此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</li>
</ol>
<p>在知晓了问题发生的根源之后，我们可以想出两种办法来实现线程安全的单例模式，</p>
<p>1）不允许2和3重排序。</p>
<p>2）允许2和3重排序，但是不允许其它线程“看到”这个重排序。</p>
<h5 id="正确的双重检查锁"><a href="#正确的双重检查锁" class="headerlink" title="正确的双重检查锁"></a>正确的双重检查锁</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance() &#123;</span><br><span class="line">        if (null &#x3D;&#x3D; uniqueSingleton) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (null &#x3D;&#x3D; uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决隐患问题，我们需要在<code>uniqueSingleton</code>前加上关键字<code>volatile</code>。使用了<code>volatile</code>关键词后，编译器的指令重排序被禁止，所有对加上该关键字的共享变量的写（write）操作都发生在读（read）操作之前。至此，双重检查锁就可以完美工作了！</p>
<h5 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h5><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的 初始化。在执行类的初始化期间，JVM会尝试去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。</p>
<p>基于这个特性，可以实现另外一种线程安全的延迟加载初始化方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingletonFactory&#123;</span><br><span class="line">    private static class InstanceHolder&#123;</span><br><span class="line">        public static Instance instance &#x3D; new Instance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Instance getInstance()&#123;</span><br><span class="line">        return InstanceHolder.instance; &#x2F;&#x2F;这里将导致InstanceHodler类被初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案的实质是：允许重排序，但是不允许非构造线程“看到”这个排序。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/2020/04/07/hashMap/</url>
    <content><![CDATA[<p><code>HashMap</code>最早出现在JDK1.2中，底层基于散列算法（Hash）实现。并且<code>HashMap</code>允许null键和null值，是线程非安全类，在多线程环境下可能会存在问题，与之对应的是<code>HashTable</code>类，<code>HashTable</code>是线程安全的<code>HashMap</code>，但是在之前由于HashTable方法都是用<code>synchronized</code>实现，开销比较大，所以在多线程时反而并不使用<code>HashTable</code>，而是使用<code>CurrentHashMap</code>。在JDK1.8后，<code>HashMap</code>和<code>CurrentHashMap</code>的数据结构都有了新变化，即加入了红黑树。</p>
<a id="more"></a>

<h3 id="JDK1-7及之前版本中的HashMap数据结构"><a href="#JDK1-7及之前版本中的HashMap数据结构" class="headerlink" title="JDK1.7及之前版本中的HashMap数据结构"></a>JDK1.7及之前版本中的HashMap数据结构</h3><p>在JDK1.6，1.7中，HashMap都是基于“拉链法”实现，即数组+链表的形式，通过不同的hash值来对键分配不同的桶（bucket）。</p>
<h3 id="JDK1-8版本的HashMap数据结构"><a href="#JDK1-8版本的HashMap数据结构" class="headerlink" title="JDK1.8版本的HashMap数据结构"></a>JDK1.8版本的HashMap数据结构</h3><p><img src="/img/hashMap/HashMap.png" alt="HashMap"></p>
<p>在JDK1.8中对HashMap的源码进行了优化，在JDK1.7中，HashMap处理“碰撞”的时候，都是采用链表来存储，当碰撞的节点很多的时候，查询时间复杂度从原来的O(1)变成了O(N)。而JDK1.8中，为了优化这种情况，HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞节点较少时，采样链表存储，当较大（默认是超过8）时，变成使用红黑树（特点是查询时间是O(logN)）存储。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><code>Node</code>是HashMap中的一个静态内部类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Node是单向链表，实现了Map.Entry接口</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line"> 	final int hash; &#x2F;&#x2F;哈希</span><br><span class="line"> 	final K key;  &#x2F;&#x2F;键值对</span><br><span class="line">   V value;</span><br><span class="line"> 	Node&lt;K,V&gt; next;  &#x2F;&#x2F;下一个节点</span><br><span class="line">    </span><br><span class="line">	 &#x2F;&#x2F;构造函数</span><br><span class="line">  Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">	 this.hash &#x3D; hash;</span><br><span class="line"> 	 this.key &#x3D; key;</span><br><span class="line"> 	 this.value &#x3D; value;</span><br><span class="line"> 	 this.next &#x3D; next;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	&#x2F;&#x2F; getter and setter ... toString ...</span><br><span class="line"> 	public final K getKey() &#123; return key; &#125;</span><br><span class="line"> 	public final V getValue() &#123; return value; &#125;</span><br><span class="line"> 	public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">	public final int hashCode() &#123;</span><br><span class="line"> 	return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue &#x3D; value;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public final boolean equals(Object o) &#123;</span><br><span class="line"> 	if (o &#x3D;&#x3D; this)</span><br><span class="line"> 	   return true;</span><br><span class="line"> 	if (o instanceof Map.Entry) &#123;</span><br><span class="line"> 	   Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"> 	if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line"> 	   Objects.equals(value, e.getValue()))</span><br><span class="line"> 	   return true;</span><br><span class="line">  &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TreeNode</code>是红黑树的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line"> 	TreeNode&lt;K,V&gt; parent; &#x2F;&#x2F; red-black tree links</span><br><span class="line"> 	TreeNode&lt;K,V&gt; left;</span><br><span class="line"> 	TreeNode&lt;K,V&gt; right;</span><br><span class="line"> 	TreeNode&lt;K,V&gt; prev; &#x2F;&#x2F; needed to unlink next upon deletion</span><br><span class="line"> 	boolean red;</span><br><span class="line"> 	TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"> 	super(hash, key, val, next);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">     * Returns root of tree containing this node.</span><br><span class="line">     *&#x2F;</span><br><span class="line"> final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line"> 	for (TreeNode&lt;K,V&gt; r &#x3D; this, p;;) &#123;</span><br><span class="line"> 		if ((p &#x3D; r.parent) &#x3D;&#x3D; null)</span><br><span class="line"> 			return r;</span><br><span class="line">         r &#x3D; p;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 默认初始容量16(必须是2的幂次方)</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 最大容量，2的30次方</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 默认加载因子，用来计算threshold</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 链表转成树的阈值，当桶中链表长度大于8时转成树 </span><br><span class="line">   threshold &#x3D; capacity * loadFactor</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 进行resize操作时，若桶中数量少于6则从树转成链表</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 桶中结构转化为红黑树对应的table的最小大小</span><br><span class="line">   当需要将解决 hash 冲突的链表转变为红黑树时，</span><br><span class="line">   需要判断下此时数组容量，</span><br><span class="line">   若是由于数组容量太小（小于　MIN_TREEIFY_CAPACITY　）</span><br><span class="line">   导致的 hash 冲突太多，则不进行链表转变为红黑树操作，</span><br><span class="line">   转为利用　resize() 函数对　hashMap 扩容</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">&#x2F;**</span><br><span class="line"> 保存Node&lt;K,V&gt;节点的数组</span><br><span class="line"> 该表在首次使用时初始化，并根据需要调整大小。 分配时，</span><br><span class="line"> 长度始终是2的幂。</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 存放具体元素的集</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 记录 hashMap 当前存储的元素的数量</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient int size;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 每次更改map结构的计数器</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient int modCount;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span><br><span class="line"> *&#x2F;</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 负载因子：要调整大小的下一个大小值（容量*加载因子）。</span><br><span class="line"> *&#x2F;</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public HashMap(int initialCapacity, float loadFactor) &#123;    &#x2F;&#x2F; 初始容量不能&#96;</span><br></pre></td></tr></table></figure>

<h4 id="tableSizeFor方法详解"><a href="#tableSizeFor方法详解" class="headerlink" title="tableSizeFor方法详解"></a>tableSizeFor方法详解</h4><p>用位运算找到大于或等于cap的最小2的整次幂的数，比如10，则返回16。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;static final int tableSizeFor(int cap) &#123;&#96;</span><br></pre></td></tr></table></figure>

<ol>
<li>让cap-1再赋值给n的目的是使得找到的目标值大于或等于原值。例如二进制<code>0100</code>,十进制是4,若不减1而直接操作，答案是<code>0001 0000</code>十进制是16，明显不符合预期。</li>
<li>对n右移1位：001xx…xxx，再位或：011xx…xxx</li>
<li>对n右移2位：00011…xxx，再位或：01111…xxx</li>
<li>对n右移4位…</li>
<li>对n右移8位…</li>
<li>对n右移16位,因为int最大就<code>2^32</code>所以移动1、2、4、8、16位并取位或,会将最高位的1后面的位全变为1。</li>
<li>再让结果n+1，即得到了2的整数次幂的值了。</li>
</ol>
<p>附带一个实例：</p>
<p><img src="/img/hashMap/tableSizeFor.jpg" alt="tableSizeFor"></p>
<h4 id="loadFactory负载因子"><a href="#loadFactory负载因子" class="headerlink" title="loadFactory负载因子"></a>loadFactory负载因子</h4><p><strong>对于HashMap来说，负载因子是一个很重要的参数，该参数反应了HashMap桶数组的使用情况，通过调节负载因子，可以使HashMap时间和空间复杂度上有不同的表现。</strong></p>
<p>当我们调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，键的键之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间。</p>
<p>相反，如果增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间。至于负载因子怎么调节，这个看使用场景了。</p>
<p>一般情况下，我们用默认值就可以了。大多数情况下0.75在时间跟空间代价上达到了平衡所以不建议修改。</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; HashMap中的Hash方法</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">   int h;</span><br><span class="line"> &#x2F;&#x2F; 拿到key的hash值后与其无符号右移16位取“与”</span><br><span class="line"> &#x2F;&#x2F; 这种方式能混合原始hash值的高位和低位，并且混合后的低位混杂了高位的特征</span><br><span class="line"> &#x2F;&#x2F; 主要是考虑数组的table的length比较小的时候也能保证考虑到高低bit都能参与到hash中，并且效率很高</span><br><span class="line"> &#x2F;&#x2F; 通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。</span><br><span class="line">  return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line"> 	Node&lt;K,V&gt;[] tab; </span><br><span class="line"> 	Node&lt;K,V&gt; first, e; </span><br><span class="line"> 	int n; K k;</span><br><span class="line"> &#x2F;&#x2F; 定位键值对所在桶的位置</span><br><span class="line"> if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;  (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line"> &#x2F;&#x2F; 判断桶中第一项(数组元素)相等</span><br><span class="line"> if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">     ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line"> 		return first;</span><br><span class="line"> &#x2F;&#x2F; 桶中不止一个结点</span><br><span class="line"> if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line"> &#x2F;&#x2F; 是否是红黑树，是的话调用getTreeNode方法</span><br><span class="line"> if (first instanceof TreeNode)</span><br><span class="line"> 	return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"> &#x2F;&#x2F; 不是红黑树的话，在链表中遍历查找    </span><br><span class="line"> do &#123;</span><br><span class="line"> if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line"> 	return e;</span><br><span class="line"> &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> 	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap：如何有效减少碰撞</p>
<ol>
<li>扰动函数：促使元素位置分布均匀，减少碰撞几率</li>
<li>使用final对象，并采用合适的equals()和hashCode()方法</li>
</ol>
<p>注意：</p>
<ol>
<li>HashMap的hash算法(<code>hash()</code>方法)。</li>
<li><code>(n - 1) &amp;amp; hash</code>等价于对 length 取余。</li>
</ol>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">   &#x2F;&#x2F; 调用hash(key)方法来计算hash </span><br><span class="line">   return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; </span><br><span class="line">   Node&lt;K,V&gt; p; </span><br><span class="line">   int n, i;</span><br><span class="line">   &#x2F;&#x2F; 容量初始化：当table为空，则调用resize()方法来初始化容器，并且resize()方法可以扩容</span><br><span class="line">   if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">   &#x2F;&#x2F;确定元素存放在哪个桶中，桶为空，新生成结点放入桶中</span><br><span class="line">   if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">   else &#123;</span><br><span class="line">   Node&lt;K,V&gt; e; K k;</span><br><span class="line">   &#x2F;&#x2F; 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br><span class="line">   if (p.hash &#x3D;&#x3D; hash &amp;&amp;  ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">   &#x2F;&#x2F;如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值对</span><br><span class="line">       e &#x3D; p;</span><br><span class="line">   &#x2F;&#x2F; 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法</span><br><span class="line">   else if (p instanceof TreeNode)</span><br><span class="line">   &#x2F;&#x2F; 放入树中</span><br><span class="line">        e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">   else &#123;</span><br><span class="line">   &#x2F;&#x2F;对链表进行遍历，并统计链表长度</span><br><span class="line">   for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">   &#x2F;&#x2F; 到达链表的尾部</span><br><span class="line">   if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;在尾部插入新结点</span><br><span class="line">       p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">   &#x2F;&#x2F; 如果结点数量达到阈值，转化为红黑树</span><br><span class="line">   if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">       treeifyBin(tab, hash);</span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line">   &#x2F;&#x2F; 判断链表中结点的key值与插入的元素的key值是否相等</span><br><span class="line">   if (e.hash &#x3D;&#x3D; hash &amp;&amp;  ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">        break;</span><br><span class="line">        p &#x3D; e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;判断要插入的键值对是否存在 HashMap 中</span><br><span class="line">   if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">       V oldValue &#x3D; e.value;</span><br><span class="line">   &#x2F;&#x2F; onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span><br><span class="line">   if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">       e.value &#x3D; value;</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">       return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">   ++modCount;</span><br><span class="line">   &#x2F;&#x2F; 键值对数量超过阈值时，则进行扩容</span><br><span class="line">   if (++size &gt; threshold)</span><br><span class="line">     resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，<code>new HashMap();</code>完成后，如果没有<code>put</code>操作，是不会分配存储空间的。</p>
<p>HashMap：put方法的逻辑</p>
<ol>
<li>如果HashMap未被初始化过，则初始化</li>
<li>对key求hash值，然后再计算下标</li>
<li>如果没有碰撞，直接放入桶中</li>
<li>如果碰撞了，以链表的方式链接到后面</li>
<li>如果链表长度超过阈值，就把链表转换成红黑树</li>
<li>如果链表的长度低于6，就把红黑树转回链表</li>
<li>如果节点已经存在就替换旧值</li>
<li>如果桶满了（容量16*负载因子0.75），就需要resize（扩容2倍后重排）</li>
</ol>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>在  HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。  HashMap  按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"> &#x2F;&#x2F; 拿到数组桶</span><br><span class="line"> Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line"> int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line"> int oldThr &#x3D; threshold;</span><br><span class="line"> int newCap, newThr &#x3D; 0;</span><br><span class="line"> &#x2F;&#x2F; 如果数组桶的容量大与0</span><br><span class="line"> if (oldCap &gt; 0) &#123;</span><br><span class="line"> &#x2F;&#x2F; 如果比最大值还大，则赋值为最大值</span><br><span class="line"> if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line"> return oldTab;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 如果扩容后小于最大值 而且 旧数组桶大于初始容量16， 阈值左移1(扩大2倍)</span><br><span class="line"> else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 如果数组桶容量&lt;&#x3D;0 且 旧阈值 &gt;0</span><br><span class="line"> else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line"> &#x2F;&#x2F; 新容量&#x3D;旧阈值</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line"> &#x2F;&#x2F; 如果数组桶容量&lt;&#x3D;0 且 旧阈值 &lt;&#x3D;0</span><br><span class="line"> else &#123; &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line"> &#x2F;&#x2F; 新容量&#x3D;默认容量</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line"> &#x2F;&#x2F; 新阈值&#x3D; 负载因子*默认容量</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 如果新阈值为0</span><br><span class="line"> if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line"> &#x2F;&#x2F; 重新计算阈值</span><br><span class="line"> float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line"> (int)ft : Integer.MAX_VALUE);</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 更新阈值</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line"> @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line"> &#x2F;&#x2F; 创建新数组</span><br><span class="line"> Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line"> &#x2F;&#x2F; 覆盖数组桶    </span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line"> &#x2F;&#x2F; 如果旧数组桶不是空，则遍历桶数组，并将键值对映射到新的桶数组中</span><br><span class="line"> if (oldTab !&#x3D; null) &#123;</span><br><span class="line"> for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line"> Node&lt;K,V&gt; e;</span><br><span class="line"> if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line"> if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line"> &#x2F;&#x2F; 如果是红黑树</span><br><span class="line"> else if (e instanceof TreeNode)</span><br><span class="line"> &#x2F;&#x2F; 重新映射时，需要对红黑树进行拆分</span><br><span class="line"> ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line"> else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line"> &#x2F;&#x2F; 如果不是红黑树，则按链表处理</span><br><span class="line"> Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line"> Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line"> Node&lt;K,V&gt; next;</span><br><span class="line"> &#x2F;&#x2F; 遍历链表，并将链表节点按原顺序进行分组</span><br><span class="line"> do &#123;</span><br><span class="line"> next &#x3D; e.next;</span><br><span class="line"> if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line"> if (loTail &#x3D;&#x3D; null)</span><br><span class="line">     loHead &#x3D; e;</span><br><span class="line"> else</span><br><span class="line">     loTail.next &#x3D; e;</span><br><span class="line">     loTail &#x3D; e;</span><br><span class="line"> &#125;</span><br><span class="line"> else &#123;</span><br><span class="line"> if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">     hiHead &#x3D; e;</span><br><span class="line"> else</span><br><span class="line">     hiTail.next &#x3D; e;</span><br><span class="line">     hiTail &#x3D; e;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line"> &#x2F;&#x2F; 将分组后的链表映射到新桶中</span><br><span class="line"> if (loTail !&#x3D; null) &#123;</span><br><span class="line">     loTail.next &#x3D; null;</span><br><span class="line">     newTab[j] &#x3D; loHead;</span><br><span class="line"> &#125;</span><br><span class="line"> if (hiTail !&#x3D; null) &#123;</span><br><span class="line">     hiTail.next &#x3D; null;</span><br><span class="line">     newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	   &#125;</span><br><span class="line"> 	  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> 	return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>
</blockquote>
<p>HashMap扩容问题：</p>
<ol>
<li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li>
<li>rehashing是一个比较耗时的过程</li>
</ol>
<p>整体步骤：</p>
<ol>
<li>计算新桶数组的容量 newCap 和新阈值 newThr</li>
<li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li>
</ol>
<p>总结起来，一共有三种<strong>扩容方式</strong>：</p>
<ol>
<li>使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值<code>DEFAULT_INITIAL_CAPACITY</code>也就是16。同时<code>threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12</code>。</li>
<li>指定初始容量的构造方法初始化<code>HashMap</code>。那么从下面源码可以看到初始容量会等于<code>threshold</code>，接着<code>threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR</code>。</li>
<li>HashMap不是第一次扩容。如果<code>HashMap</code>已经扩容过的话，那么每次table的容量以及<code>threshold</code>量为原有的两倍。</li>
</ol>
<p>细心点的人会很好奇，为什么要判断loadFactor为0呢？</p>
<blockquote>
<p>loadFactor小数位为 0，整数位可被2整除且大于等于8时，在某次计算中就可能会导致 newThr 溢出归零。</p>
</blockquote>
<h3 id="疑问和进阶"><a href="#疑问和进阶" class="headerlink" title="疑问和进阶"></a>疑问和进阶</h3><p><strong>1. JDK1.7是基于数组+单链表实现（为什么不用双链表）</strong></p>
<p>首先，用链表是为了解决hash冲突。</p>
<p>单链表能实现为什么要用双链表呢?(双链表需要更大的存储空间)</p>
<p><strong>2. 为什么要用红黑树，而不用平衡二叉树？</strong></p>
<blockquote>
<p>插入效率比平衡二叉树高，查询效率比普通二叉树高。所以选择性能相对折中的红黑树。</p>
</blockquote>
<p><strong>3. 重写对象的Equals方法时，要重写hashCode方法，为什么？跟HashMap有什么关系？</strong></p>
<p>equals与hashcode间的关系:</p>
<ol>
<li>如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)</li>
</ol>
<p>因为在  HashMap 的链表结构中遍历判断的时候，特定情况下重写的 equals  方法比较对象是否相等的业务逻辑比较复杂，循环下来更是影响查找效率。所以这里把 hashcode 的判断放在前面，只要 hashcode  不相等就玩儿完，不用再去调用复杂的 equals 了。很多程度地提升 HashMap 的使用效率。</p>
<p>所以重写 hashcode 方法是为了让我们能够正常使用 HashMap 等集合类，因为 HashMap 判断对象是否相等既要比较 hashcode 又要使用 equals 比较。而这样的实现是为了提高 HashMap 的效率。</p>
<p><strong>4. HashMap为什么不直接使用对象的原始hash值呢?</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final int hash(Object key) &#123; int h; return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，HashMap的哈希值是通过上面的方式获取，而不是通过<code>key.hashCode()</code>方法获取。</p>
<p>原因：</p>
<blockquote>
<p>通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。</p>
</blockquote>
<p><strong>5. 既然红黑树那么好，为啥hashmap不直接采用红黑树，而是当大于8个的时候才转换红黑树？</strong></p>
<p>因为红黑树需要进行左旋，右旋操作， 而单链表不需要。</p>
<p>以下都是单链表与红黑树结构对比。</p>
<p>如果元素小于8个，查询成本高，新增成本低。</p>
<p>如果元素大于8个，查询成本低，新增成本高。</p>
<p>至于为什么选数字8，是大佬折中衡量的结果-.-，就像loadFactor默认值0.75一样。</p>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>”hashMap&quot;</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal源码分析</title>
    <url>/2020/05/01/threadLocal/</url>
    <content><![CDATA[<h2 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h2><p>现代的软件开发过程中，并发是不可缺少的实现手段，由此带来的语言层面的切入点就是多线程，引入多线程开发后，自然要考虑多线程实现中的同步、互斥、线程安全等内容。因为这些需求就出现了以下三种来实现线程安全的手段：</p>
<ol>
<li>互斥同步：简单点理解就是通过加锁来实现对临界资源的访问限制。加锁方式有 Synchorized 和 Lock。</li>
<li>非阻塞同步：前面提到的互斥同步属于一种悲观锁机制，非阻塞同步属于乐观锁机制。典型的实现方式就是 CAS 操作。</li>
<li>无同步方案：要保证线程安全，并不是一定就需要同步，两者没有因果关系，同步只是保证共享数据征用时正确性的手段，如果一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证正确性。ThreadLocal 的概念就是从这里引申出来的。</li>
</ol>
<p>先通过下面这个实例来理解 ThreadLocal 的用法。先声明一个 ThreadLocal 对象，存储布尔类型的数值。然后分别在主线程中、Thread1、Thread2 中为 ThreadLocal 对象设置不同的数值：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      	&#x2F;&#x2F; 声明 ThreadLocal对象</span><br><span class="line">        ThreadLocal&lt;Boolean&gt; mThreadLocal &#x3D; new ThreadLocal&lt;Boolean&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 在主线程、子线程1、子线程2中去设置访问它的值</span><br><span class="line">        mThreadLocal.set(true);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Main &quot; + mThreadLocal.get());</span><br><span class="line"></span><br><span class="line">        new Thread(&quot;Thread#1&quot;)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mThreadLocal.set(false);</span><br><span class="line">                System.out.println(&quot;Thread#1 &quot; + mThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread(&quot;Thread#2&quot;)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;Thread#2 &quot; + mThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MainThread true</span><br><span class="line">Thread#1 false</span><br><span class="line">Thread#2 null</span><br></pre></td></tr></table></figure>

<p>可以看见，在不同线程对同一个 ThreadLocal 对象设置数值，在不同的线程中取出来的值不一样。接下来就分析一下源码，看看其内部结构。</p>
<h1 id="ThreadLocal源码实现"><a href="#ThreadLocal源码实现" class="headerlink" title="ThreadLocal源码实现"></a>ThreadLocal源码实现</h1><p>数据隔离的秘密其实是这样的，Thread 类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code> ，这个变量用来保存该线程本地变量，也就是说每个线程有一个自己的 ThreadLocalMap，既然是 Map，那么就有键值对，可以简单的将它的 key 看作是 ThreadLocal 自身，而 value 就是存储的值，（实际上 key 并不是 ThreadLocal 本身，而是它的一个弱引用，下文阅读源码可以理解这么做的原因），每个线程在往某个  ThreadLocal 中塞东西的时候，实际上都是往这个线程的 ThreadLocalMap 里面存，读也是以某个 ThreadLocal  作为引用，在自己的 map 里面找对应的 key，从而实现了线程隔离。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>ThreadLocal 自身的 API 较少，面向程序员经常使用的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ThreadLocal&lt;T&gt; threadLocal &#x3D; new ThreadLocal&lt;T&gt;() &#123;</span><br><span class="line">    protected T initialValue() &#123;</span><br><span class="line">        这里一般new一个对象返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程获取相关数据的时候只要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threadLocal.get();</span><br></pre></td></tr></table></figure>

<p>想修改、赋值只要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threadLocal.set(val);</span><br></pre></td></tr></table></figure>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>如上面说到的，ThreadLocal 是用于线程间的数据隔离，ThreadLocal 为每个线程都提供了变量的副本。</p>
<ul>
<li>举例1：联想一下服务器（例如   Tomcat）处理请求的时候，会从线程池中取一条线程出来处理请求，如果想把每个请求的用户信息保存到一个静态变量里以便在处理请求过程中随时获取到用户信息。这时候可以建一个拦截器，请求到来时，把用户信息存到一个静态  ThreadLocal 变量中，那么在请求处理过程中可以随时从静态 ThreadLocal 变量获取用户信息。</li>
<li>举例2：Spring  的事务实现也借助了 ThreadLocal 类。Spring 会从数据库连接池中获得一个 connection，然会把 connection  放进 ThreadLocal 中，也就和线程绑定了，事务需要提交或者回滚，只要从 ThreadLocal 中拿到 connection  进行操作。</li>
</ul>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="get-用法"><a href="#get-用法" class="headerlink" title="get() 用法"></a>get() 用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">     Thread t &#x3D; Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map &#x3D; getMap(t);  &#x2F;&#x2F;ThreadLocal是ThreadLocal的内部类</span><br><span class="line">     if (map !&#x3D; null) &#123; &#x2F;&#x2F;当map已存在</span><br><span class="line">         ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">         if (e !&#x3D; null) &#123;</span><br><span class="line">             @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">             T result &#x3D; (T)e.value;</span><br><span class="line">             return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();  &#x2F;&#x2F;初始化值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面先取到当前线程，然后调用 getMap 方法获取对应的  ThreadLocalMap，ThreadLocalMap 是 ThreadLocal 的静态内部类，而对应的 getMap 获取的  ThreadLocalMap 对象是存储在每个 Thread 对象的 threadLocals 实例变量中的，因此可以直接获取得到。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>下面来看下 ThreadLocal 的内部类 ThreadLocalMap 源码，这个静态内部类才是 ThreadLocal 的核心。</p>
<p><img src="/img/threadlocal/threalLocalMap.png" alt="threalLocalMap"></p>
<p>JDK1.8 中 ThreadLocalMap 静态内部类定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">     private static final int INITIAL_CAPACITY &#x3D; 16;    &#x2F;&#x2F;初始数组大小，大小必须是2的幂</span><br><span class="line">     private Entry[] table;     &#x2F;&#x2F;每个可以拥有多个ThreadLocal，大小必须为2的幂</span><br><span class="line">     private int size &#x3D; 0;</span><br><span class="line">     private int threshold;     &#x2F;&#x2F;扩容阈值</span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F;使用了弱引用，即使Entry只能存活到下次GC之前</span><br><span class="line">     static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">         Object value;</span><br><span class="line">         Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	&#x2F;&#x2F;获取某个ThreadLocal对应的值</span><br><span class="line">    private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">        int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">        Entry e &#x3D; table[i];</span><br><span class="line">        if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key)</span><br><span class="line">           return e;</span><br><span class="line">        else</span><br><span class="line">            return getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	&#x2F;&#x2F;对某个ThreadLocal进行赋值</span><br><span class="line">    private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">       Entry[] tab &#x3D; table;</span><br><span class="line">       int len &#x3D; tab.length;</span><br><span class="line">       int i &#x3D; key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">       for (Entry e &#x3D; tab[i];</span><br><span class="line">             e !&#x3D; null;</span><br><span class="line">             e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">            if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;循环利用key过期的Entry</span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">        int sz &#x3D; ++size;</span><br><span class="line">        &#x2F;&#x2F;扩容进行rehash()</span><br><span class="line">        if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>从整体上看，ThreadLocalMap 提供了一种为 ThreadLocal 定制的高效实现，并且自带一种弱引用的 GC 清理机制。</p>
<p>局部来看，既然是一个  Map（注意此处不要与 java.util.map 混淆，这里只是概念上的 map），那么肯定是有自己的 key 和 value  的，前面问题已经提及，其 key 值是 ThreadLocal 的弱引用，通过源码我们也可以看到这个结论，value 值就是实际放入的值。</p>
<blockquote>
<p>那么为什么要引入弱引用呢？</p>
</blockquote>
<p>其实这也说明作者  Josh Bloch 和 Doug Lea 的鬼斧神工之处，如果这里使用普通的 key-value  形式存储，实质上会造成节点的生命周期与线程强绑定，只要线程没有被销毁，那么节点在 GC  分析中一直处于可达状态，就没有办法被回收，而程序本身也无法判断是否可以清理节点。而引入弱引用就可以解决这个问题，即如果 ThreadLocal  对象没有强引用可达，那么它就活不过下次 GC，那么在 ThreadLocalMap 里面对应的 Entry 的键值就会失效，这为  ThreadLocalMap 本身的垃圾清理机制提供了便利。</p>
<p>我们还可以看到，ThreadLocalMap 维护了一个 Entry 表或者叫 Entry 数组，并且要求表的大小必须是 2 的幂，同时记录表里面 entry 的个数以及下一次扩容的阈值，那么为什么必须是 2 的幂呢？</p>
<p>带着这个问题继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置resize阈值以维持最坏2&#x2F;3的装载因子</span><br><span class="line">private void setThreshold(int len) &#123;</span><br><span class="line">    threshold &#x3D; len * 2 &#x2F; 3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;环形意义的下一个索引</span><br><span class="line">private static int nextIndex(int i, int len) &#123;</span><br><span class="line">    return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;环形意义的上一个索引</span><br><span class="line">private static int prevIndex(int i, int len) &#123;</span><br><span class="line">    return ((i - 1 &gt;&#x3D; 0) ? i - 1 : len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal 需要维持一个最坏 2/3 的负载因子，对于这个负载因子 HashMap 中早就应该接触过这个概念。</p>
<p>ThreadLocal 有两个方法用于得到上一个/下一个索引，注意这里实际上是环形意义下的上一个与下一个。</p>
<p>由于 ThreadLocalMap 使用线性探测法来解决散列冲突，所以实际上<code>Entry[]</code> 数组在程序逻辑上是作为一个环形存在的。 关于开放寻址、线性探测等内容，可以参考网上资料或者《计算机程序设计艺术》第三卷的 6.4 章节。</p>
<p>至此，我们已经可以大致勾勒出 ThreadLocalMap 的内部存储结构。下面是我绘制的示意图。虚线表示弱引用，实线表示强引用。</p>
<p><img src="/img/threadlocal/threadLocalMap%E7%BB%93%E6%9E%84.png" alt="threadLocalMap结构"></p>
<p>ThreadLocalMap 维护了 Entry 环形数组，数组中元素 Entry 的逻辑上的 key 为某个 ThreadLocal  对象（实际上是指向该 ThreadLocal 对象的弱引用），value 为代码中该线程往该 ThreadLocal 变量实际塞入的值。</p>
<p>然后看一下 ThreadLocalMap 的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 构造一个包含firstKey和firstValue的map。</span><br><span class="line"> * ThreadLocalMap是惰性构造的，所以只有当至少要往里面放一个元素的时候才会构建它。</span><br><span class="line"> *&#x2F;</span><br><span class="line">ThreadLocalMap(java.lang.ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化table数组</span><br><span class="line">    table &#x3D; new Entry[INITIAL_CAPACITY];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 用firstKey的threadLocalHashCode与初始大小16取模得到哈希值</span><br><span class="line">    int i &#x3D; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化该节点</span><br><span class="line">    table[i] &#x3D; new Entry(firstKey, firstValue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置节点表大小为1</span><br><span class="line">    size &#x3D; 1;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设定扩容阈值</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造函数在 set 和 get 的时候都可能会被间接调用以初始化线程的 ThreadLocalMap。</p>
<p>然后看一下上面代码中的<code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</code> 这一行，ThreadLocal 类中有一个被 final 修饰的类型为 int 的 threadLocalHashCode，它在该 ThreadLocal 被构造的时候就会生成，相当于一个 ThreadLocal 的 ID，而它的值来源于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 生成hash code间隙为这个魔数，可以让生成出来的值或者说ThreadLocal的ID较为均匀地分布在2的幂大小的数组中。</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final int HASH_INCREMENT &#x3D; 0x61c88647;</span><br><span class="line"> </span><br><span class="line">private static int nextHashCode() &#123;</span><br><span class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，它是在上一个被构造出的 ThreadLocal 的 <code>ID / threadLocalHashCode</code> 的基础上加上一个魔数<code>0x61c88647</code>的。这个魔数的选取与斐波那契散列有关，<code>0x61c88647</code>对应的十进制为 <code>1640531527</code>。斐波那契散列的乘数可以用<code>(long) ((1L &lt;&lt; 31) * (Math.sqrt(5) - 1))</code>可以得到 <code>2654435769</code>，如果把这个值给转为带符号的 int，则会得到 <code>-1640531527</code>。换句话说<br><code>(1L &lt;&lt; 32) - (long) ((1L &lt;&lt; 31) * (Math.sqrt(5) - 1))</code>得到的结果就是<code>1640531527</code>也就是<code>0x61c88647</code>。通过理论与实践，当我们用 <code>0x61c88647</code> 作为魔数累加为每个 ThreadLocal 分配各自的 ID 也就是<code>threadLocalHashCode</code>再与 2 的幂取模，得到的结果分布很均匀。<br><code>ThreadLocalMap</code>使用的是线性探测法，均匀分布的好处在于很快就能探测到下一个临近的可用<code>slot</code>，从而保证效率。这就回答了上文抛出的为什么大小要为 2 的幂的问题。即为了优化效率。</p>
<p>对于<code>&amp; (INITIAL_CAPACITY - 1)</code>，相信有过算法竞赛经验或是阅读源码较多的程序员，一看就明白，对于 2 的幂作为模数取模，可以用 <code>&amp; (2^n - 1)</code>来替代<code>% 2^n</code>，位运算比取模效率高很多。至于为什么，因为对 <code>2^n</code> 取模，只要不是低 n 位对结果的贡献显然都是 0，会影响结果的只能是低 n 位。</p>
<p>可以说在 ThreadLocalMap 中，形如<code>key.threadLocalHashCode &amp; (table.length - 1)</code>（其中 key 为一个 ThreadLocal 实例）这样的代码片段实质上就是在求一个 ThreadLocal 实例的哈希值，只是在源码实现中没有将其抽为一个公用函数。</p>
<p>再来看看 ThreadLocalMap 的主要方法：</p>
<p>（1）getEntry() 方法</p>
<p>这个方法会被 ThreadLocal 的 get 方法直接调用，用于获取 map 中某个 ThreadLocal 存放的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据key这个ThreadLocal的ID来获取索引，也即哈希值</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e &#x3D; table[i];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 对应的entry存在且未失效且弱引用指向的ThreadLocal就是key，则命中返回</span><br><span class="line">    if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key) &#123;</span><br><span class="line">        return e;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 因为用的是线性探测，所以往后找还是有可能能够找到目标Entry的。</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line"> * 调用getEntry未直接命中的时候调用此方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F; 基于线性探测法不断向后探测直到遇到空entry。</span><br><span class="line">    while (e !&#x3D; null) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">        &#x2F;&#x2F; 找到目标</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            return e;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 该entry对应的ThreadLocal已经被回收，调用expungeStaleEntry来清理无效的entry</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 环形意义下往后面走</span><br><span class="line">            i &#x3D; nextIndex(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        e &#x3D; tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 这个函数是ThreadLocal中核心清理函数，它做的事情很简单：</span><br><span class="line"> * 就是从staleSlot开始遍历，将无效（弱引用指向对象被回收）清理，即对应entry中的value置为null，将指向这个entry的table[i]置为null，直到扫到空entry。</span><br><span class="line"> * 另外，在过程中还会对非空的entry作rehash。</span><br><span class="line"> * 可以说这个函数的作用就是从staleSlot开始清理连续段中的slot（断开强引用，rehash slot等）</span><br><span class="line"> *&#x2F;</span><br><span class="line">private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 因为entry对应的ThreadLocal已经被回收，value设为null，显式断开强引用</span><br><span class="line">    tab[staleSlot].value &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 显式设置该entry为null，以便垃圾回收</span><br><span class="line">    tab[staleSlot] &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line"> </span><br><span class="line">    Entry e;</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; nextIndex(staleSlot, len); (e &#x3D; tab[i]) !&#x3D; null; i &#x3D; nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">        &#x2F;&#x2F; 清理对应ThreadLocal已经被回收的entry</span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            e.value &#x3D; null;</span><br><span class="line">            tab[i] &#x3D; null;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 对于还没有被回收的情况，需要做一次rehash。</span><br><span class="line">             * </span><br><span class="line">             * 如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i，</span><br><span class="line">             * 则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            int h &#x3D; k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">            if (h !&#x3D; i) &#123;</span><br><span class="line">                tab[i] &#x3D; null;</span><br><span class="line">                </span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * 在原代码的这里有句注释值得一提，原注释如下：</span><br><span class="line">                 *</span><br><span class="line">                 * Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="line">                 * null because multiple entries could have been stale.</span><br><span class="line">                 *</span><br><span class="line">                 * 这段话提及了Knuth高德纳的著作TAOCP（《计算机程序设计艺术》）的6.4章节（散列）</span><br><span class="line">                 * 中的R算法。R算法描述了如何从使用线性探测的散列表中删除一个元素。</span><br><span class="line">                 * R算法维护了一个上次删除元素的index，当在非空连续段中扫到某个entry的哈希值取模后的索引</span><br><span class="line">                 * 还没有遍历到时，会将该entry挪到index那个位置，并更新当前位置为新的index，</span><br><span class="line">                 * 继续向后扫描直到遇到空的entry。</span><br><span class="line">                 *</span><br><span class="line">                 * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即</span><br><span class="line">                 * 有效（value未回收），无效（value已回收），空（entry&#x3D;&#x3D;null）。</span><br><span class="line">                 * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。</span><br><span class="line">                 *</span><br><span class="line">                 * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot，</span><br><span class="line">                 * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                while (tab[h] !&#x3D; null) &#123;</span><br><span class="line">                    h &#x3D; nextIndex(h, len);</span><br><span class="line">                &#125;</span><br><span class="line">                tab[h] &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回staleSlot之后第一个空的slot索引</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来回顾一下从 ThreadLocal 读一个值可能遇到的情况：<br>根据入参<code>threadLocal</code>的<code>threadLocalHashCode</code>对表容量取模得到index</p>
<ul>
<li>如果 index 对应的 slot 就是要读的 threadLocal，则直接返回结果</li>
<li>调用<code>getEntryAfterMiss</code>线性探测，过程中每碰到无效 slot，调用<code>expungeStaleEntry</code>进行段清理；如果找到了 key，则返回结果 entry</li>
<li>没有找到 key，返回 null</li>
</ul>
<h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"> </span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">    &#x2F;&#x2F; 线性探测</span><br><span class="line">    for (Entry e &#x3D; tab[i]; e !&#x3D; null; e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">        &#x2F;&#x2F; 找到对应的entry</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 替换失效的entry</span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">    int sz &#x3D; ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                               int staleSlot) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 向前扫描，查找最前的一个无效slot</span><br><span class="line">    int slotToExpunge &#x3D; staleSlot;</span><br><span class="line">    for (int i &#x3D; prevIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; prevIndex(i, len)) &#123;</span><br><span class="line">        if (e.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 向后遍历table</span><br><span class="line">    for (int i &#x3D; nextIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 找到了key，将其与无效的slot交换</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            &#x2F;&#x2F; 更新对应slot的value值</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line"> </span><br><span class="line">            tab[i] &#x3D; tab[staleSlot];</span><br><span class="line">            tab[staleSlot] &#x3D; e;</span><br><span class="line"> </span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 如果在整个扫描过程中（包括函数一开始的向前扫描与i之前的向后扫描）</span><br><span class="line">             * 找到了之前的无效slot则以那个位置作为清理的起点，</span><br><span class="line">             * 否则则以当前的i作为清理起点</span><br><span class="line">             *&#x2F;</span><br><span class="line">            if (slotToExpunge &#x3D;&#x3D; staleSlot) &#123;</span><br><span class="line">                slotToExpunge &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 从slotToExpunge开始做一次连续段的清理，再做一次启发式清理</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span><br><span class="line">        if (k &#x3D;&#x3D; null &amp;&amp; slotToExpunge &#x3D;&#x3D; staleSlot) &#123;</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 如果key在table中不存在，则在原地放一个即可</span><br><span class="line">    tab[staleSlot].value &#x3D; null;</span><br><span class="line">    tab[staleSlot] &#x3D; new Entry(key, value);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理）</span><br><span class="line">    if (slotToExpunge !&#x3D; staleSlot) &#123;</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 启发式地清理slot,</span><br><span class="line"> * i对应entry是非无效（指向的ThreadLocal没被回收，或者entry本身为空）</span><br><span class="line"> * n是用于控制控制扫描次数的</span><br><span class="line"> * 正常情况下如果log n次扫描没有发现无效slot，函数就结束了</span><br><span class="line"> * 但是如果发现了无效的slot，将n置为table的长度len，做一次连续段的清理</span><br><span class="line"> * 再从下一个空的slot开始继续扫描</span><br><span class="line"> * </span><br><span class="line"> * 这个函数有两处地方会被调用，一处是插入的时候可能会被调用，另外个是在替换无效slot的时候可能会被调用，</span><br><span class="line"> * 区别是前者传入的n为元素个数，后者为table的容量</span><br><span class="line"> *&#x2F;</span><br><span class="line">private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">    boolean removed &#x3D; false;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; i在任何情况下自己都不会是一个无效slot，所以从下一个开始判断</span><br><span class="line">        i &#x3D; nextIndex(i, len);</span><br><span class="line">        Entry e &#x3D; tab[i];</span><br><span class="line">        if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 扩大扫描控制因子</span><br><span class="line">            n &#x3D; len;</span><br><span class="line">            removed &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 清理一个连续段</span><br><span class="line">            i &#x3D; expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((n &gt;&gt;&gt;&#x3D; 1) !&#x3D; 0);</span><br><span class="line">    return removed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">private void rehash() &#123;</span><br><span class="line">    &#x2F;&#x2F; 做一次全量清理</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"> </span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 因为做了一次清理，所以size很可能会变小。</span><br><span class="line">     * ThreadLocalMap这里的实现是调低阈值来判断是否需要扩容，</span><br><span class="line">     * threshold默认为len*2&#x2F;3，所以这里的threshold - threshold &#x2F; 4相当于len&#x2F;2</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (size &gt;&#x3D; threshold - threshold &#x2F; 4) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line"> * 做一次全量清理</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void expungeStaleEntries() &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e &#x3D; tab[j];</span><br><span class="line">        if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 个人觉得这里可以取返回值，如果大于j的话取了用，这样也是可行的。</span><br><span class="line">             * 因为expungeStaleEntry执行过程中是把连续段内所有无效slot都清理了一遍了。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 扩容，因为需要保证table的容量len为2的幂，所以扩容即扩大2倍</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void resize() &#123;</span><br><span class="line">    Entry[] oldTab &#x3D; table;</span><br><span class="line">    int oldLen &#x3D; oldTab.length;</span><br><span class="line">    int newLen &#x3D; oldLen * 2;</span><br><span class="line">    Entry[] newTab &#x3D; new Entry[newLen];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    for (int j &#x3D; 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e &#x3D; oldTab[j];</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">            if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">                e.value &#x3D; null; </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 线性探测来存放Entry</span><br><span class="line">                int h &#x3D; k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                while (newTab[h] !&#x3D; null) &#123;</span><br><span class="line">                    h &#x3D; nextIndex(h, newLen);</span><br><span class="line">                &#125;</span><br><span class="line">                newTab[h] &#x3D; e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size &#x3D; count;</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来回顾一下 ThreadLocal 的 set 方法可能会有的情况 :</p>
<ul>
<li><p>探测过程中 slot 都不无效，并且顺利找到 key 所在的 slot，直接替换即可</p>
</li>
<li><p>探测过程中发现有无效 slot，调用 replaceStaleEntry，效果是最终一定会把 key 和 value 放在这个 slot，并且会尽可能清理无效 slot</p>
<p>(1) 在 replaceStaleEntry 过程中，如果找到了 key，则做一个 swap 把它放到那个无效 slot 中，value 置为新值</p>
<p>(2) 在 replaceStaleEntry 过程中，没有找到 key，直接在无效 slot 原地放 entry</p>
</li>
<li><p>探测没有发现  key，则在连续段末尾的后一个空位置放上 entry，这也是线性探测法的一部分。放完后，做一次启发式清理，如果没清理出去 key，并且当前  table 大小已经超过阈值了，则做一次 rehash，rehash 函数会调用一次全量清理 slot 方法也即 <code>expungeStaleEntries()</code>，如果完了之后 table 大小超过了 <code>threshold - threshold / 4</code>，则进行扩容 2 倍</p>
</li>
</ul>
<h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove() 方法"></a>remove() 方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 从map中删除ThreadLocal</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void remove(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">    for (Entry e &#x3D; tab[i];</span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">        if (e.get() &#x3D;&#x3D; key) &#123;</span><br><span class="line">            &#x2F;&#x2F; 显式断开弱引用</span><br><span class="line">            e.clear();</span><br><span class="line">            &#x2F;&#x2F; 进行段清理</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove 方法相对于 getEntry 和 set 方法比较简单，直接在 table 中找 key，如果找到了，把弱引用断了做一次段清理。</p>
<p>以上就是 ThreadLocalMap 的源码分析。</p>
<p>回顾下 ThreadLocal中 的 get() 方法中的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (map !&#x3D; null) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">    if (e !&#x3D; null) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        T result &#x3D; (T)e.value;</span><br><span class="line">        return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">return setInitialValue();</span><br></pre></td></tr></table></figure>

<p>map 为<code>null</code>或e为<code>null</code>就会走到<code>setInitialValue</code>，如果我们是第一次<code>get()</code>方法，那 map 会是空的，所以接下来先看<code>setInitialValue()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">     &#x2F;&#x2F;调用我们实现的方法得到需要线程隔离的值</span><br><span class="line">     T value &#x3D; initialValue();</span><br><span class="line">     Thread t &#x3D; Thread.currentThread();</span><br><span class="line">     &#x2F;&#x2F;拿到相应线程的ThreadLocalMap成员变量</span><br><span class="line">     ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">     if (map !&#x3D; null)</span><br><span class="line">         map.set(this, value);</span><br><span class="line">     else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面 initialValue 就是实例化 ThreadLocal 要实现的方法，这里又取了线程的  ThreadLocalMap，不为空就把值 set 进去（键为 TreadLocal 本身，值就是 initialValue  返回的值）；为空就创建一个 map 同时添加一个值进去,最后返回 value。</p>
</blockquote>
<p><code>map.set(this, value)</code>这句代码在上面的<code>ThreadLocalMap</code>源码中可以看到大致流程，下面看看<code>createMap()</code>做了什么事：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">     t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table &#x3D; new Entry[INITIAL_CAPACITY];</span><br><span class="line">    int i &#x3D; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    &#x2F;&#x2F;创建一个Entry，加入数组</span><br><span class="line">    table[i] &#x3D; new Entry(firstKey, firstValue);</span><br><span class="line">    size &#x3D; 1;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到在 new ThreadLocalMap 之后，就会创建一个 Entry 加入到数组中，最后把 ThreadLocalMap 的引用赋值给 Thread 的 threadLocals 成员变量</p>
</blockquote>
<p>再回顾下 get() 方法中的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (map !&#x3D; null) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">    if (e !&#x3D; null) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        T result &#x3D; (T)e.value;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return setInitialValue();</span><br></pre></td></tr></table></figure>

<p>现在 map 不会为空了，再次调用 get 方法就会调用 map 的<code>getEntry()</code>方法（上面的 ThreadLocalMap 源码中可以看到大致流程），拿到相应的 Entry，然后就可以拿到相应的值返回出去 。</p>
<p>分析完 get() 方法，那么 set() 方法就自然而然的明白了，就不再赘述 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">   else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ThreadLocal  的实现原理是，在每个线程中维护一个 Map，键是 ThreadLocal 类型，值是 Object 类型。当想获取 ThreadLocal  的值时，就从当前线程中拿出 Map，然后再把 ThreadLocal 本身作为键从 Map 中拿出值返回。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点</li>
</ul>
<p>提供线程内的局部变量。每个线程都自己管理自己的局部变量，互不影响。</p>
<ul>
<li>缺点</li>
</ul>
<p>可能存在的内存泄漏问题。</p>
<p>关于 ThreadLocal 是否会引起内存泄漏也是一个比较有争议性的问题，其实就是要看对内存泄漏的准确定义是什么。<br>认为 ThreadLocal 会引起内存泄漏的说法是因为如果一个 ThreadLocal 对象被回收了，我们往里面放的 value 对于【当前线程 -&gt; 当前线程的 threadLocals (<code>ThreadLocal.ThreadLocalMap</code> 对象）-&gt; Entry 数组-&gt;某个 entry.value】这样一条强引用链是可达的，因此 value 不会被回收。<br>认为 ThreadLocal 不会引起内存泄漏的说法是因为 ThreadLocal.ThreadLocalMap 源码实现中自带一套自我清理的机制。</p>
<p>之所以有关于内存泄露的讨论是因为在有线程复用如线程池的场景中，一个线程的寿命很长，大对象长期不被回收影响系统运行效率与安全。如果线程不会复用，用完即销毁了也不会有  ThreadLocal 引发内存泄露的问题。《Effective Java》一书中的第 6 条对这种内存泄露称为<code>unintentional object retention</code>(无意识的对象保留）。</p>
<p>当我们仔细读过 ThreadLocalMap 的源码，我们可以推断，如果在使用的 ThreadLocal 的过程中，显式地进行remove 是个很好的编码习惯，这样是不会引起内存泄漏。<br>那么如果没有显式地进行 remove 呢？只能说如果对应线程之后调用 ThreadLocal 的 get() 和 set() 方法都有很高的概率会顺便清理掉无效对象，断开 value 强引用，从而大对象被收集器回收。</p>
<p>但无论如何，我们应该考虑到何时调用  ThreadLocal 的 remove 方法。一个比较熟悉的场景就是对于一个请求一个线程的 server 如 Tomcat，在代码中对  web api 作一个切面，存放一些如用户名等用户信息，在连接点方法结束后，再显式调用 remove。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://allenwu.itscoder.com/threadlocal-source" target="_blank" rel="noopener">深入理解 Java 之 ThreadLocal 工作原理</a></li>
<li><a href="https://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="noopener">彻底理解ThreadLocal</a></li>
<li><a href="https://www.cnblogs.com/zhangjk1993/archive/2017/03/29/6641745.html#_label2" target="_blank" rel="noopener">【Java 并发】详解 ThreadLocal</a></li>
<li><a href="https://www.cnblogs.com/xzwblog/p/7227509.html" target="_blank" rel="noopener">彻底理解ThreadLocal</a></li>
<li><a href="https://blog.csdn.net/u012834750/article/details/71646700" target="_blank" rel="noopener">ThreadLocal 内部实现、应用场景和内存泄漏</a></li>
<li><a href="https://juejin.im/post/5c99c7c8f265da60e65ba56d" target="_blank" rel="noopener">ThreadLocal和ThreadLocalMap源码分析</a></li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java内存模型（一）：基础</title>
    <url>/2020/04/05/javaMemoryModel01/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在正式理解 Java 内存模型之前，有必要先了解一下物理计算机中的并发问题，物理机中遇到的并发问题与虚拟机中的情况有不少相似之处，并且物理机对并发的处理方案对于虚拟机的实现也具有很大的参考意义。<br>在物理机中，由于绝大多数运算任务不可能只靠处理器计算完成，处理器还需要与内存交互，如读取数据、存储运算结果等，这个 I/O 操作是很难消除的（即无法仅靠寄存器来完成所有运算任务）。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束之后再从缓存同步回内存中，这样处理器就无须等待缓慢的内存读写了。</p>
<a id="more"></a>
<p>基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但是同时也带来了新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memeory）。</p>
<p><img src="/img/multithreading01/computer-mm.png" alt="computer-mm"><br>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回主内存时以谁的缓存数据为准呢？为了解决这个问题，因此制定了缓存一致性协议，在读写时要根据协议来进行操作，这类协议有 MSI 、 MESI 、MOSI 、 Synapse 、 Firefly 及 Dragon Protocol 等。<br>因此后面提到的内存模型，都可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象，不同架构的物理机器可以拥有不一样的内存模型，而 Java 虚拟机也有自己的内存模型。理解物理机的内存模型后，对于我们理解 Java 虚拟机的内存模型有很大帮助。</p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：</p>
<ol>
<li>线程间通信：线程间以何种机制交换信息，命令式编程中有共享内存和消息传递两种</li>
<li>线程间同步：程序控制不同线程之间的操作发生的相对顺序</li>
</ol>
<p>其中，在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。线程同步是显式进行的，程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。由于消息的发送必须在消息的接收之前，因此线程同步是隐式进行的。</p>
<blockquote>
<p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
</blockquote>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><blockquote>
<p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memeory Model，JMM）来屏蔽各种硬件和操作系统的差异性，以实现让 Java 程序在各种平台下都能达到一直的内存访问效果。而定义 JMM 并非是一件容易的事，这个模型必须足够严谨，才能让 Java的并发内存访问操作不会产生歧义；但是同时也必须定义的足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，在 JSR-133 发布后， JMM 开始成熟和完善了起来。</p>
</blockquote>
<p>在 Java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br>Java 线程之间的通信由 JMM 来屏蔽各种控制，同样地， JMM 模型跟物理计算机内存模型基本一致，其模型抽象如下：</p>
<p><img src="/img/multithreading01/b098a84eb7598d70913444a991d1759b.png" alt=""><br>JMM 的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量包括实例字段、静态字段和构成数组对象的元素，但是不包括线程私有的局部变量和方法参数。</p>
<p>JMM 规定了所有的变量都存储在主内存（Main Memeory）中，每条线程都有自己的本地内存（local Memeory，或叫做工作内存），本地内存与物理机内存模型中的高速缓存相似，作用相同。线程的本地内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、幅值等）都必须在本地内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法访问对方的本地内存。</p>
<blockquote>
<p>本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
</blockquote>
<p>从 JMM 模型图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p>
<ol>
<li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。<br>下面通过示意图来说明这两个步骤：</li>
</ol>
<p><img src="/img/multithreading01/2c452d147bf0d09b14b770d3990740cb.png" alt=""><br>如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。<br>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li><strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li><strong>内存系统的重排序</strong>。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<p><img src="/img/multithreading01/9026b8f4b6c1fae4270615e0aadc7cdf.png" alt=""><br>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>
<blockquote>
<p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
</blockquote>
<h3 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！为了具体说明，请看下面示例：</p>
<table>
<thead>
<tr>
<th><strong>Processor A</strong></th>
<th><strong>Processor B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>a = 1; //A1 x = b; //A2</td>
<td>b = 2; //B1 y = a; //B2</td>
</tr>
<tr>
<td>初始状态：a = b = 0 处理器允许执行后得到结果：x = y = 0</td>
<td>/</td>
</tr>
</tbody></table>
<p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下图所示：<br><img src="/img/multithreading01/7004695e6bacd62e916f2f5ece3d7c9d.png" alt=""><br>这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。<br>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。<br>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写 - 读操做重排序。<br>下面是常见处理器允许的重排序类型的列表：</p>
<table>
<thead>
<tr>
<th></th>
<th>Load-Load</th>
<th>Load-Store</th>
<th>Store-Store</th>
<th>Store-Load</th>
<th>数据依赖</th>
</tr>
</thead>
<tbody><tr>
<td>sparc-TSO</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>x86</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。<br>从上表我们可以看出：常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。<br>※注 1：sparc-TSO 是指以 TSO(Total Store Order) 内存模型运行时，sparc 处理器的特性。<br>※注 2：上表中的 x86 包括 x64 及 AMD64。<br>※注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。<br>※注 4：数据依赖性后文会专门说明。<br>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody></table>
<p><strong>StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</strong></p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p>
<ul>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li>
<li><strong>volatile 变量规则</strong>：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li>
<li><strong>传递性</strong>：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li>
</ul>
<blockquote>
<p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。</p>
</blockquote>
<p>happens-before 与 JMM 的关系如下图所示：</p>
<p><img src="/img/multithreading01/bc22eaae1a77f9e1a6c09f4b6a833163.png" alt="bc22eaae1a77f9e1a6c09f4b6a833163"><br>如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
]]></content>
      <categories>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java内存模型（二）：重排序</title>
    <url>/2020/04/09/javaMemoryModel02/</url>
    <content><![CDATA[<h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量。</td>
</tr>
</tbody></table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<a id="more"></a>

<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h3 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h3><p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double pi  &#x3D; 3.14;    &#x2F;&#x2F;A</span><br><span class="line">double r   &#x3D; 1.0;     &#x2F;&#x2F;B</span><br><span class="line">double area &#x3D; pi * r * r; &#x2F;&#x2F;C</span><br></pre></td></tr></table></figure>

<p>上面三个操作的数据依赖关系如下图所示：</p>
<p><img src="/img/multithreading01/b25896c0d68909db2b87dead6f4d9133.png" alt="b25896c0d68909db2b87dead6f4d9133"></p>
<p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B<br>的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B<br>之间的执行顺序。下图是该程序的两种执行顺序：</p>
<p><img src="/img/multithreading01/6d3b490450d04a52a096ca702f60e434.png" alt="6d3b490450d04a52a096ca702f60e434"></p>
<p>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime  和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial  语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><p>根据 happens- before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens- before 关系：</p>
<ol>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ol>
<p>这里的第 3 个 happens- before 关系，是根据 happens- before 的传递性推导出来的。</p>
<p>这里  A happens- before B，但实际执行时 B 却可以排在 A 之前执行（看上面的重排序后的执行顺序）。在第一章提到过，如果 A  happens- before B，JMM 并不要求 A 一定要在 B 之前执行。JMM  仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作 A 的执行结果不需要对操作 B  可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和操作 B 按 happens- before  顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。</p>
<h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ReorderExample &#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">boolean flag &#x3D; false;</span><br><span class="line"></span><br><span class="line">public void writer() &#123;</span><br><span class="line">    a &#x3D; 1;                   &#x2F;&#x2F;1</span><br><span class="line">    flag &#x3D; true;             &#x2F;&#x2F;2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Public void reader() &#123;</span><br><span class="line">    if (flag) &#123;                &#x2F;&#x2F;3</span><br><span class="line">        int i &#x3D;  a * a;        &#x2F;&#x2F;4</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flag 变量是个标记，用来标识变量 a 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行 writer() 方法，随后 B  线程接着执行 reader() 方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入？</p>
<p>答案是：不一定能看到。</p>
<p>由于操作  1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4  没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作 1 和操作 2  重排序时，可能会产生什么效果？请看下面的程序执行时序图：</p>
<p><img src="/img/multithreading01/aef14e33b3f92d5b045b338509a7d0d8.png" alt="aef14e33b3f92d5b045b338509a7d0d8"></p>
<p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p>
<p>※注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。</p>
<p>下面再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作 3 和操作 4 重排序后，程序的执行时序图：</p>
<p><img src="/img/multithreading01/49ae9eb5df8f260d46dc2c84a48a7748.png" alt="49ae9eb5df8f260d46dc2c84a48a7748"></p>
<p>在程序中，操作 3 和操作 4  存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程  B 的处理器可以提前读取并计算 a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer  ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。从图中我们可以看出，猜测执行实质上对操作 3 和 4  做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<p>本文转载自《Java并发编程的艺术》作者之一<strong>程晓明</strong>的博客<a href="https://www.infoq.cn/article/java-memory-model-2" target="_blank" rel="noopener"> “深入理解 Java 内存模型（二）——重排序”</a></p>
]]></content>
      <categories>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java内存模型（三）：顺序一致性</title>
    <url>/2020/04/11/javaMemoryModel03/</url>
    <content><![CDATA[<h3 id="数据竞争与顺序一致性保证"><a href="#数据竞争与顺序一致性保证" class="headerlink" title="数据竞争与顺序一致性保证"></a>数据竞争与顺序一致性保证</h3><p>当程序未正确同步时，就会存在数据竞争。java 内存模型规范对数据竞争的定义如下：</p>
<ul>
<li>在一个线程中写一个变量，</li>
<li>在另一个线程读同一个变量，</li>
<li>而且写和读没有通过同步来排序。</li>
</ul>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p>
<a id="more"></a>

<p>JMM 对正确同步的多线程程序的内存一致性做了如下保证：</p>
<ul>
<li>如果程序是正确同步的，程序的执行将具有<strong>顺序一致性</strong>（sequentially  consistent）–  即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile  和 final）的正确使用。</li>
</ul>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
<p>顺序一致性内存模型为程序员提供的视图如下：</p>
<p><img src="/img/multithreading01/4987a0c005023fbbab06293aa2c36da5.png" alt="4987a0c005023fbbab06293aa2c36da5"></p>
<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读  / 写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读 /  写操作串行化。</p>
<p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p>
<p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B 线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。</p>
<p>假设这两个线程使用监视器来正确同步：A 线程的三个操作执行后释放监视器，随后 B 线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：</p>
<p><img src="/img/multithreading01/a2be3cbfb19fa8854510e708a65e31df.png" alt="a2be3cbfb19fa8854510e708a65e31df"></p>
<p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p>
<p><img src="/img/multithreading01/4f5afaac60fff83522424ed5486f0d13.png" alt="4f5afaac60fff83522424ed5486f0d13"></p>
<p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B  看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p>
<p>但是，在  JMM 中就没有这个保证。未同步程序在 JMM  中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p>
<h3 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h3><p>下面我们对前面的示例程序 ReorderExample 用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SynchronizedExample &#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">boolean flag &#x3D; false;</span><br><span class="line"></span><br><span class="line">public synchronized void writer() &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    flag &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void reader() &#123;</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        int i &#x3D; a;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例代码中，假设 A 线程执行 writer() 方法后，B 线程执行 reader() 方法。这是一个正确同步的多线程程序。根据 JMM 规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p>
<p><img src="/img/multithreading01/08b2577f293533447511fe3724ecbd10.png" alt="08b2577f293533447511fe3724ecbd10"></p>
<p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在 JMM 中，<strong>临界区内的代码可以重排序</strong>（但  JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM  会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程  A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A  在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>
<p>从这里我们可以看到 JMM 在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p>
<h3 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h3><p>对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM 保证线程读操作读取到的值不会<strong>无中生有</strong>（out  of thin air）的冒出来。为了实现最小安全性，JVM 在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM  内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p>
<p>JMM 不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p>
<p>和顺序一致性模型一样，未同步程序在 JMM 中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p>
<ol>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li>
<li>JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性。</li>
</ol>
<p>第  3  个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus  transaction）。总线事务包括读事务（read transaction）和写事务（write  transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读 /  写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和  I/O 设备执行内存的读 / 写。下面让我们通过一个示意图来说明总线的工作机制：</p>
<p><img src="/img/multithreading01/716756201ce6e9dcc569ba78d6658bfc.png" alt="716756201ce6e9dcc569ba78d6658bfc"></p>
<p>如上图所示，假设处理器 A，B 和 C 同时向总线发起总线事务，这时总线仲裁（bus  arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器 A  在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A  的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D  向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p>
<p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读 / 写操作具有原子性。</p>
<p>在一些  32 位的处理器上，如果要求对 64 位数据的读 / 写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java 语言规范鼓励但不强求  JVM 对 64 位的 long 型变量和 double 型变量的读 / 写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位  long/ double 型变量的读 / 写操作拆分为两个 32 位的读 / 写操作来执行。这两个 32 位的读 /  写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的读 / 写将不具有原子性。</p>
<p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p>
<p><img src="/img/multithreading01/e78e4a0bc47da41ca330ae0355cb6f5a.png" alt="e78e4a0bc47da41ca330ae0355cb6f5a"></p>
<p>如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64  位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被拆分为两个  32 位的读操作，且这两个 32 位的读操作被分配到同一个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B  将看到仅仅被处理器 A“写了一半“的无效值。</p>
<p>注意，在JSR-133之前的旧内存模型中，一个64位的long/double类型的变量的读/写操作可以被拆分为两个32位的读/写操作来执行。从JSR-133内存模型开始（即JDK5开始），仅仅允许把一个64位long/double类型的变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性。</p>
<p>本文转载自《Java并发编程的艺术》作者之一<strong>程晓明</strong>的博客<a href="https://www.infoq.cn/article/java-memory-model-3" target="_blank" rel="noopener"> “深入理解 Java 内存模型（三）——顺序一致性”</a></p>
]]></content>
      <categories>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java内存模型（四）：volatile</title>
    <url>/2020/04/13/javaMemoryModel04/</url>
    <content><![CDATA[<h2 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h2><p>当我们声明共享变量为 volatile 后，对这个变量的读 / 写将会很特别。理解 volatile 特性的一个好方法是：<strong>把对 volatile 变量的单个读 / 写，看成是使用同一个监视器锁对这些单个读 / 写操作做了同步</strong>。下面我们通过具体的示例来说明，请看下面的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class VolatileFeaturesExample &#123;</span><br><span class="line">    volatile long vl &#x3D; 0L;  &#x2F;&#x2F; 使用 volatile 声明 64 位的 long 型变量 </span><br><span class="line"></span><br><span class="line">    public void set(long l) &#123;</span><br><span class="line">        vl &#x3D; l;   &#x2F;&#x2F; 单个 volatile 变量的写 </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getAndIncrement () &#123;</span><br><span class="line">        vl++;    &#x2F;&#x2F; 复合（多个）volatile 变量的读 &#x2F; 写 </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long get() &#123;</span><br><span class="line">        return vl;   &#x2F;&#x2F; 单个 volatile 变量的读 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class VolatileFeaturesExample &#123;</span><br><span class="line">    long vl &#x3D; 0L;               &#x2F;&#x2F; 64 位的 long 型普通变量 </span><br><span class="line"></span><br><span class="line">    public synchronized void set(long l) &#123;     &#x2F;&#x2F; 对单个的普通 变量的写用同一个监视器同步 </span><br><span class="line">        vl &#x3D; l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getAndIncrement () &#123; &#x2F;&#x2F; 普通方法调用 </span><br><span class="line">        long temp &#x3D; get();           &#x2F;&#x2F; 调用已同步的读方法 </span><br><span class="line">        temp +&#x3D; 1L;                  &#x2F;&#x2F; 普通写操作 </span><br><span class="line">        set(temp);                   &#x2F;&#x2F; 调用已同步的写方法 </span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized long get() &#123; </span><br><span class="line">    &#x2F;&#x2F; 对单个的普通变量的读用同一个监视器同步 </span><br><span class="line">        return vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面示例程序所示，对一个 volatile 变量的单个读 / 写操作，与对一个普通变量的读 / 写操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p>
<p>监视器锁的 happens-before 规则保证释放监视器和获取监视器的两个线程之间的内存可见性，<strong>这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入</strong>。</p>
<p>监视器锁的语义决定了临界区代码的执行具有原子性。<strong>这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性**</strong>。如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性。**</p>
<p>简而言之，volatile 变量自身具有下列特性：</p>
<ul>
<li><strong>可见性：</strong>对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li>
<li><strong>原子性：</strong>对任意单个 volatile 变量的读 / 写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li>
</ul>
<h2 id="volatile-写-读建立的-happens-before-关系"><a href="#volatile-写-读建立的-happens-before-关系" class="headerlink" title="volatile 写 - 读建立的 happens before 关系"></a>volatile 写 - 读建立的 happens before 关系</h2><p>上面讲的是 volatile 变量自身的特性，对程序员来说，volatile 对线程的内存可见性的影响比 volatile 自身的特性更为重要，也更需要我们去关注。</p>
<p>从 JSR-133 开始，<strong>volatile 变量的写 - 读可以实现线程之间的通信</strong>。</p>
<p>从内存语义的角度来说，volatile 与监视器锁有相同的效果：volatile 写和监视器的释放有相同的内存语义；volatile 读与监视器的获取有相同的内存语义。</p>
<p>请看下面使用 volatile 变量的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">    int a &#x3D; 0;</span><br><span class="line">    volatile boolean flag &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a &#x3D; 1;                   &#x2F;&#x2F;1</span><br><span class="line">        flag &#x3D; true;             &#x2F;&#x2F;2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (flag) &#123;               &#x2F;&#x2F;3</span><br><span class="line">            int i &#x3D;  a;           &#x2F;&#x2F;4</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程 A 执行 writer() 方法之后，线程 B 执行 reader() 方法。根据 happens before 规则，这个过程建立的 happens before 关系可以分为两类：</p>
<ol>
<li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li>
<li>根据 volatile 规则，2 happens before 3。</li>
<li>根据 happens before 的传递性规则，1 happens before 4。</li>
</ol>
<p>上述 happens before 关系的图形化表现形式如下：</p>
<p><img src="/img/multithreading01/3104638509c2c1b898c5e249cb30065a.png" alt="3104638509c2c1b898c5e249cb30065a"></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。</p>
<p><strong>这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写 volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。</strong></p>
<h2 id="volatile-写-读的内存语义"><a href="#volatile-写-读的内存语义" class="headerlink" title="volatile 写 - 读的内存语义"></a>volatile 写 - 读的内存语义</h2><p>volatile 写的内存语义如下：</p>
<ul>
<li>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存。</li>
</ul>
<p>以上面示例程序  VolatileExample 为例，假设线程 A 首先执行 writer() 方法，随后线程 B 执行 reader()  方法，初始时两个线程的本地内存中的 flag 和 a 都是初始状态。下图是线程 A 执行 volatile 写后，共享变量的状态示意图：</p>
<p><img src="/img/multithreading01/43e1cc4e89fdfd06eaa1c74d54f538ea.png" alt="43e1cc4e89fdfd06eaa1c74d54f538ea"></p>
<p>如上图所示，线程 A 在写 flag 变量后，本地内存 A 中被线程 A 更新过的两个共享变量的值被刷新到主内存中。此时，本地内存 A 和主内存中的共享变量的值是一致的。</p>
<p>volatile 读的内存语义如下：</p>
<ul>
<li>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ul>
<p>下面是线程 B 读同一个 volatile 变量后，共享变量的状态示意图：</p>
<p><img src="/img/multithreading01/0804d2efc97e45360eab1f76f9962c32.png" alt="0804d2efc97e45360eab1f76f9962c32"></p>
<p>如上图所示，在读 flag 变量后，本地内存 B 已经被置为无效。此时，线程 B 必须从主内存中读取共享变量。线程 B 的读取操作将导致本地内存 B 与主内存中的共享变量的值也变成一致的了。</p>
<p>如果我们把 volatile 写和 volatile 读这两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。</p>
<p><strong>下面对 volatile 写和 volatile 读的内存语义做个总结</strong>：</p>
<ul>
<li>线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所在修改的）消息。</li>
<li>线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个 volatile 变量之前对共享变量所做修改的）消息。</li>
<li>线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li>
</ul>
<h2 id="volatile-内存语义的实现"><a href="#volatile-内存语义的实现" class="headerlink" title="volatile 内存语义的实现"></a>volatile 内存语义的实现</h2><p>下面，让我们来看看 JMM 如何实现 volatile 写 / 读的内存语义。</p>
<p>前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现 volatile 内存语义，JMM 会分别限制这两种类型的重排序类型。下面是 JMM 针对编译器制定的 volatile 重排序规则表：</p>
<table>
<thead>
<tr>
<th>是否能重排序</th>
<th>第二个操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>第一个操作</td>
<td>普通读 / 写</td>
<td>volatile 读</td>
<td>volatile 写</td>
</tr>
<tr>
<td>普通读 / 写</td>
<td></td>
<td></td>
<td>NO</td>
</tr>
<tr>
<td>volatile 读</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>volatile 写</td>
<td></td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<p>举例来说，第三行最后一个单元格的意思是：在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为 volatile 写，则编译器不能重排序这两个操作。</p>
<p>从上表我们可以看出：</p>
<ul>
<li>当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。</li>
<li>当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile 读之后的操作不会被编译器重排序到 volatile 读之前。</li>
<li>当第一个操作是 volatile 写，第二个操作是 volatile 读时，不能重排序。</li>
</ul>
<p>为了实现  volatile  的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM  采取保守策略。下面是基于保守策略的 JMM 内存屏障插入策略：</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的 volatile 内存语义。</p>
<p>下面是保守策略下，volatile 写插入内存屏障后生成的指令序列示意图：</p>
<p><img src="/img/multithreading01/0c0aa1f3b4de45f761412807eac3ce2a.png" alt=""></p>
<p>上图中的 StoreStore 屏障可以保证在 volatile 写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为 StoreStore 屏障将保障上面所有的普通写在 volatile 写之前刷新到主内存。</p>
<p>这里比较有意思的是  volatile 写后面的 StoreLoad 屏障。这个屏障的作用是避免 volatile 写与后面可能有的 volatile 读 /  写操作重排序。因为编译器常常无法准确判断在一个 volatile 写的后面，是否需要插入一个 StoreLoad 屏障（比如，一个  volatile 写之后方法立即 return）。为了保证能正确实现 volatile 的内存语义，JMM 在这里采取了保守策略：在每个  volatile 写的后面或在每个 volatile 读的前面插入一个 StoreLoad 屏障。从整体执行效率的角度考虑，JMM 选择了在每个  volatile 写的后面插入一个 StoreLoad 屏障。因为 volatile 写 - 读内存语义的常见使用模式是：一个写线程写  volatile 变量，多个读线程读同一个 volatile 变量。当读线程的数量大大超过写线程时，选择在 volatile 写之后插入  StoreLoad 屏障将带来可观的执行效率的提升。从这里我们可以看到 JMM 在实现上的一个特点：<strong>首先确保正确性，然后再去追求执行效率</strong>。</p>
<p>下面是在保守策略下，volatile 读插入内存屏障后生成的指令序列示意图：</p>
<p><img src="/img/multithreading01/ab111a523fb0c0a12b894442e04719e6.png" alt="ab111a523fb0c0a12b894442e04719e6"></p>
<p>上图中的 LoadLoad 屏障用来禁止处理器把上面的 volatile 读与下面的普通读重排序。LoadStore 屏障用来禁止处理器把上面的 volatile 读与下面的普通写重排序。</p>
<p>上述 volatile 写和 volatile 读的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写 - 读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class VolatileBarrierExample &#123;</span><br><span class="line">    int a;</span><br><span class="line">    volatile int v1 &#x3D; 1;</span><br><span class="line">    volatile int v2 &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    void readAndWrite() &#123;</span><br><span class="line">        int i &#x3D; v1;           &#x2F;&#x2F; 第一个 volatile 读 </span><br><span class="line">        int j &#x3D; v2;           &#x2F;&#x2F; 第二个 volatile 读 </span><br><span class="line">        a &#x3D; i + j;            &#x2F;&#x2F; 普通写 </span><br><span class="line">        v1 &#x3D; i + 1;          &#x2F;&#x2F; 第一个 volatile 写 </span><br><span class="line">        v2 &#x3D; j * 2;          &#x2F;&#x2F; 第二个 volatile 写 </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …                    &#x2F;&#x2F; 其他方法 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对 readAndWrite() 方法，编译器在生成字节码时可以做如下的优化：</p>
<p><img src="/img/multithreading01/a066fb2bf821764981efb9ffaed26a00.png" alt="a066fb2bf821764981efb9ffaed26a00"></p>
<p><strong>注意，最后的 StoreLoad 屏障不能省略。因为第二个 volatile 写之后，方法立即 return。此时编译器可能无法准确断定后面是否会有 volatile 读或写，为了安全起见，编译器常常会在这里插入一个 StoreLoad 屏障。</strong></p>
<p>上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以 x86 处理器为例，上图中除最后的 StoreLoad 屏障外，其它的屏障都会被省略。</p>
<p>前面保守策略下的 volatile 读和写，在 x86 处理器平台可以优化成：</p>
<p><img src="/img/multithreading01/ad8f4acfd53faae8bec46d2e6e3f6e3d.png" alt="ad8f4acfd53faae8bec46d2e6e3f6e3d"></p>
<p>前文提到过，x86 处理器仅会对写 - 读操作做重排序。X86 不会对<strong>读 - 读</strong>，<strong>读 - 写</strong>和<strong>写 - 写</strong>操作做重排序，因此在  x86 处理器中会省略掉这三种操作类型对应的内存屏障。在 x86 中，JMM 仅需在 volatile 写后面插入一个 StoreLoad  屏障即可正确实现 volatile 写 - 读的内存语义。这意味着在 x86 处理器中，volatile 写的开销比 volatile  读的开销会大很多（因为执行 StoreLoad 屏障开销会比较大）。</p>
<h2 id="JSR-133-为什么要增强-volatile-的内存语义"><a href="#JSR-133-为什么要增强-volatile-的内存语义" class="headerlink" title="JSR-133 为什么要增强 volatile 的内存语义"></a>JSR-133 为什么要增强 volatile 的内存语义</h2><p>在  JSR-133 之前的旧 Java 内存模型中，虽然不允许 volatile 变量之间重排序，但旧的 Java 内存模型允许 volatile  变量与普通变量之间重排序。在旧的内存模型中，VolatileExample 示例程序可能被重排序成下列时序来执行：</p>
<p><img src="/img/multithreading01/abf61fa3967e82c09a74787e63e68349.png" alt="abf61fa3967e82c09a74787e63e68349"></p>
<p>在旧的内存模型中，当 1 和 2 之间没有数据依赖关系时，1 和 2 之间就可能被重排序（3 和 4 类似）。其结果就是：读线程 B 执行 4 时，不一定能看到写线程 A 在执行 1 时对共享变量的修改。</p>
<p>因此在旧的内存模型中  ，volatile 的写 - 读没有监视器的释放 - 获所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133  专家组决定增强 volatile 的内存语义：严格限制编译器和处理器对 volatile 变量与普通变量的重排序，确保 volatile 的写 -  读和监视器的释放 - 获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要 volatile  变量与普通变量之间的重排序可能会破坏 volatile 的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<p>由于 volatile 仅仅保证对单个 volatile 变量的读 / 写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。<strong>在功能上，监视器锁比 volatile 更强大；在可伸缩性和执行性能上，volatile 更有优势</strong>。如果读者想在程序中用 volatile 代替监视器锁，请一定谨慎。</p>
<p>本文转载自《Java并发编程的艺术》作者之一程晓明的博客：<a href="https://www.infoq.cn/article/java-memory-model-4" target="_blank" rel="noopener">深入理解 Java 内存模型（四）— volatile</a></p>
]]></content>
      <categories>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java内存模型（五）：锁</title>
    <url>/2020/04/15/javaMemoryModel05/</url>
    <content><![CDATA[<h2 id="锁的释放-获取建立的-happens-before-关系"><a href="#锁的释放-获取建立的-happens-before-关系" class="headerlink" title="锁的释放 - 获取建立的 happens before 关系"></a>锁的释放 - 获取建立的 happens before 关系</h2><p>锁是 java 并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<p>下面是锁释放 - 获取的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MonitorExample &#123;</span><br><span class="line">    int a &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void writer() &#123;  &#x2F;&#x2F;1</span><br><span class="line">        a++;                             &#x2F;&#x2F;2</span><br><span class="line">    &#125;                                    &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">    public synchronized void reader() &#123;  &#x2F;&#x2F;4</span><br><span class="line">        int i &#x3D; a;                       &#x2F;&#x2F;5</span><br><span class="line">        ……</span><br><span class="line">    &#125;                                    &#x2F;&#x2F;6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>假设线程 A 执行 writer() 方法，随后线程 B 执行 reader() 方法。根据 happens before 规则，这个过程包含的 happens before 关系可以分为两类：</p>
<ol>
<li>根据程序次序规则，1 happens before 2, 2 happens before 3; 4 happens before 5, 5 happens before 6。</li>
<li>根据监视器锁规则，3 happens before 4。</li>
<li>根据 happens before 的传递性，2 happens before 5。</li>
</ol>
<p>上述 happens before 关系的图形化表现形式如下：</p>
<p><img src="/img/multithreading01/5f6598d1fd44c0e80756f211c4cab615.png" alt="5f6598d1fd44c0e80756f211c4cab615"></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。</p>
<p>上图表示在线程 A 释放了锁之后，随后线程 B 获取同一个锁。在上图中，2 happens before 5。因此，线程 A 在释放锁之前所有可见的共享变量，在线程 B 获取同一个锁之后，将立刻变得对 B 线程可见。</p>
<h2 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h2><p><strong>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中</strong>。以上面的 MonitorExample 程序为例，A 线程释放锁后，共享数据的状态示意图如下：</p>
<p><img src="/img/multithreading01/ff0d23ee03dfb722f2a8cef49cdc9a4f.png" alt="ff0d23ee03dfb722f2a8cef49cdc9a4f"></p>
<p><strong>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量</strong>。下面是锁获取的状态示意图：</p>
<p><img src="/img/multithreading01/e00c1363695f40176d2101cd53b5e2da.png" alt="e00c1363695f40176d2101cd53b5e2da"></p>
<p>对比锁释放 - 获取的内存语义与 volatile 写 - 读的内存语义，可以看出：<strong>锁释放与 volatile 写有相同的内存语义；锁获取与 volatile 读有相同的内存语义。</strong></p>
<p>下面对锁释放和锁获取的内存语义做个总结：</p>
<ul>
<li>线程 A 释放一个锁，实质上是线程 A 向接下来将要获取这个锁的某个线程发出了（线程 A 对共享变量所做修改的）消息。</li>
<li>线程 B 获取一个锁，实质上是线程 B 接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li>
<li>线程 A 释放锁，随后线程 B 获取这个锁，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li>
</ul>
<h2 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h2><p>本文将借助 <code>ReentrantLock</code> 的源代码，来分析锁内存语义的具体实现机制。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ReentrantLockExample &#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">public void writer() &#123;</span><br><span class="line">    lock.lock();         &#x2F;&#x2F; 获取锁 </span><br><span class="line">    try &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();  &#x2F;&#x2F; 释放锁 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reader () &#123;</span><br><span class="line">    lock.lock();        &#x2F;&#x2F; 获取锁 </span><br><span class="line">    try &#123;</span><br><span class="line">        int i &#x3D; a;</span><br><span class="line">        ……</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();  &#x2F;&#x2F; 释放锁 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ReentrantLock 中，调用 lock() 方法获取锁；调用 unlock() 方法释放锁。</p>
<p>ReentrantLock 的实现依赖于 java 同步器框架 <code>AbstractQueuedSynchronizer</code>（本文简称之为  AQS）。AQS 使用一个整型的 volatile 变量（命名为 state）来维护同步状态，马上我们会看到，这个 volatile 变量是  ReentrantLock 内存语义实现的关键。 下面是 ReentrantLock 的类图（仅画出与本文相关的部分）：</p>
<p><img src="/img/multithreading01/74d654027846dc2a84f09703b2ba0ab0.png" alt="74d654027846dc2a84f09703b2ba0ab0"></p>
<p>ReentrantLock 分为公平锁和非公平锁，我们首先分析公平锁。</p>
<p>使用公平锁时，加锁方法 lock() 的方法调用轨迹如下：</p>
<ol>
<li>ReentrantLock : lock()</li>
<li>FairSync : lock()</li>
<li>AbstractQueuedSynchronizer : acquire(int arg)</li>
<li>ReentrantLock : tryAcquire(int acquires)</li>
</ol>
<p>在第 4 步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();   &#x2F;&#x2F; 获取锁的开始，首先读 volatile 变量 state</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (isFirst(current) &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0)  </span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面源代码中我们可以看出，加锁方法首先读 volatile 变量 state。</p>
<p>在使用公平锁时，解锁方法 unlock() 的方法调用轨迹如下：</p>
<ol>
<li><code>ReentrantLock</code> : unlock()</li>
<li><code>AbstractQueuedSynchronizer</code> : release(int arg)</li>
<li><code>Sync</code> : tryRelease(int releases)</li>
</ol>
<p>在第 3 步真正开始释放锁，下面是该方法的源代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);           &#x2F;&#x2F; 释放锁的最后，写 volatile 变量 state</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源代码我们可以看出，在释放锁的最后写 volatile 变量 state。</p>
<p>公平锁在释放锁的最后写 volatile  变量 state；在获取锁时首先读这个 volatile 变量。根据 volatile 的 happens-before 规则，释放锁的线程在写  volatile 变量之前可见的共享变量，在获取锁的线程读取同一个 volatile 变量后将立即变的对获取锁的线程可见。</p>
<p>现在我们分析非公平锁的内存语义的实现。</p>
<p>非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。</p>
<p>使用公平锁时，加锁方法 lock() 的方法调用轨迹如下：</p>
<ol>
<li><code>ReentrantLock</code> : lock()</li>
<li><code>NonfairSync</code> : lock()</li>
<li><code>AbstractQueuedSynchronizer</code> : compareAndSetState(int expect, int update)</li>
</ol>
<p>在第 3 步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法以原子操作的方式更新 state 变量，本文把 java 的 compareAndSet() 方法调用简称为 CAS。JDK  文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有 volatile 读和写的内存语义。</p>
<p>这里我们分别从编译器和处理器的角度来分析,CAS 如何同时具有 volatile 读和 volatile 写的内存语义。</p>
<p>前文我们提到过，编译器不会对  volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile  写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现 volatile 读和 volatile 写的内存语义，编译器不能对 CAS 与  CAS 前面和后面的任意内存操作重排序。</p>
<p>下面我们来分析在常见的 intel x86 处理器中，CAS 是如何同时具有 volatile 读和 volatile 写的内存语义的。</p>
<p>下面是 sun.misc.Unsafe 类的 compareAndSwapInt() 方法的源代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                              int expected,</span><br><span class="line">                                              int x);</span><br></pre></td></tr></table></figure>

<p>可以看到这是个本地方法调用。这个本地方法在 openjdk 中依次调用的 c++ 代码为：unsafe.cpp，atomic.cpp 和 atomic<em>windows</em>x86.inline.hpp。这个本地方法的最终实现在 openjdk 的如下位置：openjdk-7-fcs-src-b147-27<em>jun</em>2011\openjdk\hotspot\src\os<em>cpu\windows</em>x86\vm\ atomic<em>windows</em>x86.inline.hpp（对应于 windows 操作系统，X86 处理器）。下面是对应于 intel x86 处理器的源代码的片段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Adding a lock prefix to an instruction on MP machine</span><br><span class="line">&#x2F;&#x2F; VC++ doesn&#39;t like the lock prefix to be on a single line</span><br><span class="line">&#x2F;&#x2F; so we can&#39;t insert a label after the lock prefix.</span><br><span class="line">&#x2F;&#x2F; By emitting a lock prefix, we can define a label after it.</span><br><span class="line">#define LOCK_IF_MP(mp) __asm cmp mp, 0  \</span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit 0xF0 \</span><br><span class="line">                       __asm L0:</span><br><span class="line"></span><br><span class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  &#x2F;&#x2F; alternative for InterlockedCompareExchange</span><br><span class="line">  int mp &#x3D; os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为 cmpxchg 指令添加 lock 前缀。如果程序是在多处理器上运行，就为  cmpxchg 指令加上 lock 前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略 lock  前缀（单处理器自身会维护单处理器内的顺序一致性，不需要 lock 前缀提供的内存屏障效果）。</p>
<p>intel 的手册对 lock 前缀的说明如下：</p>
<ol>
<li>确保对内存的读  - 改 - 写操作原子执行。在 Pentium 及 Pentium 之前的处理器中，带有 lock  前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从 Pentium 4，Intel Xeon  及 P6 处理器开始，intel 在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在 lock   前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache  line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读 /  写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低 lock  前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
<li>禁止该指令与之前和之后的读和写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ol>
<p>上面的第 2 点和第 3 点所具有的内存屏障效果，足以同时实现 volatile 读和 volatile 写的内存语义。</p>
<p>经过上面的这些分析，现在我们终于能明白为什么 JDK 文档说 CAS 同时具有 volatile 读和 volatile 写的内存语义了。</p>
<p>现在对公平锁和非公平锁的内存语义做个总结：</p>
<ul>
<li>公平锁和非公平锁释放时，最后都要写一个 volatile 变量 state。</li>
<li>公平锁获取时，首先会去读这个 volatile 变量。</li>
<li>非公平锁获取时，首先会用 CAS 更新这个 volatile 变量, 这个操作同时具有 volatile 读和 volatile 写的内存语义。</li>
</ul>
<p>从本文对 ReentrantLock 的分析可以看出，锁释放 - 获取的内存语义的实现至少有下面两种方式：</p>
<ol>
<li>利用 volatile 变量的写 - 读所具有的内存语义。</li>
<li>利用 CAS 所附带的 volatile 读和 volatile 写的内存语义。</li>
</ol>
<h2 id="concurrent-包的实现"><a href="#concurrent-包的实现" class="headerlink" title="concurrent 包的实现"></a>concurrent 包的实现</h2><p>由于 java 的 CAS 同时具有 volatile 读和 volatile 写的内存语义，因此 Java 线程之间的通信现在有了下面四种方式：</p>
<ol>
<li>A 线程写 volatile 变量，随后 B 线程读这个 volatile 变量。</li>
<li>A 线程写 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。</li>
<li>A 线程用 CAS 更新一个 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。</li>
<li>A 线程用 CAS 更新一个 volatile 变量，随后 B 线程读这个 volatile 变量。</li>
</ol>
<p>Java  的 CAS 会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读 - 改 -  写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读 - 改 -  写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读 - 改 -  写操作的原子指令）。同时，volatile 变量的读 / 写和 CAS 可以实现线程之间的通信。把这些特性整合在一起，就形成了整个  concurrent 包得以实现的基石。如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：</p>
<ol>
<li>首先，声明共享变量为 volatile；</li>
<li>然后，使用 CAS 的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以 volatile 的读 / 写和 CAS 所具有的 volatile 读和写的内存语义来实现线程之间的通信。</li>
</ol>
<p>AQS，非阻塞数据结构和原子变量类（<code>java.util.concurrent.atomic</code> 包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而 concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：</p>
<p><img src="/img/multithreading01/5e64407107744a74e47c7ae3b4b8ce13.png" alt="5e64407107744a74e47c7ae3b4b8ce13"></p>
<p>本文转载自《Java并发编程的艺术》作者之一程晓明的个人博客<a href="https://www.infoq.cn/article/java-memory-model-5" target="_blank" rel="noopener">深入理解 Java 内存模型（五）—锁</a></p>
]]></content>
      <categories>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java内存模型（六）：final</title>
    <url>/2020/04/15/javaMemoryModel06/</url>
    <content><![CDATA[<p>与前面介绍的锁和 volatile 相比较，对 final 域的读和写更像是普通的变量访问。对于 final 域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li>
</ol>
<p>下面，我们通过一些示例性的代码来分别说明这两个规则：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FinalExample &#123;</span><br><span class="line">    int i;                            &#x2F;&#x2F; 普通变量 </span><br><span class="line">    final int j;                      &#x2F;&#x2F;final 变量 </span><br><span class="line">    static FinalExample obj;</span><br><span class="line"></span><br><span class="line">    public void FinalExample () &#123;     &#x2F;&#x2F; 构造函数 </span><br><span class="line">        i &#x3D; 1;                        &#x2F;&#x2F; 写普通域 </span><br><span class="line">        j &#x3D; 2;                        &#x2F;&#x2F; 写 final 域 </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void writer () &#123;    &#x2F;&#x2F; 写线程 A 执行 </span><br><span class="line">        obj &#x3D; new FinalExample ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void reader () &#123;       &#x2F;&#x2F; 读线程 B 执行 </span><br><span class="line">        FinalExample object &#x3D; obj;       &#x2F;&#x2F; 读对象引用 </span><br><span class="line">        int a &#x3D; object.i;                &#x2F;&#x2F; 读普通域 </span><br><span class="line">        int b &#x3D; object.j;                &#x2F;&#x2F; 读 final 域 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里假设一个线程 A 执行 writer () 方法，随后另一个线程 B 执行 reader () 方法。下面我们通过这两个线程的交互来说明这两个规则。</p>
<h2 id="写-final-域的重排序规则"><a href="#写-final-域的重排序规则" class="headerlink" title="写 final 域的重排序规则"></a>写 final 域的重排序规则</h2><p><strong>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外</strong>。这个规则的实现包含下面 2 个方面：</p>
<ul>
<li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li>
<li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li>
</ul>
<p>现在让我们分析 writer () 方法。writer () 方法只包含一行代码：<code>finalExample = new FinalExample ()</code>。这行代码包含两个步骤：</p>
<ol>
<li>构造一个 FinalExample 类型的对象；</li>
<li>把这个对象的引用赋值给引用变量 obj。</li>
</ol>
<p>假设线程 B 读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：</p>
<p><img src="/img/multithreading01/6628576a54f0ba625c8c3af4586cef3a.jpg" alt="6628576a54f0ba625c8c3af4586cef3a"></p>
<p>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程 B 错误的读取了普通变量 i 初始化之前的值。而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。</p>
<p><strong>写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。</strong>以上图为例，在读线程 B“看到”对象引用 obj 时，很可能 obj 对象还没有构造完成（对普通域 i 的写操作被重排序到构造函数外，此时初始值 2 还没有写入普通域 i）。</p>
<h2 id="读-final-域的重排序规则"><a href="#读-final-域的重排序规则" class="headerlink" title="读 final 域的重排序规则"></a>读 final 域的重排序规则</h2><p>读 final 域的重排序规则如下：</p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</li>
</ul>
<p>初次读对象引用与初次读该对象包含的  final  域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如  alpha 处理器），这个规则就是专门用来针对这种处理器。</p>
<p>reader() 方法包含三个操作：</p>
<ol>
<li>初次读引用变量 obj;</li>
<li>初次读引用变量 obj 指向对象的普通域 j。</li>
<li>初次读引用变量 obj 指向对象的 final 域 i。</li>
</ol>
<p>现在我们假设写线程 A 没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：</p>
<p><img src="/img/multithreading01/a0a9b023bc56ab97bbda8812cdca7236.png" alt="a0a9b023bc56ab97bbda8812cdca7236"></p>
<p>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程 A 写入，这是一个错误的读取操作。而读  final 域的重排序规则会把读对象 final 域的操作“限定”在读对象引用之后，此时该 final 域已经被 A  线程初始化过了，这是一个正确的读取操作。</p>
<p><strong>读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用</strong>。在这个示例程序中，如果该引用不为 null，那么引用对象的 final 域一定已经被 A 线程初始化过了。</p>
<h2 id="如果-final-域是引用类型"><a href="#如果-final-域是引用类型" class="headerlink" title="如果 final 域是引用类型"></a>如果 final 域是引用类型</h2><p>上面我们看到的 final 域是基础数据类型，下面让我们看看如果 final 域是引用类型，将会有什么效果？</p>
<p>请看下列示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FinalReferenceExample &#123;</span><br><span class="line">final int[] intArray;                     &#x2F;&#x2F;final 是引用类型 </span><br><span class="line">static FinalReferenceExample obj;</span><br><span class="line"></span><br><span class="line">public FinalReferenceExample () &#123;        &#x2F;&#x2F; 构造函数 </span><br><span class="line">    intArray &#x3D; new int[1];              &#x2F;&#x2F;1</span><br><span class="line">    intArray[0] &#x3D; 1;                   &#x2F;&#x2F;2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void writerOne () &#123;          &#x2F;&#x2F; 写线程 A 执行 </span><br><span class="line">    obj &#x3D; new FinalReferenceExample ();  &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void writerTwo () &#123;          &#x2F;&#x2F; 写线程 B 执行 </span><br><span class="line">    obj.intArray[0] &#x3D; 2;                 &#x2F;&#x2F;4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void reader () &#123;              &#x2F;&#x2F; 读线程 C 执行 </span><br><span class="line">    if (obj !&#x3D; null) &#123;                    &#x2F;&#x2F;5</span><br><span class="line">        int temp1 &#x3D; obj.intArray[0];       &#x2F;&#x2F;6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 final 域为一个引用类型，它引用一个 int 型的数组对象。对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p>
<ol>
<li>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ol>
<p>对上面的示例程序，我们假设首先线程 A 执行 writerOne() 方法，执行完后线程 B 执行 writerTwo() 方法，执行完后线程 C 执行 reader () 方法。下面是一种可能的线程执行时序：</p>
<p><img src="/img/multithreading01/29b097c36fd531028991826bb7c835db.png" alt="29b097c36fd531028991826bb7c835db"></p>
<p>在上图中，1 是对 final 域的写入，2 是对这个 final 域引用的对象的成员域的写入，3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。</p>
<p>JMM  可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为  1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B  和读线程 C 之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程 C 看到写线程 B 对数组元素的写入，写线程 B 和读线程 C 之间需要使用同步原语（lock 或 volatile）来确保内存可见性。</p>
<h2 id="为什么-final-引用不能从构造函数内“逸出”"><a href="#为什么-final-引用不能从构造函数内“逸出”" class="headerlink" title="为什么 final 引用不能从构造函数内“逸出”"></a>为什么 final 引用不能从构造函数内“逸出”</h2><p>前面我们提到过，写 final 域的重排序规则可以确保：<strong>在引用变量为任意线程可见之前，该引用变量指向的对象的 final 域已经在构造函数中被正确初始化过了</strong>。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FinalReferenceEscapeExample &#123;</span><br><span class="line">final int i;</span><br><span class="line">static FinalReferenceEscapeExample obj;</span><br><span class="line"></span><br><span class="line">public FinalReferenceEscapeExample () &#123;</span><br><span class="line">    i &#x3D; 1;                              &#x2F;&#x2F;1 写 final 域 </span><br><span class="line">    obj &#x3D; this;                          &#x2F;&#x2F;2 this 引用在此“逸出”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void writer() &#123;</span><br><span class="line">    new FinalReferenceEscapeExample ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void reader &#123;</span><br><span class="line">    if (obj !&#x3D; null) &#123;                     &#x2F;&#x2F;3</span><br><span class="line">        int temp &#x3D; obj.i;                 &#x2F;&#x2F;4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一个线程 A 执行 writer() 方法，另一个线程 B 执行 reader() 方法。这里的操作 2 使得对象还未完成构造前就为线程 B<br>可见。即使这里的操作 2 是构造函数的最后一步，且即使在程序中操作 2 排在操作 1 后面，执行 read() 方法的线程仍然可能无法看到<br>final 域被初始化后的值，因为这里的操作 1 和操作 2 之间可能被重排序。实际的执行时序可能如下图所示：</p>
<p><img src="/img/multithreading01/89e0666e4c3348a4cede04bd25a6f64e.png" alt="89e0666e4c3348a4cede04bd25a6f64e"></p>
<p>从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的 final 域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到 final 域正确初始化之后的值。</p>
<h2 id="final-语义在处理器中的实现"><a href="#final-语义在处理器中的实现" class="headerlink" title="final 语义在处理器中的实现"></a>final 语义在处理器中的实现</h2><p>现在我们以 x86 处理器为例，说明 final 语义在处理器中的具体实现。</p>
<p>上面我们提到，<strong>写 final 域的重排序规则会要求译编器在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 障屏。读 final 域的重排序规则要求编译器在读 final 域的操作前面插入一个 LoadLoad 屏障</strong>。</p>
<p>由于  x86 处理器不会对写 - 写操作做重排序，所以在 x86 处理器中，写 final 域需要的 StoreStore  障屏会被省略掉。同样，由于 x86 处理器不会对存在间接依赖关系的操作做重排序，所以在 x86 处理器中，读 final 域需要的  LoadLoad 屏障也会被省略掉。也就是说在 x86 处理器中，final 域的读 / 写不会插入任何内存屏障！</p>
<h2 id="JSR-133-为什么要增强-final-的语义"><a href="#JSR-133-为什么要增强-final-的语义" class="headerlink" title="JSR-133 为什么要增强 final 的语义"></a>JSR-133 为什么要增强 final 的语义</h2><p>在旧的  Java 内存模型中 ，最严重的一个缺陷就是线程可能看到 final 域的值会改变。比如，一个线程当前看到一个整形 final 域的值为  0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个 final 域的值时，却发现值变为了  1（被某个线程初始化之后的值）。最常见的例子就是在旧的 Java 内存模型中，String 的值可能会改变（参考文献 2  中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。</p>
<p>为了修补这个漏洞，JSR-133 专家组增强了 final 的语义。通过为 final 域增加写和读重排序规则，可以为 java 程序员提供初始化安全保证：<strong>只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指 lock 和 volatile 的使用），就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</strong></p>
<p>本文转载自《Java并发编程的艺术》作者之一程晓明的个人博客<a href="https://www.infoq.cn/article/java-memory-model-6" target="_blank" rel="noopener">深入理解 Java 内存模型（六）——final</a></p>
]]></content>
      <categories>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java内存模型（七）：总结</title>
    <url>/2020/04/17/javaMemoryModel07/</url>
    <content><![CDATA[<h2 id="处理器内存模型"><a href="#处理器内存模型" class="headerlink" title="处理器内存模型"></a>处理器内存模型</h2><p>顺序一致性内存模型是一个理论参考模型，JMM  和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM  和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和  JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p>
<p>根据对不同类型读 / 写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p>
<ol>
<li>放松程序中写 - 读操作的顺序，由此产生了 total store ordering 内存模型（简称为 TSO）。</li>
<li>在前面 1 的基础上，继续放松程序中写 - 写操作的顺序，由此产生了 partial store order 内存模型（简称为 PSO）。</li>
<li>在前面 1 和 2 的基础上，继续放松程序中读 - 写和读 - 读操作的顺序，由此产生了 relaxed memory order 内存模型（简称为 RMO）和 PowerPC 内存模型。</li>
</ol>
<a id="more"></a>

<p>注意，这里处理器对读 / 写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守 as-if-serial 语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p>
<p>下面的表格展示了常见处理器内存模型的细节特征：</p>
<table>
<thead>
<tr>
<th>内存模型名称</th>
<th>对应的处理器</th>
<th>Store-Load 重排序</th>
<th>Store-Store 重排序</th>
<th>Load-Load 和 Load-Store 重排序</th>
<th>可以更早读取到其它处理器的写</th>
<th>可以更早读取到当前处理器的写</th>
</tr>
</thead>
<tbody><tr>
<td>TSO</td>
<td>sparc-TSOX64</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>PSO</td>
<td>sparc-PSO</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>RMO</td>
<td>ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>PowerPC</td>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<p>在这个表格中，我们可以看到所有处理器内存模型都允许写  - 读重排序，原因在第一章以说明过：它们都使用了写缓存区，写缓存区可能导致写 -  读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</p>
<p>上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p>
<p>由于常见的处理器内存模型比  JMM 要弱，java  编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM  在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了 JMM 在不同处理器内存模型中需要插入的内存屏障的示意图：</p>
<p>![如上图所示，JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 java 程序员呈现了一个一致的内存模型。</p>
<h2 id="JMM，处理器内存模型与顺序一致性内存模型之间的关系"><a href="#JMM，处理器内存模型与顺序一致性内存模型之间的关系" class="headerlink" title="JMM，处理器内存模型与顺序一致性内存模型之间的关系"></a>JMM，处理器内存模型与顺序一致性内存模型之间的关系</h2><p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p>
<p><img src="/img/multithreading01/140b2d3f8adf99f9fcb255f258dbefb1.png" alt="140b2d3f8adf99f9fcb255f258dbefb1"></p>
<p>从上图我们可以看出：常见的 4 种处理器内存模型比常用的 3 中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</p>
<h2 id="JMM-的设计"><a href="#JMM-的设计" class="headerlink" title="JMM 的设计"></a>JMM 的设计</h2><p>从 JMM 设计者的角度来说，在设计 JMM 时，需要考虑两个关键因素：</p>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li>
</ul>
<p>由于这两个因素互相矛盾，所以 JSR-133 专家组在设计 JMM 时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。下面让我们看看 JSR-133 是如何实现这一目标的。</p>
<p>为了具体说明，请看前面提到过的计算圆面积的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double pi  &#x3D; 3.14;    &#x2F;&#x2F;A</span><br><span class="line">double r   &#x3D; 1.0;     &#x2F;&#x2F;B</span><br><span class="line">double area &#x3D; pi * r * r; &#x2F;&#x2F;C</span><br></pre></td></tr></table></figure>

<p>上面计算圆的面积的示例代码存在三个 happens- before 关系：</p>
<ol>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ol>
<p>由于  A happens- before B，happens- before 的定义会要求：A 操作执行的结果要对 B 可见，且 A  操作的执行顺序排在 B 操作之前。 但是从程序语义的角度来说，对 A 和 B  做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这 3 个  happens- before 关系中，虽然 2 和 3 是必需要的，但 1 是不必要的。因此，JMM 把 happens- before  要求禁止的重排序分为了下面两类：</p>
<ul>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ul>
<p>JMM 对这两种不同性质的重排序，采取了不同的策略：</p>
<ul>
<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。</li>
</ul>
<p>下面是 JMM 的设计示意图：</p>
<p><img src="/img/multithreading01/f5e54ed72c8e332a39c58c025c6a16e5.png" alt="f5e54ed72c8e332a39c58c025c6a16e5"></p>
<p>从上图可以看出两点：</p>
<ul>
<li>JMM 向程序员提供的 happens- before 规则能满足程序员的需求。JMM 的  happens- before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的  A happens- before B）。</li>
<li>JMM 对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM  其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个  volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile  变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
<h2 id="JMM-的内存可见性保证"><a href="#JMM-的内存可见性保证" class="headerlink" title="JMM 的内存可见性保证"></a>JMM 的内存可见性保证</h2><p>Java 程序的内存可见性保证按程序类型可以分为下列三类：</p>
<ol>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步 / 未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</li>
</ol>
<p>下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：</p>
<p><img src="/img/multithreading01/fc8fe8fd89809158e2653f6f7defd963.png" alt="fc8fe8fd89809158e2653f6f7defd963"></p>
<p>只要多线程程序是正确同步的，JMM 保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h2 id="JSR-133-对旧内存模型的修补"><a href="#JSR-133-对旧内存模型的修补" class="headerlink" title="JSR-133 对旧内存模型的修补"></a>JSR-133 对旧内存模型的修补</h2><p>JSR-133 对 JDK5 之前的旧内存模型的修补主要有两个：</p>
<ul>
<li>增强 volatile 的内存语义。旧内存模型允许 volatile 变量与普通变量重排序。JSR-133 严格限制 volatile 变量与普通变量的重排序，使 volatile 的写 - 读和锁的释放 - 获取具有相同的内存语义。</li>
<li>增强 final 的内存语义。在旧内存模型中，多次读取同一个 final 变量的值可能会不相同。为此，JSR-133 为 final 增加了两个重排序规则。现在，final 具有了初始化安全性。</li>
</ul>
<p>本文转载自《Java并发编程的艺术》作者之一程晓明的个人博客<a href="https://www.infoq.cn/article/java-memory-model-7" target="_blank" rel="noopener">深入理解 Java 内存模型（七）—总结</a></p>
]]></content>
      <categories>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <url>/2020/04/15/concurrentHashMap/</url>
    <content><![CDATA[<h3 id="为什么要使用-ConcurrentHashMap"><a href="#为什么要使用-ConcurrentHashMap" class="headerlink" title="为什么要使用 ConcurrentHashMap"></a>为什么要使用 ConcurrentHashMap</h3><p>ConcurrentHashMap 是线程安全且高效的 HashMap。使用 ConcurrentHashMap 的主要原因是 HashMap 是非线程安全的（HashMap 线程不安全的原因可以参考<a href="https://bestzuo.cn/hashmap-thread-unsafe.html" target="_blank" rel="noopener">这里</a>），如果要在多线程环境下使用 Map 结构，可以有以下方式：</p>
<ol>
<li>使用 Collections.synchronizedMap(Mao&lt;K,V&gt; m) 方法把 HashMap 变成一个线程安全的 Map</li>
<li>使用 HashTable</li>
<li>使用 ConcurrentHashMap</li>
</ol>
<p>为什么不用  HashTable 呢，这是因为 HashTable 的效率非常低，其内部方法都是使用 Synchronized  来保证线程安全，并且若线程竞争激烈时，HashTable 的效率会变得更加低，因为当一个线程访问 HashTable 的同步方法，其它线程也访问  HashTable 的同步方法，那么会进入阻塞或者轮询状态。比如线程 1 使用 put 方法进行元素添加，线程 2 不但不能使用 put  方法添加元素，还不能使用 get 方法查询元素。所以多线程环境下往往不会使用 HashTable。</p>
<a id="more"></a>

<p>为了解决上述问题，Java 官方提供了 ConcurrentHashMap 类来实现并发访问性能较高的 HashMap。其优点如下：</p>
<ul>
<li>线程安全</li>
<li>相比于 HashTable 和 Collections.synchronizedMap() 效率高</li>
</ul>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>ConcurrentHashMap  在 JDK 1.7 和 JDK 1.8 的结构是不相同的，这里我们先解析 JDK 1.7 下的  ConcurrentHashMap，在这个基础上再分析 JDK 1.8 下 ConcurrentHashMap 的实现并比较与 1.7  做出了什么优化。</p>
<h4 id="JDK1-7下的ConcurrentHashMap"><a href="#JDK1-7下的ConcurrentHashMap" class="headerlink" title="JDK1.7下的ConcurrentHashMap"></a>JDK1.7下的ConcurrentHashMap</h4><p>在  JDK 1.7 中，ConcurrentHashMap 的结构是分段锁（segment） + HashEntry  数组。ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap  采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是  Segment 的个数）。</p>
<p><img src="/img/concurrentHashMap/jdk1.7-concurrenthashmap.png" alt="jdk1.7-concurrenthashmap"></p>
<p>其中 segment 是一种可重入锁（ReentrantLock），在 ConcurrentHashMap  中扮演锁的角，HashEntry 则用于寸储键值对数据。一个 ConcurrentHashMap 中包含一个 Segment  数组，Segment 的结构和 HashMap 类似，是一种数组和链表的结构，一个 Segment 中包含一个 HashEntry 数组，每个  HashEntry 是一个链表结构的元素。每个 Segment 守护着一个 HashEntry 数组里面的元素，对 HashEntry  数组中元素进行修改时，必须先获取对应的 Segment 锁。</p>
<h4 id="JDK1-8下的ConcurrentHashMap"><a href="#JDK1-8下的ConcurrentHashMap" class="headerlink" title="JDK1.8下的ConcurrentHashMap"></a>JDK1.8下的ConcurrentHashMap</h4><p>JDK  1.8 中 ，ConcurrentHashMap 的结构是数组 + 链表 + 红黑树，不再是分段锁（segment）机制，而是采用了 CAS +  Synchronized 细化了锁粒度，从而提升了并发性能，并且在数组链表长度超过 8  时，会自动将链表转化为红黑树，这样解决了散列不均匀产生链表过长从而使得搜索时间复杂度过大的问题。</p>
<p><img src="/img/concurrentHashMap/jdk1.8-concurrenthashmap.png" alt="jdk1.8-concurrenthashmap"></p>
<p>Synchronized 只锁定当前链表或者红黑树的首节点，这样只要 hash 不冲突，就不会产生并发，从而提升了一定的并发性能。</p>
<h3 id="ConcurrentHashMap的源码分析"><a href="#ConcurrentHashMap的源码分析" class="headerlink" title="ConcurrentHashMap的源码分析"></a>ConcurrentHashMap的源码分析</h3><p>为了更全面的理解 ConcurrentHashMap 的源码和发展历史，这里也分为 JDK 1.7 和 JDK 1.8 中的 ConcurrentHashMap 源码分析。</p>
<h4 id="JDK-1-7-源码"><a href="#JDK-1-7-源码" class="headerlink" title="JDK 1.7 源码"></a>JDK 1.7 源码</h4><p>由上面小节我们初步了解了 ConcurrentHashMap 在 1.7 中的数据结构，其中我们需要关注的点：</p>
<ul>
<li>ConcurrentHashMap 如何定位 Segment, 如何定位 HashEntry</li>
<li>修改的加锁逻辑，如何进行扩容</li>
<li>读数据时，如何做到不加锁但保证线程安全的？</li>
</ul>
<p>ConcurrentHashMap 的默认常量字段有：</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">含义</th>
<th align="center">初始值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DEFAULT_INITIAL_CAPACITY</td>
<td align="center">初始容量</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">DEFAULT_LOAD_FACTOR</td>
<td align="center">初始负载因子</td>
<td align="center">0.75</td>
</tr>
<tr>
<td align="center">DEFAULT_CONCURRENCY_LEVEL</td>
<td align="center">并发度</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">MAX_SEGMENTS</td>
<td align="center">segment最大容量</td>
<td align="center">2^16</td>
</tr>
<tr>
<td align="center">RETRIES_BEFORE_LOCK</td>
<td align="center">重试次数</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>ConcurrentHashMap  的初始化方法也是通过 initialCapacity、loadFactor 和 ConcurrencyLevel 等几个参数初始化  segement 数组、段偏移量 segmentShift、段掩码 segmentMask 和每个 segment 中的 HashEntry  数组来实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">	</span><br><span class="line">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel &#x3D; MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find power-of-two sizes best matching arguments</span><br><span class="line">    int sshift &#x3D; 0;  </span><br><span class="line">    int ssize &#x3D; 1;</span><br><span class="line">    while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    segmentShift &#x3D; 32 - sshift;</span><br><span class="line">    segmentMask &#x3D; ssize - 1;</span><br><span class="line">    this.segments &#x3D; Segment.newArray(ssize);</span><br><span class="line"></span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">    if (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    int cap &#x3D; 1;</span><br><span class="line">    while (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;&#x3D; 1;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; this.segments.length; ++i)</span><br><span class="line">        this.segments[i] &#x3D; new Segment&lt;K,V&gt;(cap, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始化segment数组"><a href="#初始化segment数组" class="headerlink" title="初始化segment数组"></a>初始化segment数组</h5><p>初始化 segment 数组源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;并发度最大只有segmengs数组大小</span><br><span class="line">if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">    concurrencyLevel &#x3D; MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Find power-of-two sizes best matching arguments</span><br><span class="line">&#x2F;&#x2F; 为了保证segemnts数组长度为2的N次方</span><br><span class="line">int sshift &#x3D; 0;  </span><br><span class="line">int ssize &#x3D; 1;  &#x2F;&#x2F;segment数组的长度</span><br><span class="line">while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift &#x3D; 32 - sshift;</span><br><span class="line">segmentMask &#x3D; ssize - 1;</span><br><span class="line">this.segments &#x3D; Segment.newArray(ssize);</span><br></pre></td></tr></table></figure>

<p>由上可知，segments 数组的长度 ssize 是通过 concurrencyLevel 计算得出的。为了能通过按为与的散列算法来定位  segments 数组的索引，必须保证 segments 数组的长度为 2 的 N 次方（power-of-two  size），所以必须计算出一个大于或等于 concurrencyLevel 的最小的 2 的 N 次方来作为 segments 数组的长度。</p>
<p>比如假如concurrencyLevel 等于 14 、15 或者 16，ssize 都会等于 16，即容器里面锁的个数也是 16。</p>
<h5 id="初始化segmentShift和segmentMask"><a href="#初始化segmentShift和segmentMask" class="headerlink" title="初始化segmentShift和segmentMask"></a>初始化segmentShift和segmentMask</h5><p>这两个全局变量需要在定位  segment 时的散列算法中使用，sshift 等于 ssize 从 1 向左移位的次数，在默认情况下 concurrencyLevel  等于 16，1 需要往左移位移动 4 次，所以 sshift 等于 4。segmentShift 用于定位参与散列函数运算的位数， <code>segmentShift = 32 - sshift</code>，所以等于  28，这里之所以用 32 是因为 ConcurrentHashMap 里的 hash() 方法输出的最大数是 32  位的，后面的测试中我们可以看到这点。 segmentMask 是散列运算的掩码，等于 ssize - 1，即最大值是 16，  segmentMask 的最大值为 65535。</p>
<h5 id="初始化每个segment"><a href="#初始化每个segment" class="headerlink" title="初始化每个segment"></a>初始化每个segment</h5><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">if (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line">int cap &#x3D; 1;  &#x2F;&#x2F; c就是segment中HashEntry数组的长度</span><br><span class="line">while (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;&#x3D; 1;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; this.segments.length; ++i)</span><br><span class="line">    this.segments[i] &#x3D; new Segment&lt;K,V&gt;(cap, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 cap 就是每个 segment 中 HashEntry 数组的长度，它等于 initialCapacity 除以  ssize 的倍数 c，如果 c 大于 1，就会取大于等于 c 的 2 的 N 次方值，所以 cap 不是 1，就是 2 的 N 次方。  segment 的容量 <code>threshold = (int) cap * loadFactor</code>，默认情况下 initialCapacity 等于 16，loadFactor 等于 0.75，通过运算 cap 等于 1，threshold 等于零。</p>
<h5 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h5><p>在插入和获取元素的时候，必须先通过散列（hash）算法定位到对应的  Segment。翻源码可以看到，ConcurrentHashMap 中的 hash 算法是单独写的方法，使用的是 Wang/Jenkins  hash 的变种算法对元素的 hashCode 进行一次再散列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int hash(int h) &#123;</span><br><span class="line">    &#x2F;&#x2F; Spread bits to regularize both segment and index locations,</span><br><span class="line">    &#x2F;&#x2F; using variant of single-word Wang&#x2F;Jenkins hash.</span><br><span class="line">    h +&#x3D; (h &lt;&lt;  15) ^ 0xffffcd7d;</span><br><span class="line">    h ^&#x3D; (h &gt;&gt;&gt; 10);</span><br><span class="line">    h +&#x3D; (h &lt;&lt;   3);</span><br><span class="line">    h ^&#x3D; (h &gt;&gt;&gt;  6);</span><br><span class="line">    h +&#x3D; (h &lt;&lt;   2) + (h &lt;&lt; 14);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以进行再散列，目的是减少散列冲突，使元素能均匀的分布在不同的 Segment 上，从而提高容器的存储效率。假如散列的质量差到极点，所有的元素都在一个 Segment 中，不仅存取元素缓慢，分段锁也会失去意义。</p>
<p>ConcurrentHashMap 通过以下散列算法定位 segment：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Segment&lt;K,V&gt; segmentFor(int hash) &#123;</span><br><span class="line">    return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认情况下，segmentShift 的值为 28，segmentMask 的值为15，再散列后的数的最大是 32 位二进制数据，向右无符号移动 28 位，意思是让高 4 位参与到散列运算中。</p>
<h5 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h5><p>先看源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    int hash &#x3D; hash(key.hashCode());</span><br><span class="line">    return segmentFor(hash).get(key, hash); &#x2F;&#x2F;源码如下</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Segment类中的get方法</span><br><span class="line">V get(Object key, int hash) &#123;</span><br><span class="line">    if (count !&#x3D; 0) &#123; &#x2F;&#x2F; read-volatile</span><br><span class="line">        HashEntry&lt;K,V&gt; e &#x3D; getFirst(hash); &#x2F;&#x2F;源码如下</span><br><span class="line">        while (e !&#x3D; null) &#123;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">                V v &#x3D; e.value;</span><br><span class="line">                if (v !&#x3D; null)</span><br><span class="line">                    return v;</span><br><span class="line">                return readValueUnderLock(e); &#x2F;&#x2F; recheck</span><br><span class="line">            &#125;</span><br><span class="line">            e &#x3D; e.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 get 操作比较简单和高效，先经过一次再 hash，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定位到具体的HashEntry</span><br><span class="line">HashEntry&lt;K,V&gt; getFirst(int hash) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">    return tab[hash &amp; (tab.length - 1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个操作高效的原因是整个 get 操作没有加锁，除非读到的值为空时才会加锁重读。而原理就是使用 volatile 修饰 get 方法中需要用到的共享变量，比如 count 字段和 存储值的 HashEntry 的 value。volatile修饰的变量可以保证可见性，能被多线程同时读并且不会读到过期的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient volatile int count;</span><br><span class="line">volatile V value;</span><br></pre></td></tr></table></figure>

<p>在定位元素的代码中可以发现，定位 HashEntry 和 Segment 的散列算法虽然一样，都是与数组的长度减 1  再相与，但是相与的值不一样。定位 segment 使用的是元素的 hashCode 经过再散列后得到的值的高位，而定位 HashEntry  直接使用的是再散列后的值。这么做的目的是避免两次散列后的值一样，虽然元素在 Segment 里面散开了，但是却没有在 HashEntry  中散开。</p>
<h5 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h5><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (value &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; hash(key.hashCode());</span><br><span class="line">    return segmentFor(hash).put(key, hash, value, false);  &#x2F;&#x2F;源码如下</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        int c &#x3D; count;</span><br><span class="line">        if (c++ &gt; threshold) &#x2F;&#x2F; ensure capacity</span><br><span class="line">            rehash();  &#x2F;&#x2F;大于阈值，需要进行rehash扩容</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        int index &#x3D; hash &amp; (tab.length - 1);  &#x2F;&#x2F;定位HashEntry位置</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; tab[index];</span><br><span class="line">        HashEntry&lt;K,V&gt; e &#x3D; first;</span><br><span class="line">        while (e !&#x3D; null &amp;&amp; (e.hash !&#x3D; hash || !key.equals(e.key)))</span><br><span class="line">            e &#x3D; e.next;</span><br><span class="line"></span><br><span class="line">        V oldValue;</span><br><span class="line">        &#x2F;&#x2F;如果对应的key已经有值，覆盖</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;写入新值</span><br><span class="line">        else &#123;</span><br><span class="line">            oldValue &#x3D; null;</span><br><span class="line">            ++modCount;</span><br><span class="line">            tab[index] &#x3D; new HashEntry&lt;K,V&gt;(key, hash, first, value);</span><br><span class="line">            count &#x3D; c; &#x2F;&#x2F; write-volatile</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 操作为了线程安全性，首先需要定位到对应的 Segment，并在操作共享变量过程中加锁。插入操作主要有两个步骤：</p>
<ol>
<li>判断 Segment 中的 HashEntry 数组是否需要扩容</li>
<li>定位添加元素的位置，然后将其放到 HashEntry 数组中</li>
</ol>
<p>值得一提的是，Segment 的扩容判断比 HashMap 的扩容判断更加合理，因为 HashMap 是在插入元素后判断元素是否已经达到容量的，如果达到了就进行扩容，但是有可能扩容后并没有新元素进行添加，那么这时候就相当于扩容无效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void rehash() &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">    if (oldCapacity &gt;&#x3D; MAXIMUM_CAPACITY)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">             * Reclassify nodes in each list to new Map.  Because we are</span><br><span class="line">             * using power-of-two expansion, the elements from each bin</span><br><span class="line">             * must either stay at same index, or move with a power of two</span><br><span class="line">             * offset. We eliminate unnecessary node creation by catching</span><br><span class="line">             * cases where old nodes can be reused because their next</span><br><span class="line">             * fields won&#39;t change. Statistically, at the default</span><br><span class="line">             * threshold, only about one-sixth of them need cloning when</span><br><span class="line">             * a table doubles. The nodes they replace will be garbage</span><br><span class="line">             * collectable as soon as they are no longer referenced by any</span><br><span class="line">             * reader thread that may be in the midst of traversing table</span><br><span class="line">             * right now.</span><br><span class="line">             *&#x2F;</span><br><span class="line"></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable &#x3D; HashEntry.newArray(oldCapacity&lt;&lt;1);</span><br><span class="line">    threshold &#x3D; (int)(newTable.length * loadFactor);</span><br><span class="line">    int sizeMask &#x3D; newTable.length - 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; We need to guarantee that any existing reads of old Map can</span><br><span class="line">        &#x2F;&#x2F;  proceed. So we cannot yet null out each bin.</span><br><span class="line">        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];</span><br><span class="line"></span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            int idx &#x3D; e.hash &amp; sizeMask;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;  Single node on list</span><br><span class="line">            if (next &#x3D;&#x3D; null)</span><br><span class="line">                newTable[idx] &#x3D; e;</span><br><span class="line"></span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; Reuse trailing consecutive sequence at same slot</span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun &#x3D; e;</span><br><span class="line">                int lastIdx &#x3D; idx;</span><br><span class="line">                for (HashEntry&lt;K,V&gt; last &#x3D; next;</span><br><span class="line">                     last !&#x3D; null;</span><br><span class="line">                     last &#x3D; last.next) &#123;</span><br><span class="line">                    int k &#x3D; last.hash &amp; sizeMask;</span><br><span class="line">                    if (k !&#x3D; lastIdx) &#123;</span><br><span class="line">                        lastIdx &#x3D; k;</span><br><span class="line">                        lastRun &#x3D; last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] &#x3D; lastRun;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Clone all remaining nodes</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class="line">                    int k &#x3D; p.hash &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];</span><br><span class="line">                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(p.key, p.hash,</span><br><span class="line">                                                     n, p.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h5><p>ConcurrentHashMap 统计容量很有意思，统计整个  ConcurrentHashMap 中元素的数量，就必须统计所有 Segment 里元素的大小后求和。Segment 中的全局变量 count  是一个 volatile 变量，那么在多线程环境下，是不是直接把所有 Segment 里的 count 相加就可以得到整个  ConcurrentHashMap 大小了呢？</p>
<p>在多线程环境下显然不是的，虽然相加时可以获取每个 Segment 的 count  最新值，但是可能累加前使用的 count 发生了变化，那么统计结果就不准了，所以，最安全的方法是在统计 size 的时候把所有的 Segment  的 put 、remove 和 clean 方法都锁住，但是这样做显然效率非常低下。</p>
<p>我们看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;[] segments &#x3D; this.segments;</span><br><span class="line">    long sum &#x3D; 0;</span><br><span class="line">    long check &#x3D; 0;</span><br><span class="line">    int[] mc &#x3D; new int[segments.length];</span><br><span class="line">    &#x2F;&#x2F; Try a few times to get accurate count. On failure due to</span><br><span class="line">    &#x2F;&#x2F; continuous async changes in table, resort to locking.</span><br><span class="line">    for (int k &#x3D; 0; k &lt; RETRIES_BEFORE_LOCK; ++k) &#123;</span><br><span class="line">        check &#x3D; 0;</span><br><span class="line">        sum &#x3D; 0;</span><br><span class="line">        int mcsum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; segments.length; ++i) &#123;</span><br><span class="line">            sum +&#x3D; segments[i].count;</span><br><span class="line">            mcsum +&#x3D; mc[i] &#x3D; segments[i].modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mcsum !&#x3D; 0) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; segments.length; ++i) &#123;</span><br><span class="line">                check +&#x3D; segments[i].count;</span><br><span class="line">                if (mc[i] !&#x3D; segments[i].modCount) &#123;</span><br><span class="line">                    check &#x3D; -1; &#x2F;&#x2F; force retry</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &#x3D;&#x3D; sum)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (check !&#x3D; sum) &#123; &#x2F;&#x2F; Resort to locking all segments</span><br><span class="line">        sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; segments.length; ++i)</span><br><span class="line">            segments[i].lock();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; segments.length; ++i)</span><br><span class="line">            sum +&#x3D; segments[i].count;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; segments.length; ++i)</span><br><span class="line">            segments[i].unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &gt; Integer.MAX_VALUE)</span><br><span class="line">        return Integer.MAX_VALUE;</span><br><span class="line">    else</span><br><span class="line">        return (int)sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的常量<code>RETRIES_BEFORE_LOCK</code>在最上面已经提到过，默认值是  2，表示重试次数。我们可以看到，源码中的做法是先尝试 2 次（初始的重试次数）通过不锁住 Segment 的方式来统计各个 Segment  大小，如果统计过程中，容器的 count 发生了变化，再采用加锁的方式来统计所有 Segment 的大小。而判断统计过程中容器是否发生变化是通过  modCount 这个变量感知的，在 put 、remove 和 clean 方法里操作元素前都会将变量 modCount 值加  1，那么在统计 size 前后比较 modCount 是否发生变化，从而得知容器的大小是否发生变化。</p>
<h4 id="JDK-1-8-源码"><a href="#JDK-1-8-源码" class="headerlink" title="JDK 1.8 源码"></a>JDK 1.8 源码</h4><p>JDK  1.8 数据结构见上，为了优化性能，提升并发度，JDK 1.8 开始去掉了 Segment 分段锁机制，直接采取了与 HashMap  相同的数据结构，不同的是为了保证线程安全，采用了 CAS + Synchronized 进行 put 、remove 等操作。</p>
<p>不同于 JDK 1.7 中的 HashEntry 存储键值对，JDK 1.8 中采用了 Node 这个内部类进行键值对的存储。</p>
<p>先看一下 JDK 1.8 中 ConcurrentHashMap 的字段：</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">含义</th>
<th align="center">初始值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MAXIMUM_CAPACITY</td>
<td align="center">最大容量</td>
<td align="center">2^30</td>
</tr>
<tr>
<td align="center">DEFAULT_CAPACITY</td>
<td align="center">默认容量</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">MAX_ARRAY_SIZE</td>
<td align="center">最大数组容量</td>
<td align="center">Integer.MAX_VALUE - 8</td>
</tr>
<tr>
<td align="center">DEFAULT_CONCURRENCY_LEVEL</td>
<td align="center">默认并发度</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">LOAD_FACTOR</td>
<td align="center">负载因子</td>
<td align="center">0.75f</td>
</tr>
</tbody></table>
<p>当然还有很多字段，这里只挑一些非常重要的。</p>
<p>JDK 1.8 中 ConcurrentHashMap 比较复杂，但是分析时只分析如何利用 CAS + Synchronized 进行高效的同步更新数据。</p>
<h5 id="put-操作-1"><a href="#put-操作-1" class="headerlink" title="put 操作"></a>put 操作</h5><p>先看源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false); &#x2F;&#x2F;源码如下</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    &#x2F;&#x2F;ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    &#x2F;&#x2F;计算key的hash值</span><br><span class="line">    int hash &#x3D; spread(key.hashCode());</span><br><span class="line">    int binCount &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;for循环的作用：因为更新元素是使用CAS机制更新，需要不断的失败重试，直到成功为止。</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">        &#x2F;&#x2F; f：链表或红黑二叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        &#x2F;&#x2F;判断Node[]数组是否初始化，没有则进行初始化操作</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            tab &#x3D; initTable();</span><br><span class="line">        &#x2F;&#x2F;通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;检查到内部正在移动元素（Node[] 数组扩容）</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">            &#x2F;&#x2F;帮助它扩容</span><br><span class="line">            tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F;锁住链表或红黑二叉树的头结点</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                &#x2F;&#x2F;判断f是否是链表的头结点</span><br><span class="line">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果fh&gt;&#x3D;0 是链表节点</span><br><span class="line">                    if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                        binCount &#x3D; 1;</span><br><span class="line">                        &#x2F;&#x2F;遍历链表所有节点</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            &#x2F;&#x2F;如果节点存在，则更新value</span><br><span class="line">                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal &#x3D; e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val &#x3D; value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            &#x2F;&#x2F;不存在则在链表尾部添加新节点。</span><br><span class="line">                            Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;TreeBin是红黑二叉树节点</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount &#x3D; 2;</span><br><span class="line">                        &#x2F;&#x2F;添加树节点</span><br><span class="line">                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) !&#x3D; null) &#123;</span><br><span class="line">                            oldVal &#x3D; p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val &#x3D; value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果链表长度已经达到临界值8 就需要把链表转换为树结构</span><br><span class="line">                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal !&#x3D; null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将当前ConcurrentHashMap的size数量+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，put 操作的逻辑如下：</p>
<ol>
<li><p>判断 Node[] 数组是否初始化，没有则进行初始化操作</p>
</li>
<li><p>通过 hash 定位 Node[] 数组的索引坐标，是否有 Node 节点，如果没有则使用 CAS 进行添加（链表的头结点），添加失败则进入下次循环。</p>
</li>
<li><p>检查到内部正在扩容，如果正在扩容，就帮助它一块扩容。</p>
</li>
<li><p>如果 f != null，则使用 synchronized 锁住 f 元素（链表/红黑二叉树的头元素）</p>
<p>4.1 如果是 Node (链表结构)则执行链表的添加操作。<br>4.2 如果是 TreeNode (树型结果)则执行树添加操作。</p>
</li>
<li><p>判断链表长度已经达到临界值 8 就需要把链表转换为树结构。</p>
<h5 id="get-操作-1"><a href="#get-操作-1" class="headerlink" title="get 操作"></a>get 操作</h5></li>
</ol>
<p>先看源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    int h &#x3D; spread(key.hashCode());</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class="line">        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class="line">            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">        while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是不加锁，但是同 JDK 1.7 相同，Node 节点中的 value 和 next 都是 volatile 的，即线程对这些数据的修改对其他线程是立马可见的。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li>方腾飞 等著 《Java 并发编程的艺术》</li>
<li>Doug Lea 等著 《Java 并发编程实战》</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="noopener">ConcurrentHashMap (Java Platform SE 8 ) - Oracle Help Center</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html" target="_blank" rel="noopener">探索 ConcurrentHashMap 高并发性的实现机制</a></li>
<li><a href="https://www.infoq.cn/article/ConcurrentHashMap" target="_blank" rel="noopener">聊聊并发（四）——深入分析 ConcurrentHashMap</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></li>
<li><a href="https://www.jianshu.com/p/d10256f0ebea" target="_blank" rel="noopener">ConcurrentHashMap 原理解析（JDK1.8）</a></li>
<li><a href="https://liuyueyi.github.io/hexblog/2018/05/14/ConcurrentHashMap之1-7与1-8小结/" target="_blank" rel="noopener">ConcurrentHashMap之1.7与1.8小结</a></li>
<li><a href="https://blog.csdn.net/mydreamongo/article/details/8960667" target="_blank" rel="noopener">HashMap为什么是线程不安全的？</a></li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的原子操作类</title>
    <url>/2020/04/24/atomic/</url>
    <content><![CDATA[<p>在多线程环境下，如果多个线程同时更新一个变量，可能并不会得到预期的结果。往往我们会使用加锁机制如 Synchrnized 等解决这个问题，但是仅仅对于更新基本变量来说，加锁的开销太大了，从 JDK 1.5 开始，<code>java.util.concurrent.atomic</code>（简称J.U.C 原子类）提供一种用法简单、性能高效、线程安全的更新一个变量的方式。因为变量的类型有很多，所以在 Atomic 包中一共提供了 13个类，属于 4 种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性。Atomic 包基本都是使用的 Unsafe 实现的包装类。</p>
<a id="more"></a>

<h3 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h3><p>使用原子方式更新基本类型，原子类包中提供了三个类：</p>
<ul>
<li>AtomicBoolean：原子更新布尔类型</li>
<li>AtomicInteger：原子更新整形</li>
<li>AtomicInteger：原子更新长整形</li>
</ul>
<p>上面三个类提供的方法基本一模一样，所以这里我们只以 AtomicInteger 作为代表进行讨论。</p>
<p>AtomicInteger 的常用方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int addAndGet(int delta)</td>
<td align="center">以原子方式将输入的数值与实例中值相加，并返回结果</td>
</tr>
<tr>
<td align="center">boolean compareAndSet(int expect,int update)</td>
<td align="center">如果输入的数值等于预期值，则以原子的方式将该数值设置为输入的值</td>
</tr>
<tr>
<td align="center">int getAndIncrement()</td>
<td align="center">以原子的方式将当前值加1，注意，这里返回的是自增前的值</td>
</tr>
<tr>
<td align="center">void lazySet(int newValue)</td>
<td align="center">最终会设置成newValue，使用lazySet后，可能导致其它线程在之后的一小段时间内还是可以访问到旧值</td>
</tr>
<tr>
<td align="center">int getAndSet()</td>
<td align="center">以原子方式设置为newValue的值，并返回旧值</td>
</tr>
</tbody></table>
<p>使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class AtomicIntegerTest&#123;</span><br><span class="line">    static AtomicInteger ai &#x3D; new AtomicInteger(1);</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(ai.getAndIncrement());  &#x2F;&#x2F;返回旧值</span><br><span class="line">        System.out.println(ai.get());              &#x2F;&#x2F;返回新值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>那么 AtomicInteger 底层是如何实现的呢？我们扒一下 JDK 1.8 中的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 getAndAddInt 的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的 this 指示的是 unsafe 对象，可以看到最终都是调用 unsafe.compareAndSwapInt 方法，也就是 CAS 方法。</p>
<p>底层调用的都是 Unsafe 类的方式，类权限定名为<code>sun.misc.Unsafe</code>，由于这个包是 JDK 的 native 方法，底层使用 C++ 实现，用户不能直接通过 new Unsafe() 或者 Unsafe.getUnsafe() 等方法创建对象。</p>
<p>所以换种方法，我们通过查看 openjdk-8 的源码来查看底层操作，目录是<code>openjdk-8-src-b132-03_mar_2014\openjdk\jdk\src\share\classes\sun\misc</code>。此类包含了低级（native 硬件级别的原子操作）、不安全的操作集合。</p>
<p>获取 Unsafe 实例静态方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Unsafe() &#123;&#125;</span><br><span class="line"></span><br><span class="line">private static final Unsafe theUnsafe &#x3D; new Unsafe();</span><br><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">public static Unsafe getUnsafe() &#123;</span><br><span class="line">    Class&lt;?&gt; caller &#x3D; Reflection.getCallerClass();</span><br><span class="line">    if (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">        throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">    return theUnsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一下其中的 public native 方法，扩展的 C++ 就不看了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;&#x2F;扩充内存  &#96;</span><br></pre></td></tr></table></figure>

<p>上面这些有兴趣可以仔细看看，我们主要看 compareAndSwapObject 的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;**&#96;</span><br></pre></td></tr></table></figure>

<p>到这里我们就可以明白了，更新数值都是基于 CAS 实现的，</p>
<p>CAS 指的是现代 CPU  广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。简单介绍一下这个指令的操作过程：首先，CPU  会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU  会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，CAS  的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。（这段描述引自《Java并发编程实践》）</p>
<p>简单的来说，CAS有 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。<strong>当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则返回 V</strong>。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而 Synchronized 是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。</p>
<h3 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h3><p>通过原子的方式更新数组里某个元素，Atomic 包中提供以下类：</p>
<ul>
<li>AtomicIntegerArray：原子更新整型数组中元素</li>
<li>AtomicLongArray：原子更新长整型数组中的元素</li>
<li>AtomicReferenceArray：原子更新引用类型数组中的元素</li>
</ul>
<p>其中 AtomicIntegerArray 类主要是提供原子的方式更新数组中的整形，其常用方法如下：</p>
<ol>
<li>int addAndGet(int i,int delta)：以原子方式将输入值与数组中索引 i 的元素相加</li>
<li>boolean compareAndSet(int i,int expect,int update)：如果当前值等于预期值，则以原子方式将数组位置 i 的元素设置为 update 值。</li>
</ol>
<p>以上几个类提供的方法几乎一样，我们只以 AtomicIntegerArray 讲解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public class A&#96;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;3&#96;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，AtomicIntegerArray 传入数组的构造方法仅仅是将原数组复制了一份，所以原数组中内容不会被影响。</p>
<h3 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h3><p>原子更新基本类型 AtomicInteger 只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供以下类：</p>
<ul>
<li>AtomicReference：原子更新引用类型</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li>
<li>AtomicMarkableReference：原子更新带有引用标记的引用类型，可以原子更新一个布尔类型的标记位和引用类型。构造方法是 AtomicMarkableReference(V initialRef,boolean initialMark)</li>
</ul>
<p>此处仅以 AtomicReference 为例进行讲解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AtomicReferenceTest&#123;</span><br><span class="line">    public static AtomicReference&lt;user&gt; atomicUserRef &#x3D; new AtomicReference&lt;user&gt;();</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        User user &#x3D; new User(&quot;conan&quot;,15);</span><br><span class="line">        atomicUserRef.set(user);</span><br><span class="line">        User updateUser &#x3D; new User(&quot;Shinichi&quot;,17);</span><br><span class="line">        atomicUserRef.compareAndSet(user,updateUser);</span><br><span class="line">        System.out.println(atomicUserRef.get().getName());</span><br><span class="line">        System.out.println(atomicUserRef.get().getOld());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class User&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int old;</span><br><span class="line">        </span><br><span class="line">        public User(String name,String old)&#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            this.old &#x3D; old;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public String getName()&#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public int getOld()&#123;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Shinichi&#96;</span><br></pre></td></tr></table></figure>

<h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p>如果需要原子更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic 包提供了以下 3 个类进行原子字段更新：</p>
<ul>
<li>AtomicintegerFieldUpdater：原子更新整型的字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新出现的 “ABA” 问题。</li>
</ul>
<p>要想原子的更新字段类需要两步，第一步因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法 newUpdatar() 创建一个更新器，并且需要设置想要更新的类和属性；第二步，更新类的字段（属性）必须使用 public volatile 修饰符。</p>
<p>此处仅以 AtomicIntegerFieldUpdater 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public class AtomicIntegerF&#96;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;1011&#96;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程中的AQS</title>
    <url>/2020/04/25/AQS/</url>
    <content><![CDATA[<p>`</p>
<p>java.util.concurrent<code>包（即面试必问的 J.U.C 包）提供了解决并发编程问题的办法，而</code>java.util.concurrent.locks<code>中的类，以及常用的</code>Semophore<code>等工具类，很多都是基于 AQS 实现的。 那么什么是 AQS 呢？其全称为</code>AbstractQueuedSynchronizer`，即抽象队列同步器，一般简称为队列同步器。</p>
<a id="more"></a>

<h1 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h1><p>AQS 是一个抽象类，主是是以继承的方式使用。AQS 本身是没有实现任何同步接口的，它仅仅只是定义了同步状态的获取和释放的方法来供自定义的同步组件的使用。</p>
<p><img src="/img/AQS/aqs.png" alt="aqs"></p>
<h2 id="AQS的核心结构"><a href="#AQS的核心结构" class="headerlink" title="AQS的核心结构"></a>AQS的核心结构</h2><p>在分析 AQS 源码之前，我们需要先知道 AQS  内部的关键是什么，简单来说，AQS 的实现依赖内部的同步队列（FIFO 双向队列），如果当前线程获取同步状态失败，AQS  会将该线程以及等待状态等信息构造成一个 Node，将其加入同步队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。</p>
<p>上面说的有点抽象，不妨打开 AQS 源码，先看一下 AQS 中最主要的三个成员变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;volatile修饰的队列头节点</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;volatile修饰的队列尾节点</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;volatile修饰的同步状态</span><br><span class="line">&#x2F;&#x2F;state &#x3D; 0 表示同步状态可用（如果用于锁，表示锁可用）</span><br><span class="line">&#x2F;&#x2F;state &#x3D; 1 表示同步状态已被占用（锁被占用）</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure>

<p>并且根据源码可以显然看到，AQS 内部实现了 Node 和 ConditionObject 两个内部类，并且 Node 是使用 <code>static final</code>修饰的静态内部类，可以看到其结构如下：</p>
<p><img src="/img/AQS/aqs.png" alt="aqs"></p>
<p>Node 的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    &#x2F;&#x2F;共享模式</span><br><span class="line">    static final Node SHARED &#x3D; new Node();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;独占模式</span><br><span class="line">    static final Node EXCLUSIVE &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span><br><span class="line">    static final int CANCELLED &#x3D;  1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span><br><span class="line">    static final int SIGNAL    &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span><br><span class="line">    static final int CONDITION &#x3D; -2;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;表示下一次共享式同步状态获取将会无条件地传播下去</span><br><span class="line">    static final int PROPAGATE &#x3D; -3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;等待状态</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;前驱节点</span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;后继节点</span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当前节点的线程</span><br><span class="line">    volatile Thread thread;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么看到这里就可以基本明白：Node 的作用实际上是在维护一个队列，根据源码文档可知这个队列是一个<code>FIFO</code>双向队列，官方称之为<code>CLH</code>（Craig, Landin, and Hagersten）队列。</p>
<p>CLH 队列结构示意图如下：</p>
<p><img src="/img/AQS/clh.png" alt="clh"></p>
<p>在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（ thread ）、状态（ waitStatus ）、前驱节点（ prev ）、后继节点（ next ） 。</p>
<p>CLH  同步队列是一个 FIFO 双向队列，AQS 依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS  则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到 CLH  同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（如果构造的是公平锁），使其再次尝试获取同步状态。</p>
<p>那么根据上述分析可知，AQS 实际上就是使用了一个 int 成员变量 state 表示同步状态，并通过内置的 FIFO 队列来完成资源获取线程的排队工作。</p>
<h2 id="AQS的实现方式"><a href="#AQS的实现方式" class="headerlink" title="AQS的实现方式"></a>AQS的实现方式</h2><p>了解了上面的核心结构，我们就可以继续来研究一下 AQS 内部具体是怎么实现的。</p>
<p>同步器的设计是基于模板方法设计模式的，也就是说，使用者需要继承同步器并重写指定方法，然后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。可能说的有点抽象，后面在探讨  ReentrantLock 等基于 AQS 实现的类中会逐渐明白这个原理。</p>
<p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或者修改同步状态：</p>
<ol>
<li><code>getState()</code>：获取当前同步状态。</li>
<li><code>setState(int newState)</code>：设置当前同步状态。</li>
<li><code>compareAndSetState(int expect,int update)</code>：使用 CAS 设置当前状态，该方法能够保证状态设置的原子性。</li>
</ol>
<p>其源码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取同步状态</span><br><span class="line">protected final int getState() &#123;</span><br><span class="line">   return state;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;设置同步状态</span><br><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">   state &#x3D; newState;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;以原子方式设置同步状态</span><br><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 AQS 里面的方法很多，但是绝大多数方法都是 private 和 final 的，即不能被继承和实现。在第一个 AQS 图中红框圈出来的表示的是继承 AQS 后能够重写的方法，其方法名称和方法描述如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">protected boolean tryAcquire(int args)</td>
<td align="center"><strong>独占式获取同步状态</strong>，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态。</td>
</tr>
<tr>
<td align="center">protected boolean tryRelease(int arg)</td>
<td align="center"><strong>独占式释放同步状态</strong> ，等待获取同步状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td align="center">protected int tryAcquireShared</td>
<td align="center"><strong>共享式获取同步状态</strong>，返回大于等于0的值表示获取成功，否则获取失败</td>
</tr>
<tr>
<td align="center">protected boolean tryReleaseShared(int arg)</td>
<td align="center"><strong>共享式释放</strong>同步状态</td>
</tr>
<tr>
<td align="center">protected boolean isHeldExclusively()</td>
<td align="center">当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程独占</td>
</tr>
</tbody></table>
<p>源码中上面方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;尝试获取独占模式   </span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尝试释放独占模式</span><br><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;共享式获取同步状态</span><br><span class="line">&#x2F;&#x2F;返回负数表示失败;0表示成功，但没有剩余可用资源;正数表示成功，且有剩余资源。</span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;共享式释放同步状态;如果释放后允许唤醒后续等待结点返回true，否则返回false。</span><br><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占;只有用到condition才需要去实现它。</span><br><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面分析可知，AQS 在内部定义了两种资源共享方式：</p>
<ul>
<li>Exclusive（独占，只有一个线程能执行，如ReentrantLock）</li>
<li>Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）</li>
</ul>
<p>下面我们对这两种方式一一探讨。</p>
<h3 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h3><p>独占模式就相当于使用了排他锁，每次只有一个线程能够执行，其他线程需要在 CLH 队列中排队。下面分析一下 AQS 源码中的独占模式方法。</p>
<h4 id="acquire-方法"><a href="#acquire-方法" class="headerlink" title="acquire()方法"></a>acquire()方法</h4><p>该方法以独占模式获取共享资源。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。<code>ReentrantLock</code>的<code>lock</code>方法就是调用的该方法来获取锁。</p>
<p>方法的执行流程如下：</p>
<ol>
<li>调用自定义同步器的<code>tryAcquire()</code>尝试直接去获取资源，如果成功则直接返回。</li>
<li>没成功，则<code>addWaiter()</code>将该线程加入等待队列的尾部，并标记为独占模式。</li>
<li><code>acquireQueued()</code>使线程在等待队列中休息，有机会时（轮到自己，会被<code>unpark()</code>）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回<code>true</code>，否则返回<code>false</code>。 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断<code>selfInterrupt()</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 独占模式获取同步状态，如果当前线程获取同步状态成功，则直接返回，否则</span><br><span class="line"> * 将会进入同步队列等待，该方法会调用实现类重写的tryAcquire(int arg)方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryAcquire-方法"><a href="#tryAcquire-方法" class="headerlink" title="tryAcquire()方法"></a>tryAcquire()方法</h4><p>源码 doc 翻译：尝试以独占模式获取。 如果对象的状态允许以独占模式获取它，则此方法应查询，如果是，则获取它。</p>
<p>执行 acquire 的线程始终调用此方法。 如果此方法报告失败，则获取方法可以对线程进行排队（如果它尚未排队），直到它通过某个其他线程的释放来发出信号。 这可用于<code>Lock</code>类中实现<code>tryLock()方法</code>。</p>
<p><strong>自我理解</strong>：这个方法是需要实现类进行重写的，用于对资源的获取和释放。至于能不能重入，能不能加锁，那就看具体的自定义同步器怎么去设计了。当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p>
<p>该部分源码在上面已经提及。</p>
<h4 id="addWaiter-方法"><a href="#addWaiter-方法" class="headerlink" title="addWaiter()方法"></a>addWaiter()方法</h4><p>源码 doc 翻译：为当前线程和给定模式创建节点并进行排队。</p>
<p><strong>自我理解</strong>：CLH 队列入列无非就是 tail 指向新节点、新节点的 prev 指向当前最后的节点，当前最后一个节点的 next 指向当前节点。代码我们可以看看<code>addWaiter(Node node)</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;**&#96;</span><br></pre></td></tr></table></figure>

<h4 id="enq-方法"><a href="#enq-方法" class="headerlink" title="enq()方法"></a>enq()方法</h4><p>源码 doc 翻译：将节点插入队列，必要时进行初始化 。</p>
<p><strong>自我理解</strong>：<code>addWaiter(Node node)</code>先通过快速尝试设置尾节点，如果失败，则调用<code>enq(Node node)</code>方法设置尾节点。在<code>enq(Node node)</code>方法中，AQS 通过自旋锁的方式来保证节点可以正确添加，只有成功添加后，当前线程才会从该方法返回，否则会一直执行下去 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 将node加入队尾</span><br><span class="line"> *&#x2F;</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 自旋</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        &#x2F;&#x2F; 当前没有节点，构造一个new Node()，将head和tail指向它</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; </span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前有节点，将传入的Node放在链表的最后</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="acquireQueued-方法"><a href="#acquireQueued-方法" class="headerlink" title="acquireQueued()方法"></a>acquireQueued()方法</h4><p>源码doc翻译：对于已经在队列中的线程，以独占不间断模式获取。 由条件等待方法使用以及获取。</p>
<p>自我理解：通过<code>tryAcquire()</code>和<code>addWaiter()</code>，该线程获取资源失败，已经被放入等待队列尾部了。下一步需要处理的是：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。其实就是个排队拿号，在等待队列中排队拿号，直到拿到号后再返回 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true; </span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false; &#x2F;&#x2F; 标记等待过程中是否被中断过</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();    &#x2F;&#x2F; node的前一个节点</span><br><span class="line">            &#x2F;&#x2F; 如果前一个节点是head，说明当前node节点是第二个节点，接着尝试去获取资源</span><br><span class="line">            &#x2F;&#x2F; 可能是head释放完资源唤醒自己的，当然也可能被interrupt了</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;    &#x2F;&#x2F; 返回等待过程中是否被中断过</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果自己可以休息了，就进入waiting状态，直到被unpark()</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;    &#x2F;&#x2F; 如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shouldParkAfterFailedAcquire-方法"><a href="#shouldParkAfterFailedAcquire-方法" class="headerlink" title="shouldParkAfterFailedAcquire()方法"></a>shouldParkAfterFailedAcquire()方法</h4><p>源码 doc 翻译：检查并更新无法获取的节点的状态。 如果线程应该阻塞，则返回 true。 这是所有获取循环中的主要信号控制。 需要<code>pred == node.prev</code>。</p>
<p><strong>自我理解</strong>： 此方法主要用于检查状态，看看自己是否真的可以去休息了</p>
<ol>
<li>如果 pred 的<code>waitStatus</code>是<code>SIGNAL</code>，直接返回<code>true</code></li>
<li>如果 pred 的<code>waitStatus&gt;0</code>，也就是<code>CANCELLED</code>，向前一直找到<code>&lt;= 0</code>的节点，让节点的<code>next</code>指向<code>node</code></li>
<li>如果 pred 的<code>waitStatus&lt;=0</code>，改成<code>SIGNAL</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;private static boolean shouldParkAfterFail&#96;</span><br></pre></td></tr></table></figure>

<h4 id="parkAndCheckInterrupt-方法"><a href="#parkAndCheckInterrupt-方法" class="headerlink" title="parkAndCheckInterrupt()方法"></a>parkAndCheckInterrupt()方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;** * 让线程去休息，真正进入等待状态&#96;</span><br></pre></td></tr></table></figure>

<p><code>acquireQueued</code>总共做了3件事：</p>
<ul>
<li>结点进入队尾后，检查状态。</li>
<li>调用 <code>park()</code> 进入waiting 状态，等待 <code>unpark()</code> 或 <code>interrupt()</code> 唤醒自己。</li>
<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head 指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程 1。</li>
</ul>
<p>流程图如下：</p>
<p><img src="/img/AQS/liucheng.jpg.png" alt="liucheng.jpg"></p>
<h4 id="release-方法"><a href="#release-方法" class="headerlink" title="release()方法"></a>release()方法</h4><p>此方法是独占模式下线程释放资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即 state=0）,它会唤醒等待队列里的其他线程来获取资源 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 释放资源</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h); &#x2F;&#x2F; 唤醒等待队列里的下一个线程</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryRelease-方法"><a href="#tryRelease-方法" class="headerlink" title="tryRelease()方法"></a>tryRelease()方法</h4><p>跟<code>tryAcquire()</code>一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，<code>tryRelease()</code>都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可（state-=arg），也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，<code>release()</code>是根据<code>tryRelease()</code>的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源（state=0），要返回 true，否则返回 false。</p>
<h4 id="unparkSuccessor-方法"><a href="#unparkSuccessor-方法" class="headerlink" title="unparkSuccessor()方法"></a>unparkSuccessor()方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;private void unparkSuccessor(Node node) &#123;&#96;</span><br></pre></td></tr></table></figure>

<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>在 AQS 中维护着一个 FIFO 的同步队列，当线程获取同步状态失败后，则会加入到这个  CLH 同步队列的对尾并一直保持着自旋。在 CLH  同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出 CLH  同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p>
<h3 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h3><h4 id="acquireShared-方法"><a href="#acquireShared-方法" class="headerlink" title="acquireShared()方法"></a>acquireShared()方法</h4><p>源码 doc 翻译:以共享模式获取，忽略中断。 通过首先调用{<a href="https://my.oschina.net/u/393" target="_blank" rel="noopener">@link</a> #tryAcquireShared}来实现，成功返回。 否则线程排队，可能反复阻塞和解除阻塞，调用{<a href="https://my.oschina.net/u/393" target="_blank" rel="noopener">@link</a> #tryAcquireShared}直到成功。</p>
<p>简单点说就是这个方法会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryAcquireShared-方法"><a href="#tryAcquireShared-方法" class="headerlink" title="tryAcquireShared()方法"></a>tryAcquireShared()方法</h4><p><code>tryAcquireShared()</code>依然需要自定义实现类去实现。但是 AQS 已经把其返回值的语义定义好了：负值代表获取失败；0 代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;共享式获取同步状态</span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doAcquireShared-方法"><a href="#doAcquireShared-方法" class="headerlink" title="doAcquireShared()方法"></a>doAcquireShared()方法</h4><p>源码 doc 翻译：以共享不间断模式获取</p>
<p>此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">        &#x2F;&#x2F;队列尾部添加共享模式的节点</span><br><span class="line">        final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                &#x2F;&#x2F;获取上一个节点,如果上一个节点时head，尝试获取资源</span><br><span class="line">                    int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);&#x2F;&#x2F;成功有剩余资源，将head指向自己，唤醒之后的线程</span><br><span class="line">                        p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                        if (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed &#x3D; false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="setHeadAndPropagate-方法"><a href="#setHeadAndPropagate-方法" class="headerlink" title="setHeadAndPropagate()方法"></a>setHeadAndPropagate()方法</h4><p>设置队列头，并检查后继者是否在共享模式下等待，如果是传播，如果传播<code>&gt; 0</code>或<code>PROPAGATE</code>状态已设置。</p>
<p>这个方法除了重新标记 head 指向的节点外，还有一个重要的作用，那就是 propagate（传递）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;private void setHeadAndPropagate(Node node, int propagate) &#123;&#96;</span><br></pre></td></tr></table></figure>

<h4 id="doReleaseShared-方法"><a href="#doReleaseShared-方法" class="headerlink" title="doReleaseShared()方法"></a>doReleaseShared()方法</h4><p>共享模式的释放操作 ，发出后续信号并确保传播。 （注意：对于独占模式，如果需要信号，只需调用数量来调用 head 的 unparkSuccessor）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;private&#96;</span><br></pre></td></tr></table></figure>

<p><code>acquireShared</code>总结：</p>
<ul>
<li><code>tryAcquireShared()</code>尝试获取资源，成功则直接返回。</li>
<li><code>doAcquireShared()</code>会将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己。它还会尝试着让唤醒传递到后面的节点。</li>
</ul>
<h4 id="releaseShared-方法"><a href="#releaseShared-方法" class="headerlink" title="releaseShared()方法"></a>releaseShared()方法</h4><p>以共享模式发布。, 如果{<a href="https://my.oschina.net/u/393" target="_blank" rel="noopener">@link</a> #tryReleaseShared}返回 true，则通过解除阻塞一个或多个线程来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public&#96;</span><br></pre></td></tr></table></figure>

<h1 id="自定义同步组件"><a href="#自定义同步组件" class="headerlink" title="自定义同步组件"></a>自定义同步组件</h1><p>在了解了前面 AQS 的实现原理后，我们可以自己实现一个同步组件来加深对 AQS 的理解。</p>
<p>我们设计一个同步工具：该工具在同一时刻，只允许至多两个线程同时访问，超过两个线程的访问将被阻塞，我们将这个组件定义为 TwinsLock。</p>
<p>首先，确定访问模式，由于同一时刻能支持多个线程访问，所以是共享模式，因此需要重写 AQS 的 <code>tryAcquireShared(int args)</code>方法和<code>tryReleaseShared(int args)</code>方法等，这样才能保证同步器的共享式同步状态的获取和释放方法得以执行。</p>
<p>其次，定义资源数，由于  TwinsLock 在同一时刻允许至多两个线程同时访问，表明同步资源数为 2，这样可以设置初始状态 status 为 2，当一个线程进行获取，  status 减一，该线程释放，则 status 加 1，状态的合法范围为 0、1 和 2.</p>
<p>最后，组合上述要求，我们可以写出主要代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public&#96;</span><br></pre></td></tr></table></figure>

<p>在上述方法中， TwinsLock 实现了 Lock 接口，提供了面向使用者的接口，使用者调用 lock() 方法获取锁，随后调用  unlock() 方法释放锁，而同一时刻只能有两个线程同时获取到锁。TwinsLock 同时包含了一个自定义同步器  Sync，而该同步器面向线程访问和同步状态控制。以共享式获取同步状态为例：同步器会先计算出获取后的同步状态，然后通过 CAS  确保状态的正确设置，当 <code>tryAcquireShared(int reduceCount)</code>方法返回值大于等于 0 时，当前线程才获取同步状态，对于上层的 TwinsLock 来说，则表示当前线程获取了锁。</p>
<p>同步器是一个桥梁，连接线程访问以及同步状态控制等底层技术与不同的并发组件（比如 Lock 、CountDownLatch 等）的接口语义。</p>
<p>下面测试一下上面自定义同步器能否正常工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public c&#96;</span><br></pre></td></tr></table></figure>

<p>运行结果可以看到线程名称成对输出，也就是表明在同一时刻只有两个线程能够获取到锁，这表明 TwinsLock 可以按照预期工作。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li>方腾飞 等著 《Java 并发编程的艺术》</li>
<li><a href="https://my.oschina.net/xiongying0214/blog/1944627" target="_blank" rel="noopener">并发编程之AQS(AbstractQueuedSynchronizer)</a></li>
<li><a href="https://segmentfault.com/a/1190000008471362?utm_source=tag-newest" target="_blank" rel="noopener">浅谈Java并发编程系列（九）—— AQS结构及原理分析</a></li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>J.U.C并发包知识点梳理</title>
    <url>/2020/04/15/JUC/</url>
    <content><![CDATA[<p>CAS是 java.util.concurrent.atomic 包的基础，AQS是 java.util.concurrent.locks 包以及一些常用类比如 Semophore ， ReentrantLock 等类的基础</p>
<a id="more"></a>

<h2 id="J-U-C包的分类"><a href="#J-U-C包的分类" class="headerlink" title="J.U.C包的分类"></a>J.U.C包的分类</h2><ol>
<li>线程执行器executor</li>
<li>锁locks</li>
<li>原子变量类atomic</li>
<li>并发工具类tools</li>
<li>并发集合collections</li>
</ol>
<p><img src="/img/JUC/juc.png" alt="juc"></p>
<p>上面的图可以点开放大来看，为了看的更仔细，下面是J.U.C模块拆分出来的具体分类图：</p>
<h2 id="J-U-C的几大内容"><a href="#J-U-C的几大内容" class="headerlink" title="J.U.C的几大内容"></a>J.U.C的几大内容</h2><p><img src="/img/JUC/concurrent.png" alt="concurrent"></p>
<p>其中 tools 包中提供了并发编程的工具类如 CountDownLatch、CyclicBarrier 等；locks 包中提供了如  ReentrantLock 为代表的显式锁等；Collections 包中提供了并发集合类，常用的有  ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet  以及阻塞队列等；executor 包中提供了一个线程调度的框架；最后的 atomic 包中就是原子操作类。</p>
<p>下面一一介绍。</p>
<h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p><img src="/img/JUC/executor.png" alt="executor"></p>
<h3 id="Locks锁"><a href="#Locks锁" class="headerlink" title="Locks锁"></a>Locks锁</h3><p><img src="/img/JUC/locks.png" alt="locks"></p>
<p>lock 包中的锁都是基于 AQS 构成，因此理解这一部分就需要重点理解 <a href="https://bestzuo.cn/posts/3723625690.html" target="_blank" rel="noopener">AQS的原理</a>，<a href="https://bestzuo.cn/posts/java-condition.html" target="_blank" rel="noopener">Condition 接口实现类</a>和 Lock 实现类组合可以实现等待/通知模式，<a href="https://bestzuo.cn/posts/1665595927.html" target="_blank" rel="noopener">读写锁</a>则是有自己的实现方式，LockSupport 是一个工具类，与 Condition 接口配合使用。</p>
<h3 id="原子类atomic"><a href="#原子类atomic" class="headerlink" title="原子类atomic"></a>原子类atomic</h3><p><img src="/img/JUC/atomic.png" alt="atomic"></p>
<p>原子类的构建是以 CAS 实现为基础，<a href="https://bestzuo.cn/posts/2201553789.html" target="_blank" rel="noopener">原子类实现</a>的原理必须要了解。</p>
<h3 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h3><p><img src="/img/JUC/tools.png" alt="tools"></p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>闭锁，<strong>让主线程等待一组事件发生后继续执行</strong>，事件指的是<code>CountDownLatch</code>里的<code>countDown()</code>方法。使用这个工具类可以将任务分为多个子任务执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new CountDownLatchDemo().go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void go() throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(3);</span><br><span class="line">        &#x2F;&#x2F;依次创建3个线程，并启动</span><br><span class="line">        new Thread(new Task(countDownLatch),&quot;Thread1&quot;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        new Thread(new Task(countDownLatch),&quot;Thread2&quot;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        new Thread(new Task(countDownLatch),&quot;Thread3&quot;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        &#x2F;&#x2F;调用await方法阻塞当前线程，直到其它所有线程执行完</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(&quot;所有线程已到达，主线程开始执行&quot; + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Task implements Runnable&#123;</span><br><span class="line">        private CountDownLatch countDownLatch;</span><br><span class="line">        public Task(CountDownLatch countDownLatch)&#123;</span><br><span class="line">            this.countDownLatch &#x3D; countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;已经到达&quot; + System.currentTimeMillis());</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以运行一下代码，控制台输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程Thread1已经到达1554697004783</span><br><span class="line">线程Thread2已经到达1554697005755</span><br><span class="line">线程Thread3已经到达1554697006755</span><br><span class="line">所有线程已到达，主线程开始执行1554697007755</span><br></pre></td></tr></table></figure>

<p>CountDownLatch 的实现原理并不复杂，也是基于 AQS  实现的同步组件，由于允许多个线程同时运行，所以内部维护的是共享锁。构造器中传入 CountDownLatch 的数字 3 实质上就是 AQS  的同步状态 state 设置为 3，而 CountDownLatch 的关键方法 countDown() 实质上调用的是 AQS 的  releaseShared() 方法，即调用一次该方法这个共享锁的同步状态减 1，直到同步状态为 0 这个锁释放。</p>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>字面意思为可循环使用的屏障，主要作用是让一组线程到达一个屏障（又叫做同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。可用于多线程计算数据等场景。</p>
<ol>
<li>等待其它线程，且会阻塞自己当前线程，所有线程必须同时到达栅栏位置后，才能继续执行。</li>
<li>所有线程达到栅栏处，可以触发执行另外一个预先设置的线程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new CyclicBarrierDemo().go();</span><br><span class="line">    &#125;</span><br><span class="line">    private void go() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化栅栏的参与者数是3</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3);</span><br><span class="line">        &#x2F;&#x2F;依次创建三个线程并启动</span><br><span class="line">        new Thread(new Task(cyclicBarrier),&quot;Thread1&quot;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        new Thread(new Task(cyclicBarrier),&quot;Thread2&quot;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        new Thread(new Task(cyclicBarrier),&quot;Thread3&quot;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Task implements Runnable&#123;</span><br><span class="line">        private CyclicBarrier cyclicBarrier;</span><br><span class="line">        public Task(CyclicBarrier cyclicBarrier)&#123;</span><br><span class="line">            this.cyclicBarrier &#x3D; cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;已经到达&quot; + System.currentTimeMillis());</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;每个线程调用await方法告诉CyclicBarrier我已经到达了屏障</span><br><span class="line">                &#x2F;&#x2F;然后当前线程被阻塞</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;开始处理&quot; + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上可以看出来，好像表面上 CyclicBarrier 和 CountDownLatch 没有什么区别啊？那么区别在哪呢？</p>
</blockquote>
<p>CountDownLatch 的计数器只能用一次，而 CyclicBarrier 的计数器可以使用 reset() 方法重置，所以 CyclicBarrier 可以适用于更复杂的业务场景。例如如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p>
<p>CyclicBarrier 还提供其它有用的方法，比如 getNumberWaiting() 方法可以获得 CyclicBarrier 阻塞的线程数量。isBroken() 方法用来了解阻塞的线程是否被中断等等。</p>
<p>我们可以看一下源码，CyclicBarrier  是基于 ReentrantLock 和 Condition 接口实现的，而两者都是基于 AQS 实现的，所以说到底最终还是基于 AQS  实现的工具类。其中有一个内部类 Generation，每一次使用的CycBarrier可以当成Generation的实例，其源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class Generation &#123;</span><br><span class="line">    boolean broken &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其属性如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrier &#123;</span><br><span class="line">    &#x2F;** The lock for guarding barrier entry *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 可重入锁</span><br><span class="line">    private final ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">    &#x2F;** Condition to wait on until tripped *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 条件队列</span><br><span class="line">    private final Condition trip &#x3D; lock.newCondition();</span><br><span class="line">    &#x2F;** The number of parties *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 参与的线程数量</span><br><span class="line">    private final int parties;</span><br><span class="line">    &#x2F;* The command to run when tripped *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 由最后一个进入 barrier 的线程执行的操作</span><br><span class="line">    private final Runnable barrierCommand;</span><br><span class="line">    &#x2F;** The current generation *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 当前代</span><br><span class="line">    private Generation generation &#x3D; new Generation();</span><br><span class="line">    &#x2F;&#x2F; 正在等待进入屏障的线程数量</span><br><span class="line">    private int count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其构造方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">        &#x2F;&#x2F; 参与的线程数量小于等于0，抛出异常</span><br><span class="line">        if (parties &lt;&#x3D; 0) throw new IllegalArgumentException();</span><br><span class="line">        &#x2F;&#x2F; 设置parties</span><br><span class="line">        this.parties &#x3D; parties;</span><br><span class="line">        &#x2F;&#x2F; 设置count</span><br><span class="line">        this.count &#x3D; parties;</span><br><span class="line">        &#x2F;&#x2F; 设置barrierCommand</span><br><span class="line">        this.barrierCommand &#x3D; barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认</span><br><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心函数 dowait 源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">TimeoutException &#123;</span><br><span class="line">    &#x2F;&#x2F; 保存当前锁</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    &#x2F;&#x2F; 锁定</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 保存当前代</span><br><span class="line">        final Generation g &#x3D; generation;</span><br><span class="line"></span><br><span class="line">        if (g.broken) &#x2F;&#x2F; 屏障被破坏，抛出异常</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        if (Thread.interrupted()) &#123; &#x2F;&#x2F; 线程被中断</span><br><span class="line">            &#x2F;&#x2F; 损坏当前屏障，并且唤醒所有的线程，只有拥有锁的时候才会调用</span><br><span class="line">            breakBarrier();</span><br><span class="line">            &#x2F;&#x2F; 抛出异常</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 减少正在等待进入屏障的线程数量</span><br><span class="line">        int index &#x3D; --count;</span><br><span class="line">        if (index &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 正在等待进入屏障的线程数量为0，所有线程都已经进入</span><br><span class="line">            &#x2F;&#x2F; 运行的动作标识</span><br><span class="line">            boolean ranAction &#x3D; false;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 保存运行动作</span><br><span class="line">                final Runnable command &#x3D; barrierCommand;</span><br><span class="line">                if (command !&#x3D; null) &#x2F;&#x2F; 动作不为空</span><br><span class="line">                    &#x2F;&#x2F; 运行</span><br><span class="line">                    command.run();</span><br><span class="line">                &#x2F;&#x2F; 设置ranAction状态</span><br><span class="line">                ranAction &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F; 进入下一代</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!ranAction) &#x2F;&#x2F; 没有运行的动作</span><br><span class="line">                    &#x2F;&#x2F; 损坏当前屏障</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; loop until tripped, broken, interrupted, or timed out</span><br><span class="line">        &#x2F;&#x2F; 无限循环</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!timed) &#x2F;&#x2F; 没有设置等待时间</span><br><span class="line">                    &#x2F;&#x2F; 等待</span><br><span class="line">                    trip.await(); </span><br><span class="line">                else if (nanos &gt; 0L) &#x2F;&#x2F; 设置了等待时间，并且等待时间大于0</span><br><span class="line">                    &#x2F;&#x2F; 等待指定时长</span><br><span class="line">                    nanos &#x3D; trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123; </span><br><span class="line">                if (g &#x3D;&#x3D; generation &amp;&amp; ! g.broken) &#123; &#x2F;&#x2F; 等于当前代并且屏障没有被损坏</span><br><span class="line">                    &#x2F;&#x2F; 损坏当前屏障</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    &#x2F;&#x2F; 抛出异常</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F; 不等于当前带后者是屏障被损坏</span><br><span class="line">                    &#x2F;&#x2F; We&#39;re about to finish waiting even if we had not</span><br><span class="line">                    &#x2F;&#x2F; been interrupted, so this interrupt is deemed to</span><br><span class="line">                    &#x2F;&#x2F; &quot;belong&quot; to subsequent execution.</span><br><span class="line">                    &#x2F;&#x2F; 中断当前线程</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (g.broken) &#x2F;&#x2F; 屏障被损坏，抛出异常</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            if (g !&#x3D; generation) &#x2F;&#x2F; 不等于当前代</span><br><span class="line">                &#x2F;&#x2F; 返回索引</span><br><span class="line">                return index;</span><br><span class="line"></span><br><span class="line">            if (timed &amp;&amp; nanos &lt;&#x3D; 0L) &#123; &#x2F;&#x2F; 设置了等待时间，并且等待时间小于0</span><br><span class="line">                &#x2F;&#x2F; 损坏屏障</span><br><span class="line">                breakBarrier();</span><br><span class="line">                &#x2F;&#x2F; 抛出异常</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数为 CyclicBarrier 类的核心函数，CyclicBarrier 类对外提供的 await 函数在底层都是调用该了 doawait 函数，其逻辑判断过程大致如下：</p>
<p><img src="/img/JUC/dowait.png" alt="dowait"></p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量，控制某个资源可被同时访问的线程个数。可以用做流量控制，特别是公有资源有限的应用场景，比如数据库连接等。</p>
<p> 该工具类还提供一些其它方法，比如：</p>
<p>（1）<code>intavailablePermits()</code> ：返回此信号量中当前可用的许可证数。</p>
<p>（2）<code>intgetQueueLength()</code> ：返回正在等待获取许可证的线程数。</p>
<p>（3）<code>booleanhasQueuedThreads()</code> ：是否有线程正在等待获取许可证。</p>
<p>（4）<code>void reducePermits(int reduction)</code> ：减少reduction个许可证，是个protected方法。</p>
<p>（5）<code>Collection getQueuedThreads()</code> ：返回所有等待获取许可证的线程集合，是个protected方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;线程池</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        &#x2F;&#x2F;只能5个线程同时访问</span><br><span class="line">        final Semaphore semp &#x3D; new Semaphore(5);</span><br><span class="line">        &#x2F;&#x2F;模拟20个客户端访问</span><br><span class="line">        for(int index &#x3D; 0; index &lt; 20;index++)&#123;</span><br><span class="line">            final int NO &#x3D; index;</span><br><span class="line">            Runnable run &#x3D; new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    &#x2F;&#x2F;获取许可</span><br><span class="line">                    try &#123;</span><br><span class="line">                        semp.acquire();</span><br><span class="line">                        System.out.println(&quot;Accessing:&quot; + NO);</span><br><span class="line">                        Thread.sleep((long)(Math.random() * 10000));</span><br><span class="line">                        &#x2F;&#x2F;访问完后，释放</span><br><span class="line">                        semp.release();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.execute(run);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;退出线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>交换器，两个线程到达同步点后，相互交换数据。可以用于遗传算法，也可以用于校对工作，比如银行电子账户流水，为了避免错误采用AB岗两人进行录入系统，录入到Excel后可以使用这种方式进行校对来判断录入是否一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public class ExchangerTest extends Thread &#123;&#96;</span><br></pre></td></tr></table></figure>

<h3 id="并发集合Collections"><a href="#并发集合Collections" class="headerlink" title="并发集合Collections"></a>并发集合Collections</h3><p><img src="/img/JUC/collections.png" alt="collections"></p>
<p><strong>BlockQueue</strong>：提供可阻塞的入队和出队操作，<code>BlockingQueue</code>不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，他还自动管理了多线间的自动等待于唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。</p>
<h4 id="放入数据"><a href="#放入数据" class="headerlink" title="放入数据"></a>放入数据</h4><ol>
<li>offer(anObject) ：表示如果可能的话，将<code>anObject</code>加到<code>BlockingQueue</code>里，即如果<code>BlockingQueue</code>可以容纳,则返回 true ，否则返回 false 。（本方法不阻塞当前执行方法的线程）；　　　　　　</li>
<li>offer(E o, long timeout, TimeUnit unit) ：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。`</li>
<li>put(anObject) ：把 anObject 加到 BlockingQueue 里,如果 BlockQueue 没有空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续。</li>
</ol>
<h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><ol>
<li>poll(time)：取走 BlockingQueue 里排在首位的对象，若不能立即取出，则可以等 time 参数规定的时间，取不到时返回 null;</li>
<li>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</li>
<li>take()：取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入；</li>
<li>drainTo()：一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li>
</ol>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>基于数组的阻塞队列实现，在  ArrayBlockingQueue 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，  ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p>
<p>ArrayBlockingQueue  在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于  LinkedBlockingQueue；按照实现原理来分析， ArrayBlockingQueue  完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea 之所以没这样去做，也许是因为  ArrayBlockingQueue  的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。  ArrayBlockingQueue 和 LinkedBlockingQueue  间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的 Node  对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于 GC 的影响还是存在一定的区别。而在创建 ArrayBlockingQueue  时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>基于链表的阻塞队列，同  ArrayListBlockingQueue  类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue   可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而  LinkedBlockingQueue  之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>作为开发者，我们需要注意的是，如果构造一个  LinkedBlockingQueue 对象，而没有指定其容量大小，LinkedBlockingQueue  会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。<br>ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 生产者线程</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Producer implements Runnable &#123;</span><br><span class="line">    </span><br><span class="line">    private volatile boolean  isRunning &#x3D; true;&#x2F;&#x2F;是否在运行标志</span><br><span class="line">    private BlockingQueue queue;&#x2F;&#x2F;阻塞队列</span><br><span class="line">    private static AtomicInteger count &#x3D; new AtomicInteger();&#x2F;&#x2F;自动更新的值</span><br><span class="line">    private static final int DEFAULT_RANGE_FOR_SLEEP &#x3D; 1000;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    public Producer(BlockingQueue queue) &#123;</span><br><span class="line">        this.queue &#x3D; queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String data &#x3D; null;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;启动生产者线程！&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            while (isRunning) &#123;</span><br><span class="line">                System.out.println(&quot;正在生产数据...&quot;);</span><br><span class="line">                Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));&#x2F;&#x2F;取0~DEFAULT_RANGE_FOR_SLEEP值的一个随机数</span><br><span class="line"> </span><br><span class="line">                data &#x3D; &quot;data:&quot; + count.incrementAndGet();&#x2F;&#x2F;以原子方式将count当前值加1</span><br><span class="line">                System.out.println(&quot;将数据：&quot; + data + &quot;放入队列...&quot;);</span><br><span class="line">                if (!queue.offer(data, 2, TimeUnit.SECONDS)) &#123;&#x2F;&#x2F;设定的等待时间为2s，如果超过2s还没加进去返回true</span><br><span class="line">                    System.out.println(&quot;放入数据失败：&quot; + data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;退出生产者线程！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        isRunning &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 消费者线程</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line">    </span><br><span class="line">    private BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    private static final int DEFAULT_RANGE_FOR_SLEEP &#x3D; 1000;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    public Consumer(BlockingQueue&lt;String&gt; queue) &#123;</span><br><span class="line">        this.queue &#x3D; queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;启动消费者线程！&quot;);</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        boolean isRunning &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (isRunning) &#123;</span><br><span class="line">                System.out.println(&quot;正从队列获取数据...&quot;);</span><br><span class="line">                String data &#x3D; queue.poll(2, TimeUnit.SECONDS);&#x2F;&#x2F;有数据时直接从队列的队首取走，无数据时阻塞，在2s内有数据，取走，超过2s还没数据，返回失败</span><br><span class="line">                if (null !&#x3D; data) &#123;</span><br><span class="line">                    System.out.println(&quot;拿到数据：&quot; + data);</span><br><span class="line">                    System.out.println(&quot;正在消费数据：&quot; + data);</span><br><span class="line">                    Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。</span><br><span class="line">                    isRunning &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;退出消费者线程！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue; </span><br><span class="line"></span><br><span class="line">public class BlockingQueueTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 声明一个容量为10的缓存队列</span><br><span class="line">        BlockingQueue&lt;String&gt; queue &#x3D; new LinkedBlockingQueue&lt;String&gt;(10);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;new了三个生产者和一个消费者</span><br><span class="line">        Producer producer1 &#x3D; new Producer(queue);</span><br><span class="line">        Producer producer2 &#x3D; new Producer(queue);</span><br><span class="line">        Producer producer3 &#x3D; new Producer(queue);</span><br><span class="line">        Consumer consumer &#x3D; new Consumer(queue);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 借助Executors</span><br><span class="line">        ExecutorService service &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        &#x2F;&#x2F; 启动线程</span><br><span class="line">        service.execute(producer1);</span><br><span class="line">        service.execute(producer2);</span><br><span class="line">        service.execute(producer3);</span><br><span class="line">        service.execute(consumer);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 执行10s</span><br><span class="line">        Thread.sleep(10 * 1000);</span><br><span class="line">        producer1.stop();</span><br><span class="line">        producer2.stop();</span><br><span class="line">        producer3.stop();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        &#x2F;&#x2F; 退出Executor</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br>使用场景：<br>DelayQueue 使用场景较少，但都相当巧妙，常见的例子比如使用一个 DelayQueue 来管理一个超时未响应的连接队列。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的  Compator 对象来决定），但需要注意的是 PriorityBlockingQueue  并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现  PriorityBlockingQueue 时，内部控制线程同步的锁采用的是公平锁。</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的  BlockingQueue  来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p>
<p>声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:</p>
<p>如果采用公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</p>
<p>但如果是非公平模式（SynchronousQueue  默认）：SynchronousQueue 采用非公平锁，同时配合一个 LIFO  队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发知识点总结</title>
    <url>/2020/04/08/thread/</url>
    <content><![CDATA[<h1 id="一、线程状态转换"><a href="#一、线程状态转换" class="headerlink" title="一、线程状态转换"></a>一、线程状态转换</h1><p><img src="/img/thread/adfb427d-3b21-40d7-a142-757f4ed73079.png" alt="adfb427d-3b21-40d7-a142-757f4ed73079"></p>
 <a id="more"></a>

<h2 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h2><p>创建后尚未启动。</p>
<h2 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h2><p>可能正在运行，也可能正在等待 CPU 时间片。</p>
<p>包含了操作系统线程状态中的 Running 和 Ready。</p>
<h2 id="阻塞（Blocked）"><a href="#阻塞（Blocked）" class="headerlink" title="阻塞（Blocked）"></a>阻塞（Blocked）</h2><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p>
<h2 id="无限期等待（Waiting）"><a href="#无限期等待（Waiting）" class="headerlink" title="无限期等待（Waiting）"></a>无限期等待（Waiting）</h2><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h2 id="限期等待（Timed-Waiting）"><a href="#限期等待（Timed-Waiting）" class="headerlink" title="限期等待（Timed Waiting）"></a>限期等待（Timed Waiting）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p>
<p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h2 id="死亡（Terminated）"><a href="#死亡（Terminated）" class="headerlink" title="死亡（Terminated）"></a>死亡（Terminated）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>
<h1 id="二、使用线程"><a href="#二、使用线程" class="headerlink" title="二、使用线程"></a>二、使用线程</h1><p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p>需要实现 run() 方法。</p>
<p>通过 Thread 调用 start() 方法来启动线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable instance &#x3D; new MyRunnable();</span><br><span class="line">    Thread thread &#x3D; new Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public Integer call() &#123;</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    MyCallable mc &#x3D; new MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread &#x3D; new Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyThread mt &#x3D; new MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<h1 id="三、基础线程机制"><a href="#三、基础线程机制" class="headerlink" title="三、基础线程机制"></a>三、基础线程机制</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>常用线程池如下：</p>
<ol>
<li><p><code>newFixedThreadPool(int nThreads)</code> ：指定工作线程数量的线程池。</p>
</li>
<li><p><code>newCachedThreadPool()</code> ：一个任务创建一个线程；常用于处理大量短时间工作任务的线程池。</p>
<p>(1) 试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程。</p>
<p>(2) 如果线程闲置的时间超过阈值，则会被终止并移除缓存。</p>
<p>(3) 系统长时间闲置的时候，不会消耗什么资源。</p>
</li>
<li><p><code>newSingleThreadExecutor()</code> ：相当于大小为 1 的 FixedThreadPool，创建唯一的工作者线程来执行任务，如果线程异常结束，会有另外一个线程取代它。</p>
</li>
<li><p><code>newSingleThreadScheduledExecutor()</code> 和<code>newScheduledThreadPool(int corePoolSize)</code>：定时或者周期性的工作调度，两者的区别在于单一工作线程还是多个线程。</p>
</li>
<li><p><code>newWorkStealingPool()</code> ：内部会构建ForkJoinPool，利用working-stealing算法，并行的处理任务，不保证处理顺序。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        executorService.execute(new MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main() 属于非守护线程。</p>
<p>使用 setDaemon() 方法将一个线程设置为守护线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread thread &#x3D; new Thread(new MyRunnable());</span><br><span class="line">    thread.setDaemon(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class InterruptExample &#123;</span><br><span class="line"></span><br><span class="line">    private static class MyThread1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                System.out.println(&quot;Thread run&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread1 &#x3D; new MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(&quot;Main run&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$0(InterruptExample.java:5)</span><br><span class="line">    at InterruptExample$$Lambda$1&#x2F;713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class InterruptExample &#123;</span><br><span class="line"></span><br><span class="line">    private static class MyThread2 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!interrupted()) &#123;</span><br><span class="line">                &#x2F;&#x2F; ..</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Thread end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread2 &#x3D; new MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread end</span><br></pre></td></tr></table></figure>

<h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            System.out.println(&quot;Thread run&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(&quot;Main run&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$1&#x2F;1160460865.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; future &#x3D; executorService.submit(() -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; ..</span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(true);</span><br></pre></td></tr></table></figure>

<h1 id="五、互斥同步"><a href="#五、互斥同步" class="headerlink" title="五、互斥同步"></a>五、互斥同步</h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>1. 同步一个代码块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void func() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SynchronizedExample &#123;</span><br><span class="line"></span><br><span class="line">    public void func1() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SynchronizedExample e1 &#x3D; new SynchronizedExample();</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SynchronizedExample e1 &#x3D; new SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 &#x3D; new SynchronizedExample();</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br></pre></td></tr></table></figure>

<p><strong>2. 同步一个方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void func () &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和同步代码块一样，作用于同一个对象。</p>
<p><strong>3. 同步一个类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void func() &#123;</span><br><span class="line">    synchronized (SynchronizedExample.class) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SynchronizedExample &#123;</span><br><span class="line"></span><br><span class="line">    public void func2() &#123;</span><br><span class="line">        synchronized (SynchronizedExample.class) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SynchronizedExample e1 &#x3D; new SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 &#x3D; new SynchronizedExample();</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p><strong>4. 同步一个静态方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized static void fun() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LockExample &#123;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void func() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock(); &#x2F;&#x2F; 确保释放锁，从而避免发生死锁。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    LockExample lockExample &#x3D; new LockExample();</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><p>除非需要使用  ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM  实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized  不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h1 id="六、线程之间的协作"><a href="#六、线程之间的协作" class="headerlink" title="六、线程之间的协作"></a>六、线程之间的协作</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JoinExample &#123;</span><br><span class="line"></span><br><span class="line">    private class A extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;A&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class B extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            this.a &#x3D; a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;B&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        A a &#x3D; new A();</span><br><span class="line">        B b &#x3D; new B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    JoinExample example &#x3D; new JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<p>它们都属于 Object 的一部分，而不属于 Thread。</p>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WaitNotifyExample &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void before() &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void after() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example &#x3D; new WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<p><strong>wait() 和 sleep() 的区别</strong></p>
<ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>wait() 会释放锁，sleep() 不会。</li>
</ul>
<h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AwaitSignalExample &#123;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    private Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void before() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;before&quot;);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void after() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(&quot;after&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example &#x3D; new AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<h1 id="七、J-U-C-AQS"><a href="#七、J-U-C-AQS" class="headerlink" title="七、J.U.C - AQS"></a>七、J.U.C - AQS</h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用来控制一个线程等待多个线程。</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CountdownLatchExample &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final int totalThread &#x3D; 10;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(&quot;run..&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;&#x3D; 0) throw new IllegalArgumentException();</span><br><span class="line">    this.parties &#x3D; parties;</span><br><span class="line">    this.count &#x3D; parties;</span><br><span class="line">    this.barrierCommand &#x3D; barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierExample &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int totalThread &#x3D; 10;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(&quot;before..&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(&quot;after..&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SemaphoreExample &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int clientCount &#x3D; 3;</span><br><span class="line">        final int totalRequestCount &#x3D; 10;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + &quot; &quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 2 2 2 2 2 1 2 2</span><br></pre></td></tr></table></figure>

<h1 id="八、J-U-C-其它组件"><a href="#八、J-U-C-其它组件" class="headerlink" title="八、J.U.C - 其它组件"></a>八、J.U.C - 其它组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍  Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture  接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureTaskExample &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                int result &#x3D; 0;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">                    Thread.sleep(10);</span><br><span class="line">                    result +&#x3D; i;</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread &#x3D; new Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;other task is running...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">other task is running...</span><br><span class="line">4950</span><br></pre></td></tr></table></figure>

<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p>
<ul>
<li><strong>FIFO 队列</strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li><strong>优先级队列</strong> ：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p>
<p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerConsumer &#123;</span><br><span class="line"></span><br><span class="line">    private static BlockingQueue&lt;String&gt; queue &#x3D; new ArrayBlockingQueue&lt;&gt;(5);</span><br><span class="line"></span><br><span class="line">    private static class Producer extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                queue.put(&quot;product&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot;produce..&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Consumer extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String product &#x3D; queue.take();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot;consume..&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">        Producer producer &#x3D; new Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        Consumer consumer &#x3D; new Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        Producer producer &#x3D; new Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</span><br></pre></td></tr></table></figure>

<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int threshold &#x3D; 5;</span><br><span class="line">    private int first;</span><br><span class="line">    private int last;</span><br><span class="line"></span><br><span class="line">    public ForkJoinExample(int first, int last) &#123;</span><br><span class="line">        this.first &#x3D; first;</span><br><span class="line">        this.last &#x3D; last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        if (last - first &lt;&#x3D; threshold) &#123;</span><br><span class="line">            &#x2F;&#x2F; 任务足够小则直接计算</span><br><span class="line">            for (int i &#x3D; first; i &lt;&#x3D; last; i++) &#123;</span><br><span class="line">                result +&#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 拆分成小任务</span><br><span class="line">            int middle &#x3D; first + (last - first) &#x2F; 2;</span><br><span class="line">            ForkJoinExample leftTask &#x3D; new ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask &#x3D; new ForkJoinExample(middle + 1, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result &#x3D; leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    ForkJoinExample example &#x3D; new ForkJoinExample(1, 10000);</span><br><span class="line">    ForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();</span><br><span class="line">    Future result &#x3D; forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ForkJoinPool extends AbstractExecutorService</span><br></pre></td></tr></table></figure>

<p>ForkJoinPool  实现了工作窃取算法来提高 CPU  的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2  从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2  来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p>
<h1 id="九、线程不安全示例"><a href="#九、线程不安全示例" class="headerlink" title="九、线程不安全示例"></a>九、线程不安全示例</h1><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadUnsafeExample &#123;</span><br><span class="line"></span><br><span class="line">    private int cnt &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int get() &#123;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    final int threadSize &#x3D; 1000;</span><br><span class="line">    ThreadUnsafeExample example &#x3D; new ThreadUnsafeExample();</span><br><span class="line">    final CountDownLatch countDownLatch &#x3D; new CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">997</span><br></pre></td></tr></table></figure>

<h1 id="十、锁优化"><a href="#十、锁优化" class="headerlink" title="十、锁优化"></a>十、锁优化</h1><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String concatString(String s1, String s2, String s3) &#123;</span><br><span class="line">    return s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String concatString(String s1, String s2, String s3) &#123;</span><br><span class="line">    StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString()  方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的  append()  方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个  append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p>
<p><img src="/img/thread/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f62623661343962652d303066322d346632372d613063652d3465643736346263363035632e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f62623661343962652d303066322d346632372d613063652d3465643736346263363035632e706e67"></p>
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p>
<p><img src="/img/thread/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f30353165343336632d306534362d346335392d386636372d3532643839643635363138322e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f30353165343336632d306534362d346335392d386636372d3532643839643635363138322e706e67"></p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为  0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS  操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的  Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<p><img src="/img/thread/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f62616161363831662d376335322d343139382d613561652d3330336239333836636634372e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f62616161363831662d376335322d343139382d613561652d3330336239333836636634372e706e67"></p>
<p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word  是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p>
<p><img src="/img/thread/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f33393063393133622d356633312d343434662d626264622d3262383862363838653763652e6a7067.jpg" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f33393063393133622d356633312d343434662d626264622d3262383862363838653763652e6a7067"></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的线程池分析</title>
    <url>/2020/04/20/threadPool/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。在开发过程中，合理使用线程池可以带来以下好处：</p>
<p>​     Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。在开发过程中，合理使用线程池可以带来以下好处：</p>
<ol>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ol>
<a id="more"></a>

<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>我们可以通过 ThreadPoolExecutor 来创建一个线程池，构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.acc &#x3D; System.getSecurityManager() &#x3D;&#x3D; null ?</span><br><span class="line">            null :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建一个线程池需要输入的参数"><a href="#创建一个线程池需要输入的参数" class="headerlink" title="创建一个线程池需要输入的参数"></a>创建一个线程池需要输入的参数</h3><ul>
<li>corePoolSize：核心线程数量，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建线程，等到需要执行的任务数大于  corePoolSize 时就不再创建。如果调用了线程池的 prestartAllCoreThreads()  方法，线程池会提前创建并启动所有基本线程。</li>
<li>maximumPoolSize：最大线程数量，当线程池中线程数量达到 corePoolSize 时，如果工作队列中还有任务提交进来，那么就继续创建线程直到线程数量达到 maximumPoolSize 后就不再创建线程。</li>
<li>keepAliveTime：线程池中的非核心线程（即超过核心线程数量的线程）在没有任务执行而空闲后，能够保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
<li>TimeUnit：keepAliveTime  的单位，可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒 (MILLISECONDS)，微秒  (MICROSECONDS, 千分之一毫秒) 和毫微秒 (NANOSECONDS, 千分之一微秒)。</li>
<li>workQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个<strong>阻塞队列</strong>：</li>
<li></li>
</ul>
<table>
<thead>
<tr>
<th align="center">阻塞队列</th>
<th align="center">队列简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayBlockingQueue</td>
<td align="center">是一个基于数组结构的有界阻塞队列，此 队列按 FIFO（先进先出）原则对元素进行排序。</td>
</tr>
<tr>
<td align="center">LinkedBlockingQueue</td>
<td align="center">一个基于链表结构的阻塞队列，此队列按 FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool()使用了这个队列。</td>
</tr>
<tr>
<td align="center">SynchronousQueue</td>
<td align="center">一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool() 使用了这个队列。</td>
</tr>
<tr>
<td align="center">PriorityBlockingQueue</td>
<td align="center">一个具有优先级的无限阻塞队列。maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</td>
</tr>
</tbody></table>
<ul>
<li>ThreadFactory ：创建线程的工厂，一般不设置的话默认为采用 DefaultThreadFactory，如果需要设置线程优先级、守护线程等可以采用其它线程工厂或者自定义线程工厂。</li>
<li>RejectedExecutionHandler：饱和策略，当队列中任务和线程池中线程数量都达到最大时，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是  AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK 1.5 提供的四种策略：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">策略名称</th>
<th align="center">策略简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AbortPolicy</td>
<td align="center">直接抛出异常</td>
</tr>
<tr>
<td align="center">CallerRunsPolicy</td>
<td align="center">只用调用者所在线程来运行任务。</td>
</tr>
<tr>
<td align="center">DiscardOldestPolicy</td>
<td align="center">丢弃队列里最近的一个任务，并执行当前任务。</td>
</tr>
<tr>
<td align="center">DiscardPolicy</td>
<td align="center">不处理，丢弃掉。</td>
</tr>
</tbody></table>
<p>当然也可以根据应用场景需要来实现 <code>RejectedExecutionHandler</code>接口自定义策略。如记录日志或持久化不能处理的任务。</p>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a><strong>向线程池提交任务</strong></h3><p>我们可以使用 execute 提交的任务，但是 execute 方法没有返回值，所以无法判断任务是否被线程池执行成功。通过以下代码可知 execute 方法输入的任务是一个 Runnable 类的实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threadsPool.execute(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们也可以使用 submit 方法来提交任务，它会返回一个 future 对象, 那么我们可以通过这个 future  对象来判断任务是否执行成功，通过 future 的 get() 方法来获取返回值，get() 方法会阻塞住直到任务完成，而使用 get(long  timeout, TimeUnit unit) 方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Future&lt;Object&gt; future &#x3D; executor.submit(harReturnValuetask);&#96;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a><strong>线程池的关闭</strong></h3><p>我们可以通过调用线程池的 shutdown 或  shutdownNow 方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt  方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow 首先将线程池的状态设置成  STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而 shutdown 只是将线程池的状态设置成 SHUTDOWN  状态，然后中断所有没有正在执行任务的线程。</p>
<p>只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回  true。当所有的任务都已关闭后, 才表示线程池关闭成功，这时调用 isTerminaed 方法会返回  true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown  来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。</p>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>线程池的主要处理流程图如下，用户使用时需要进行提交任务即可。</p>
<p><img src="/img/threadPool/handler.png" alt="handler"></p>
<p>从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ol>
<li>首先线程池判断<strong>基本线程池</strong>是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</li>
<li>其次线程池判断<strong>工作队列</strong>是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</li>
<li>最后线程池判断<strong>整个线程池</strong>是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</li>
</ol>
<p><img src="/img/threadPool/liuchen.png" alt="liuchen"></p>
<p>ThreadPoolExecutor 执行 execute 方法分为下面4种情况：</p>
<ol>
<li>如果当前允许的线程少于 corePoolSize ，则创建新线程来执行任务（注意，执行这一任务需要获取全局锁）。</li>
<li>如果运行的线程等于或多于 corePoolSize，则尝试将任务加入 BlockingQueue。</li>
<li>如果无法将任务加入 BlockingQueue，即队列已满，则尝试创建新的线程来执行任务（执行这一步骤也需要获取全局锁）。</li>
<li>如果创建新线程使当前运行的线程超出 maximumPoolSize，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ol>
<p>ThreadPoolExecutor  采用上述步骤的总体设计思路，是为了在执行 execute() 方法时，尽可能地避免获取全局锁（那将会是一个严重的性能瓶颈）。在  ThreadPoolExecutor 完成预热之后（当前运行的线程数大于等于 corePoolSize ），几乎所有的 execute()  方法调用都是执行步骤 2，而步骤 2 不需要获取全局锁。</p>
<p><strong>源码分析</strong>。上面的流程分析让我们很直观的了解了线程池的工作原理，让我们再通过源代码来看看是如何实现的。线程池执行任务的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#x2F;&#x2F; 如果线程数小于基本线程数，则创建线程并执行当前任务 </span><br><span class="line">    if (poolSize &gt;&#x3D; corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span><br><span class="line">        if (runState &#x3D;&#x3D; RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            if (runState !&#x3D; RUNNING || poolSize &#x3D;&#x3D; 0)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，则创建一个线程执行任务。</span><br><span class="line">        else if (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            &#x2F;&#x2F; 抛出 RejectedExecutionException 异常 </span><br><span class="line">            reject(command); &#x2F;&#x2F; is shutdown or saturated</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作线程</strong>。线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后，还会无限循环获取工作队列里的任务来执行。我们可以从 Worker 的 run 方法里看到这点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Runnable task &#x3D; firstTask;</span><br><span class="line">        firstTask &#x3D; null;</span><br><span class="line">        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">            runTask(task);</span><br><span class="line">            task &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        workerDone(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h2><p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>
<ol>
<li>任务的性质：CPU 密集型任务，IO 密集型任务和混合型任务。</li>
<li>任务的优先级：高，中和低。</li>
<li>任务的执行时间：长，中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ol>
<p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU 密集型任务配置尽可能小的线程，如配置 Ncpu+1 个线程的线程池。IO 密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如 <code>2*Ncpu</code>。混合型的任务，如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过 <code>Runtime.getRuntime().availableProcessors()</code>方法获得当前设备的 CPU 个数。</p>
<p>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，如果等待的时间越长 CPU 空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用 CPU。</p>
<p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行  SQL  变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于 taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize: 线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不 减。</li>
<li>getActiveCount：获取活动的线程数。</li>
</ul>
<p>通过扩展线程池进行监控。通过继承线程池并重写线程池的  beforeExecute，afterExecute 和 terminated  方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;protected void beforeExecute(Thread t, Runnable r) &#123; &#125;&#96;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantReadWriteLock读写锁源码分析</title>
    <url>/2020/05/03/ReentrantReadWriteLock/</url>
    <content><![CDATA[<h3 id="读写锁的概念"><a href="#读写锁的概念" class="headerlink" title="读写锁的概念"></a>读写锁的概念</h3><p>常见的锁（Synchronized 和 Lock  的实现类）基本都是排他锁，同一时刻只允许一个线程进行访问。提起 ReentrantReadWriteLock，不得不想起  ReentrantLock 这个可重入排他锁。实际上这两者之间没有太大关系，都是 Lock 的独立实现。</p>
<p>在介绍原理之前，先简单叙述一下什么是读写锁：</p>
<blockquote>
<p>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其它写线程均被阻塞。具体而言，一个线程要获取读锁的前提条件是：没有其它线程的写锁；没有写请求或者有写请求，但调用线程和持有锁的线程是同一个  。一个线程要获取写锁的前提条件是：没有其它线程的读锁；没有其它线程的写锁。</p>
</blockquote>
<a id="more"></a>

<p>为了表示方便，以下叙述读写锁均指 ReentrantReadWriteLock  这个实现类，读写锁维护了一对锁：读锁和写锁，通过分离读写锁，使得其吞吐量和并发性在某些应用场景下（尤其是读多写少的多线程环境下）较排他锁提升较大。除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁还简化了读写交互场景的编程方式，使其变得更加简单明了。</p>
<p>在没有读写锁支持之前（Java  5  之前），如果要完成这种场景的代码编写，往往需要使用“等待-通知”机制，具体而言，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知后，所有等待的读操作才能继续执行，这样做的目的主要是使读操作能够读到正确的数据，不会出现脏读。而使用读写锁实现上述功能时，只需要在读操作的时候获取读锁，写操作的时候获取写锁就可以了，内部线程等待通知由内部进行实现，留给程序员的接口变得更加方便和直观。</p>
<p>ReentrantReadWriteLock 具备的特性：</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公平性选择</td>
<td align="center">支持非公平（默认）和公平两种锁获取方式</td>
</tr>
<tr>
<td align="center">重进入</td>
<td align="center">支持重进入，读线程获取读锁后，能够再次获取读锁，写线程获取写锁后能再次获取写锁，同时也可以获取读锁</td>
</tr>
<tr>
<td align="center">锁降级</td>
<td align="center">遵循获取写锁、获取读锁再释放写锁的锁降级，写锁能够降级为读锁</td>
</tr>
</tbody></table>
<h3 id="读写锁的接口和示例"><a href="#读写锁的接口和示例" class="headerlink" title="读写锁的接口和示例"></a>读写锁的接口和示例</h3><p>首先看下接口的 ReadWriteLock，这个接口仅定义两个方法：读写 ReadLock() 和写锁 WriteLock()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Lock readLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 ReentrantReadWriteLock 是其实现类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>读写锁中有五个静态内部类：</p>
<ul>
<li>Sync</li>
<li>NonfairSync</li>
<li>FairSync</li>
<li>ReadLock</li>
<li>WriteLock</li>
</ul>
<p>它们之间的关系如下图所示：</p>
<p><img src="/img/ReentrantReadWriteLock/readwritelock.png" alt="readwritelock"></p>
<p>其中 Sync 继承自 AQS，是读写锁实现的核心，关于 AQS 可以参考我的<a href="https://bestzuo.cn/posts/3723625690.html" target="_blank" rel="noopener">另外一篇博客</a>。FairSync 是公平锁的底层实现，NonfairSync 是非公平锁的底层实现。</p>
<p>ReentrantReadWriteLock 类中，除了 readLock() 和 writeLock() 的实现方法外，还提供了一些便于外界监控内部工作状态的方法，这些方法和描述如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getReadLockCount()</td>
<td align="center">返回当前读锁被获取的次数，该次数不等于读锁的线程数，因为可重入的原因，一个线程连续获取了 n 次读锁，那么占据该读锁的线程数是 1，但该方法返回 n</td>
</tr>
<tr>
<td align="center">int getReadHoldCount()</td>
<td align="center">返回当前线程获取读锁的次数，该方法在 Java 6 中加入，使用 ThreadLocal 保存当前线程获取的次数，这也使得 Java 6的实现变得更复杂</td>
</tr>
<tr>
<td align="center">boolean isWriteLocked()</td>
<td align="center">判断写锁是否被获取</td>
</tr>
<tr>
<td align="center">int getWriteHoldCount()</td>
<td align="center">返回当前线写锁被获取的次数</td>
</tr>
</tbody></table>
<p>我们可以使用一个例子来表示读写锁的使用方式，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public class Cache&#123;&#96;</span><br></pre></td></tr></table></figure>

<p>上述示例中的 Cache 组合一个非线程安全的 HashMap 作为缓存的实现，同时使用读写锁来保证 Cache 是线程安全的。其中在  get 方法中，需要获取读锁，这使得并发访问该方法时线程不会被阻塞；在 put 方法和 clear 方法中，更新 HashMap  时必须提前获取写锁，并且其它获取读锁和写锁的线程均被阻塞，只有写锁释放后，其它读写操作才能继续进行。</p>
<p>由此可见，使用读写锁提高了多线程环境下读操作的并发性，并且保证了写操作的互斥性和读写操作之间的可见性。尤其是简化了代码的编写方式。</p>
<h3 id="读写锁的源码分析"><a href="#读写锁的源码分析" class="headerlink" title="读写锁的源码分析"></a>读写锁的源码分析</h3><p>了解了常用的使用方法后，我们接下来就需要探析一下读写锁的源码实现和核心思想。</p>
<h4 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h4><p>通过前面分析我们知道，读写锁是依赖 AQS 实现同步功能的，其核心就是读写锁的静态内部类 Sync，其中实现的方法如下：</p>
<p><img src="/img/ReentrantReadWriteLock/sync.png" alt="sync"></p>
<p>我们知道，AQS 实现同步是依赖一个 volatile 修饰的 int 类型的 state 状态变量和一个 CLH 队列，那么要靠这个 int 类型的变量同时表示“读”和“写”状态，就只能按照位切割了。事实上读写锁也是这么去实现的，用高 16 位表示读，低 16 位表示写，其划分方式如下图所示：</p>
<p><img src="/img/ReentrantReadWriteLock/read-write-lock-design.png" alt="read-write-lock-design"></p>
<p>通过位运算可以很快的计算并确定读写锁各自的状态。假设当前同步状态 state 值为 S，写状态就可以表示为 <code>S &amp; 0x0000FFFF</code>（将高 16 位全部抹去），读状态可以表示为<code>S &gt;&gt; 16</code>（无符号补 0 右移 16 位）。当写状态增加 1 时，就可以表示为 <code>S + 1</code>，当读状态增加 1 时，等于 <code>S + (1 &lt;&lt; 16)</code>，也就是<code>S + 0x00010000</code>。</p>
<p>根据状态的划分能得出一个推论： S 不等于 0 时，当写状态（ S &amp; 0x0000FFFF）等于 0 时，则读状态（S &gt;&gt; 16）大于 0，即读锁已被获取。</p>
<h4 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h4><p>写锁的获取入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; WriteLock</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AQS</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F; 尝试获取，获取失败后入队，入队失败则interrupt当前线程</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁的获取依赖<code>tryAcquire()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;protected f&#96;</span><br></pre></td></tr></table></figure>

<p>从源码可以看到写锁是一个支持重进入的排他锁，如果当前线程已经获取到写锁，就增加写状态；如果当前线程在获取写锁时，读锁已经被获取（判断条件是读状态不为 0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p>
<p>为什么存在读锁时，写锁不能被获取呢？这是为了保证写锁的操作对读锁可见，如果允许读锁在已经存在的条件下获取写锁，那么正在运行的其它线程就无法感知到当前线程的写操作。</p>
<p>写锁的释放入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;&#x2F;&#96;</span><br></pre></td></tr></table></figure>

<p>写锁的释放与 ReentrantLock 的释放操作基本一致，这里没有什么好说的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;prote&#96;</span><br></pre></td></tr></table></figure>

<h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p>读锁的获取入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;&#x2F; ReadLockpublic void lock() &#123;    sync.acq&#96;</span><br></pre></td></tr></table></figure>

<p>可以看到依赖于 tryAcquireShared 方法，这个方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;prot&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">    HoldCounter rh &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 最外层嵌套循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        &#x2F;&#x2F; 操作5：存在写锁，且写锁并非当前线程则直接返回失败</span><br><span class="line">        if (exclusiveCount(c) !&#x3D; 0) &#123;</span><br><span class="line">            if (getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line">                return -1;</span><br><span class="line">            &#x2F;&#x2F; else we hold the exclusive lock; blocking here</span><br><span class="line">            &#x2F;&#x2F; would cause deadlock.</span><br><span class="line">            &#x2F;&#x2F; 操作6：如果当前线程是重入读锁则放行</span><br><span class="line">        &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line">            &#x2F;&#x2F; Make sure we&#39;re not acquiring read lock reentrantly</span><br><span class="line">            &#x2F;&#x2F; 当前是firstReader，则直接放行,说明是已获取的线程重入读锁</span><br><span class="line">            if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">                &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行到这里说明是其他线程，如果是cachedHoldCounter（其count不为0）也就是上一个获取锁的线程则可以重入，否则进入AQS中排队</span><br><span class="line">                &#x2F;&#x2F; **这里也是对写锁的让步**，如果队列中头结点为写锁，那么当前获取读锁的线程要进入队列中排队</span><br><span class="line">                if (rh &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    rh &#x3D; cachedHoldCounter;</span><br><span class="line">                    if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current)) &#123;</span><br><span class="line">                        rh &#x3D; readHolds.get();</span><br><span class="line">                        if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 说明是上述刚初始化的rh，所以直接去AQS中排队</span><br><span class="line">                if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sharedCount(c) &#x3D;&#x3D; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        &#x2F;&#x2F; 操作7：修改读锁状态，实际上读锁自增操作</span><br><span class="line">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 操作8：对ThreadLocal中维护的获取锁次数进行更新。</span><br><span class="line">            if (sharedCount(c) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                firstReader &#x3D; current;</span><br><span class="line">                firstReaderHoldCount &#x3D; 1;</span><br><span class="line">            &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh &#x3D;&#x3D; null)</span><br><span class="line">                    rh &#x3D; cachedHoldCounter;</span><br><span class="line">                if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">                    rh &#x3D; readHolds.get();</span><br><span class="line">                else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter &#x3D; rh; &#x2F;&#x2F; cache for release</span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可以看到读锁是一个支持重进入的共享锁，能够被多个线程同时获取，在没有其它写线程访问时，读锁总会被成功获取，所做的也只是增加读状态。如果当前线程已经获取了读锁，则使用 CAS 增加读状态；如果当前线程在获取读锁时，写锁已经被其它线程获取，则进入等待状态。</p>
<p>获取读锁在 JDK1.6 后变得复杂了许多，例如新增了使用 ThreadLocal 的实现的 getReadCount() 方法来返回当前线程获取读锁的次数。</p>
<p>读锁的释放入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;&#x2F; R&#96;</span><br></pre></td></tr></table></figure>

<p>其中释放的具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;prote&#96;</span><br></pre></td></tr></table></figure>

<p>读锁的释放主要是：</p>
<ol>
<li>清理 ThreadLocal 中保存的获取锁数量信息</li>
<li>CAS 修改读锁个数，实际上是自减一</li>
</ol>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>锁降级指的是写锁降级为读锁。</p>
<p>如果当前线程拥有写锁，然后将其释放，最后再获取读锁。这种分段完成的过程不能称为锁降级。锁降级实际上是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。但是从读锁升级到写锁是不可能的。</p>
<p>那么这个锁降级体现在哪里呢？</p>
<p>在 tryAcquireShared 方法和 fullTryAcquireShared 中都有体现，例如下面的判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;if&#96;</span><br></pre></td></tr></table></figure>

<p>面的代码的意思是：当写锁被持有时，如果持有该锁的线程不是当前线程，就返回 “获取锁失败”，反之当前线程可以继续获取读锁。这就称之为锁降级。</p>
<p>用《Java 并发编程的艺术》书中的例子可以说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void processData()&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    if(!update)&#123;</span><br><span class="line">        &#x2F;&#x2F;必须先释放读锁</span><br><span class="line">        readLock.unlock();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;锁降级从写锁获取到开始</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            if(!update)&#123;</span><br><span class="line">                &#x2F;&#x2F;准备数据的流程（略）</span><br><span class="line">                ...</span><br><span class="line">                update &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;锁降级完成，写锁降级为读锁</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;使用数据的流程（略）</span><br><span class="line">        ...</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，当数据发生变更后，update 变量（布尔类型且使用 volatile 修饰）被设置为 false，此时所有访问  processDate() 方法的线程都能感知到变化，但只有一个线程能够获取到写锁，其它线程会被阻塞在读锁和写锁的 unlock()  方法上。当前线程获取写锁完成数据准备后，再获取读锁，随后释放写锁，完成锁降级。<br>那么锁降级的意义是什么？很多书上或者博客上都会解释如下：</p>
<blockquote>
<p>锁降级中读锁的获取是有必要的，主要是为了保证数据的可见性，如果当前线程不获取读锁而直接释放写锁，假设此时另外一个线程（记作线程  T）获取了写锁并修改了数据，那么当前线程无法感知线程 T 的数据更新。如果当前 线程获取读锁，即遵循锁降级的步骤，则线程 T  将会被阻塞，知道当前线程使用数据并释放读锁后，线程 T 才能获取写锁进行数据更新</p>
</blockquote>
<p>不过这里解释的是锁降级步骤中读锁的获取是否有必要，跟锁降级的意义似乎并没有太大的关联。根据参考文章 [4]，作者提出上面这种解释也是存在问题的。<br>上面提到，锁降级中，读锁的获取的目的是 “为了保证数据的可见性”。而得到这个结论的依据是 “如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程 T）获取了写锁并修改了数据，那么当前线程无法感知线程 T 的数据更新”。<br>这里貌似有个漏洞：如果另一个线程获取了写锁（并修改了数据），那么这个锁就被独占了，没有任何其他线程可以读到数据，更不用谈 “感知数据更新”。</p>
<p>作者认为，锁降级说白了就是写锁的一种特殊重入机制。通过这种重入，可以减少一步流程——释放写锁后再次获取读锁。</p>
<p>使用了锁降级，就可以减去释放写锁的步骤。直接获取读锁。效率更高。而且没有线程争用。和 “可见性” 并没有关系。我个人通过阅读源码也觉得该作者的解释更加合理。</p>
<p>用一幅图来展示锁降级：</p>
<p><img src="/img/ReentrantReadWriteLock/4236553-f545a504abde8c2f.png" alt="4236553-f545a504abde8c2f"></p>
<p>总的来说，锁降级就是一种特殊的锁重入机制，JDK 使用 <code>先获取写入锁，然后获取读取锁，最后释放写入锁</code> 这个步骤，是为了提高获取锁的效率，而不是所谓的可见。</p>
<p>最后再总结一下获取锁的逻辑，首先判断写锁释放被持有了，如果被持有了，且是当前线程，使用锁降级，如果没有，读锁正常获取。</p>
<p>获取过程中，会使用 firstReader 和 cachedHoldCounter 提高性能。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>读写锁适用于读多写少的应用场景，相比于其它排他锁可以提升吞吐量</li>
<li>读写锁利用同步状态 state 位切割方式分为读锁和写锁</li>
<li>读锁是共享锁，写锁是排他锁</li>
<li>锁降级有一定争议，但个人认为其意义是提升获取锁的效率</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM虚拟机：Java运行时数据区域</title>
    <url>/2020/05/06/JVM01/</url>
    <content><![CDATA[<h2 id="Java运行时数据区域分析"><a href="#Java运行时数据区域分析" class="headerlink" title="Java运行时数据区域分析"></a>Java运行时数据区域分析</h2><p><code>JDK1.8</code>的<code>JVM</code>运行时数据区域结构模型如下：</p>
<p><img src="/img/JVM/jdk1.8-jvm.png" alt="jdk1.8-jvm"></p>
<a id="more"></a>

<p>我们可以从整体看到，<code>JVM</code>运行时数据区域大致可以分为：程序计数器、Java虚拟机栈、本地方法栈、堆区、元空间、运行时常量池、直接内存等区域。<br>在<code>JDK1.6</code>时，字符串常量池位于永久代的运行时常量池中，从<code>JDK1.7</code>开始，字符串常量池就已经从永久代剥离放入了堆中。<code>JDK1.8</code>开始，元空间取代了永久代，并且放入了本地内存（物理内存）中。</p>
<p>其中，线程隔离的有：</p>
<ul>
<li>程序计数器</li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p>其它的都是线程共享的区域。</p>
<p>下面我们来一一详解其中每部分的作用。</p>
<h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><p>　　程序计数器（Program Counter Register）可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。每个线程都需要有一个独立的程序计数器，因此PC是“线程私有”的。并且这个计数器记录的是正在执行的虚拟机字节码指令的地址（如果是<code>Native</code>本地方法，那么计数器值为<code>Undifined</code>）。</p>
<h3 id="2、Java虚拟机栈"><a href="#2、Java虚拟机栈" class="headerlink" title="2、Java虚拟机栈"></a>2、Java虚拟机栈</h3><p>　　与程序计数器一样，Java虚拟机栈也是线程私有的，并且其生命周期与线程相同。<strong>虚拟机栈描述的是Java方法执行的内存模型</strong>，每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p><img src="/img/JVM/jvm01.jpg" alt="jvm01"></p>
<p>可以通过 <code>-Xss</code> 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -Xss512M HackTheJava</span><br></pre></td></tr></table></figure>

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出<code>StackOverflowError</code>异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<p><img src="/img/JVM/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88.png" alt="本地方法栈"></p>
<p>与Java虚拟机栈一样，本地方法栈区域也会抛出<code>StackOverFlow</code>和<code>OutOfMemoryError</code>异常。</p>
<h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><p>所有对象都在这里分配内存，是垃圾收集的主要区域（GC 堆）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>具体地，也可以细致分为 Eden 区、From Survivor 区和 To Survivor 区。</p>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure>

<h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法去描述为堆的一个逻辑部分，但是它却有一个别名叫做Non0Heap（非堆），目的应该是与Java堆区分开。</p>
<p>不管是永久代还是元数据区都是<code>JVM</code>规范中方法区的实现方式。方法区和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 <code>OutOfMemoryError</code> 异常。为了更容易管理方法区，<strong>从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</strong></p>
<h3 id="6、运行时常量池"><a href="#6、运行时常量池" class="headerlink" title="6、运行时常量池"></a>6、运行时常量池</h3><p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern( )。</p>
<p>在 JDK1.7 之前，字符串常量池包括于运行时常量池中，在其后，字符串常量池被剥离出运行时常量池，放入了堆中，而运行时常量池仍然在方法区（现在称为元空间区）中。</p>
<p>我们可以在不同的JDK版本中验证一下，测试方式是以死循环方式创建字符串常量：</p>
<p>JVM参数配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MaxPermSize&#x3D;10m</span><br><span class="line">-XX:PermSize&#x3D;10m</span><br><span class="line">-Xms100m</span><br><span class="line">-Xmx100m</span><br><span class="line">-XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;publi&#96;</span><br></pre></td></tr></table></figure>

<p>JDK1.6 下运行结果：永久代 OOM 异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;15365&#96;</span><br></pre></td></tr></table></figure>

<p>JDK1.7 下运行结果：堆区 OOM 异常，并且伴随频繁的 FullGC，CPU 一直处于高位运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2252792</span><br><span class="line">2252794</span><br><span class="line">2252796</span><br><span class="line">2252798</span><br><span class="line">*** java.lang.instrument ASSERTION FAILED ***: &quot;!errorOutstanding&quot; with message can&#39;t create name string at ..&#x2F;..&#x2F;..&#x2F;src&#x2F;share&#x2F;instrument&#x2F;JPLISAgent.c line: 807</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.nio.CharBuffer.wrap(CharBuffer.java:369)</span><br><span class="line">	at sun.nio.cs.StreamEncoder.implWrite(StreamEncoder.java:265)</span><br><span class="line">	at sun.nio.cs.StreamEncoder.write(StreamEncoder.java:125)</span><br><span class="line">	at java.io.OutputStreamWriter.write(OutputStreamWriter.java:207)</span><br><span class="line">	at java.io.BufferedWriter.flushBuffer(BufferedWriter.java:129)</span><br><span class="line">	at java.io.PrintStream.write(PrintStream.java:526)</span><br><span class="line">	at java.io.PrintStream.print(PrintStream.java:597)</span><br><span class="line">	at java.io.PrintStream.println(PrintStream.java:736)</span><br><span class="line">	at com.jd.im.StringOomMock.main(StringOomMock.java:16)</span><br></pre></td></tr></table></figure>

<p>JDK1.8下运行结果：与 JDK1.7 一样，都是 OOM 异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2236898</span><br><span class="line">2236900</span><br><span class="line">2236902</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.lang.Integer.toString(Integer.java:403)</span><br><span class="line">	at java.lang.String.valueOf(String.java:3099)</span><br><span class="line">	at java.io.PrintStream.print(PrintStream.java:597)</span><br><span class="line">	at java.io.PrintStream.println(PrintStream.java:736)</span><br><span class="line">	at com.jd.im.StringOomMock.main(StringOomMock.java:16)</span><br></pre></td></tr></table></figure>

<h3 id="7、直接内存"><a href="#7、直接内存" class="headerlink" title="7、直接内存"></a>7、直接内存</h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native  函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer  对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ol>
<li>周志明《深入理解Java虚拟机：JVM高级特性与最佳实战》</li>
<li><a href="https://blog.csdn.net/bruce128/article/details/79357870" target="_blank" rel="noopener">JDK1.8 JVM运行时数据区域划分</a></li>
<li><a href="https://blog.csdn.net/qq_31615049/article/details/81611918" target="_blank" rel="noopener">基于JDK1.8 分析运行时常量池、字符串常量池、各种常量池</a></li>
</ol>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM虚拟机：垃圾收集、内存分配与回收策略</title>
    <url>/2020/05/15/JVM02/</url>
    <content><![CDATA[<p>在<code>JDK1.8</code>中，垃圾回收主要是针对堆区域进行的。因为栈区域中的程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<p>具体而言，栈中的栈帧随着方法的进入和退出而有条不紊的执行着入栈和出栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来的时候就已知的（尽管在运行期会由<code>JIT</code>编译器进行一些优化，但是大体上可以认为是编译器可知的）。因此这些区域的内存分配和回收都具有确定性。而堆区域不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期间才能知道会创建哪些对象，这部分的内存分配和回收都是动态的，并且常量池也在堆区域，因此  GC 主要关注于堆。</p>
<a id="more"></a>

<h3 id="一、判断一个对象是否可以回收"><a href="#一、判断一个对象是否可以回收" class="headerlink" title="一、判断一个对象是否可以回收"></a>一、判断一个对象是否可以回收</h3><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h4><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1 ，引用失效时计数器减 1 。引用计数为 0 时的对象可以被回收。</p>
<ul>
<li>优点：实现简单，判定效率很高</li>
<li>缺点：无法解决对象间循环依赖问题。当两个对象出现循环依赖的情况下，此时引用计数器永远不为 0 ，导致无法对它们进行回收。正是因为循环依赖问题的出现，因此 Java 虚拟机不使用引用计数法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public class Test &#123;&#96;</span><br></pre></td></tr></table></figure>

<h4 id="2-可达性分析法"><a href="#2-可达性分析法" class="headerlink" title="2.可达性分析法"></a>2.可达性分析法</h4><p>以<code>GC Roots</code>为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p><img src="/img/JVM/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="可达性分析"></p>
<p>在<code>JDK1.8</code>中，可作为<code>GC Roots</code>的对象包括以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>常量池中的常量引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ul>
<h4 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3.方法区的回收"></a>3.方法区的回收</h4><p><code>JDK1.8</code>后，对方法区的回收主要是对类的卸载，但是效率很低。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h4 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4.finalize()"></a>4.finalize()</h4><p>类似 C++ 的析构函数，用于关闭外部资源。但是 <code>try-finally</code> 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 <code>finalize()</code> 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 <code>finalize()</code> 方法自救，后面回收时不会再调用该方法。</p>
<h3 id="二、引用类型"><a href="#二、引用类型" class="headerlink" title="二、引用类型"></a>二、引用类型</h3><p>无论是通过引用计数法判断对象的引用数量，还是通过可达性分析法判断对象是否可达，判定对象是否可以被回收都与引用有关。</p>
<p>Java提供了四种强度不同的引用类型。</p>
<h4 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h4><p>被强引用关联的对象不会被回收，一般是使用new创建一个新对象的方法来创建强引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br></pre></td></tr></table></figure>

<h4 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h4><p>软引用是用来描述一些还有用但非必须的对象。对于软引用关联着的对象，只有在内存不够的情况下才会被回收。</p>
<p>在<code>JDK1.2</code>后提供了<code>SoftReference</code>类来创建软引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf &#x3D; new SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;  &#x2F;&#x2F; 使对象只被软引用关联</span><br></pre></td></tr></table></figure>

<h4 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h4><p>弱引用也是来描述非必须对象的，但是它的强度比软引用更弱，被弱引用关联的对象只能存活到下一次GC之前。</p>
<p><code>JDK1.2</code>后可以使用<code>WeakReference</code>来创建弱引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf &#x3D; new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;</span><br></pre></td></tr></table></figure>

<h4 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h4><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p><code>JDK1.2</code>后可以使用 <code>PhantomReference</code> 来创建虚引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf &#x3D; new PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;</span><br></pre></td></tr></table></figure>

<h3 id="三、垃圾回收算法"><a href="#三、垃圾回收算法" class="headerlink" title="三、垃圾回收算法"></a>三、垃圾回收算法</h3><h4 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1.标记-清除"></a>1.标记-清除</h4><p><img src="/img/JVM/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="标记清除"></p>
<p>标记要回收的对象，然后清除。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h4 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2.标记-整理"></a>2.标记-整理</h4><p><img src="/img/JVM/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="标记整理"></p>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3.复制算法"></a>3.复制算法</h4><p><img src="/img/JVM/%E5%A4%8D%E5%88%B6.png" alt="复制"></p>
<p>复制算法将将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 和其中一块 <code>Survivor</code>。在回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活着的对象全部复制到另一块 <code>Survivor</code> 上，最后清理 <code>Eden</code> 和使用过的那一块 <code>Survivor</code>。</p>
<p><code>HotSpot</code> 虚拟机的 <code>Eden</code> 和 <code>Survivor</code> 大小比例默认为 <code>8:1</code>，保证了内存的利用率达到 <code>90%</code>。如果每次回收有多于 <code>10%</code> 的对象存活，那么一块 <code>Survivor</code> 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h4 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4.分代收集"></a>4.分代收集</h4><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h3 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h3><p><code>HotSpot</code>虚拟机中的7个垃圾收集器：</p>
<p><img src="/img/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="垃圾收集器"></p>
<p>连线表示垃圾收集器可以配和使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h4 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h4><p><img src="/img/JVM/serial.jpg" alt="serial"></p>
<p><code>Serial</code> 翻译为串行，也就是说它以串行的方式执行。</p>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p>
<p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 <code>Client</code> 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h4 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h4><p><img src="/img/JVM/parNew.jpg" alt="parNew"></p>
<p>它是 <code>Serial</code> 收集器的多线程版本。</p>
<p>它是 <code>Server</code> 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 <code>Serial</code> 收集器，只有它能与 <code>CMS</code> 收集器配合使用。</p>
<h4 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h4><p>与 <code>ParNew</code> 一样是多线程收集器。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、<code>Eden</code> 和 <code>Survivor</code> 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h4 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h4><p>![serial old](/img/JVM/serial old.jpg)</p>
<p>是 <code>Serial</code> 收集器的老年代版本，也是给 <code>Client</code> 场景下的虚拟机使用。如果用在 <code>Server</code> 场景下，它有两大用途：</p>
<ul>
<li>在 <code>JDK 1.5</code> 以及之前版本（<code>Parallel Old</code> 诞生以前）中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li>
</ul>
<h4 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h4><p>![parallel old](/img/JVM/parallel old.jpg)</p>
<p>是 <code>Parallel Scavenge</code> 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 收集器。</p>
<h4 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h4><p><img src="/img/JVM/cms.jpg" alt="cms"></p>
<p>CMS（Concurrent Mark Sweep），<code>Mark Sweep</code> 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
<ol>
<li>初始标记：仅仅只是标记一下 <code>GC Roots</code> 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 <code>GC Roots Tracing</code> 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ol>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次  GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS  收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 <code>Serial Old</code> 来替代 <code>CMS</code>。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 <code>Full GC</code>。</li>
</ul>
<h4 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h4><p><code>G1</code>（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。<code>HotSpot</code> 开发团队赋予它的使命是未来可以替换掉 <code>CMS</code> 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 <code>G1</code> 可以直接对新生代和老年代一起回收。</p>
<p><img src="/img/JVM/g11.png" alt="g11"></p>
<p><code>G1</code> 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p>![通过引入 <code>Region</code> 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 <code>Region</code> 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 <code>Region</code>，这也是 G1 (Garbage-First) 名称的来由。</p>
<p>每个 <code>Region</code> 都有一个 <code>Remembered Set</code>，用来记录该 <code>Region</code> 对象的引用对象所在的 <code>Region</code>。通过使用 <code>Remembered Set</code>，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="/img/JVM/g13.jpg" alt="g13"></p>
<p><strong>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</strong></p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 <code>Region</code> 中的回收价值和成本进行排序，根据用户所期望的 <code>GC</code> 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ol>
<p><strong>具备如下特点：</strong></p>
<ul>
<li>并行与并发：G1 能够利用多CPU、多核优势，缩短 STW（Stop The World）的时间，部分其它收集器原本需要停顿 Java 线程执行的 GC 操作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</li>
<li>分代收集： 分代概念在 G1 中仍然保留，虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它仍然能够采取不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的效果。</li>
<li>空间整合：整体来看是基于 标记 - 整理 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 复制 算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h3 id="五、内存分配与回收策略"><a href="#五、内存分配与回收策略" class="headerlink" title="五、内存分配与回收策略"></a>五、内存分配与回收策略</h3><h4 id="1-Minor-GC与Full-GC"><a href="#1-Minor-GC与Full-GC" class="headerlink" title="1.Minor GC与Full GC"></a>1.Minor GC与Full GC</h4><ul>
<li><code>Minor GC</code>：指发生在新生代上的垃圾收集动作，因为新生代对象存活时间很短，因此 <code>Minor GC</code> 会频繁执行，执行的速度一般也会比较快。</li>
<li><code>Full GC</code>（<code>Major GC</code>）：指发生在老年代的GC，出现了<code>Major GC</code>，经常会伴随至少一次的<code>Minor GC</code>（但非绝对，在<code>Parallel Scavenge</code>收集器的收集策略中就有直接进行<code>Major GC</code>的策略选择过程）。<code>Major GC</code>的速度一般会比<code>Minor GC</code>慢10倍以上。</li>
</ul>
<h4 id="2-内存分配策略"><a href="#2-内存分配策略" class="headerlink" title="2.内存分配策略"></a>2.内存分配策略</h4><ul>
<li>对象优先在<code>Eden</code>分配</li>
</ul>
<p>大多数情况下，对象在新生代 <code>Eden</code> 区分配，当 <code>Eden</code> 区空间不够时，发起 <code>Minor GC</code>。</p>
<ul>
<li>大对象直接进入老年代</li>
</ul>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p><code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在 <code>Eden</code> 区和 <code>Survivor</code> 区之间的大量内存复制。</p>
<ul>
<li>长期存活的对象进入老年代</li>
</ul>
<p>为对象定义年龄计数器，对象在 <code>Eden</code> 出生并经过 <code>Minor GC</code> 依然存活，将移动到 <code>Survivor</code> 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p><code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值。</p>
<ul>
<li>动态对象年龄判定</li>
</ul>
<p>虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 <code>Survivor</code> 中相同年龄所有对象大小的总和大于 <code>Survivor</code> 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p>
<ul>
<li>空间分配担保</li>
</ul>
<p>在发生 <code>Minor GC</code> 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 <code>Minor GC</code> 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 <code>Minor GC</code>；如果小于，或者 <code>HandlePromotionFailure</code> 设置不允许冒险，那么就要进行一次 <code>Full GC</code>。</p>
<h4 id="3-Full-GC的触发条件"><a href="#3-Full-GC的触发条件" class="headerlink" title="3.Full GC的触发条件"></a>3.Full GC的触发条件</h4><p>对于 <code>Minor GC</code>，其触发条件非常简单，当 <code>Eden</code> 空间满时，就将触发一次 <code>Minor GC</code>。而 <code>Full GC</code> 则相对复杂，有以下条件：</p>
<ul>
<li>调用System.gc( )</li>
</ul>
<p>只是建议虚拟机执行 <code>Full GC</code>，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<ul>
<li>老年代空间不足</li>
</ul>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 <code>Full GC</code>，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 <code>-Xmn</code> 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code>调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<ul>
<li>空间分配担保失败</li>
</ul>
<p>使用复制算法的 <code>Minor GC</code> 需要老年代的内存空间作担保，如果担保失败会执行一次 <code>Full GC</code>。具体内容请参考上面的第五小节。</p>
<ul>
<li>JDK1.7及以前的永久代空间不足</li>
</ul>
<p>在 <code>JDK 1.7</code> 及以前，<code>HotSpot</code> 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 <code>CMS GC</code> 的情况下也会执行 <code>Full GC</code>。如果经过 <code>Full GC</code> 仍然回收不了，那么虚拟机会抛出 <code>java.lang.OutOfMemoryError</code>。</p>
<p>为避免以上原因引起的 <code>Full GC</code>，可采用的方法为增大永久代空间或转为使用 <code>CMS GC</code>。</p>
<ul>
<li>Concurrent Mode Failure</li>
</ul>
<p>执行 <code>CMS GC</code> 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 <code>Concurrent Mode Failure</code> 错误，并触发 <code>Full GC</code>。</p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM虚拟机：类加载机制</title>
    <url>/2020/05/17/JVM03/</url>
    <content><![CDATA[<p>类是在运行期间第一次使用时动态加载的，而不是一次性加载。因为如果一次性加载，那么会占用很多的内存。 并且根据动态加载的特性，用户可以通过 Java 预定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或者其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已经广泛应用于<br>Java 程序之中，从最基础的 Applet 、 JSP 到相对复杂的 OSGI 技术，都是利用了 Java 运行时动态加载的特性。</p>
<h3 id="一、类的生命周期"><a href="#一、类的生命周期" class="headerlink" title="一、类的生命周期"></a>一、类的生命周期</h3><p><img src="/img/JVM/%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F.jpg" alt="类的声明周期"></p>
<a id="more"></a>

<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h3 id="二、类加载过程"><a href="#二、类加载过程" class="headerlink" title="二、类加载过程"></a>二、类加载过程</h3><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在<code>java.lang.reflect.Proxy</code>使用<code>ProxyGenerator.generateProxyClass</code>的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><p>确保 <code>Class</code> 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><p>类变量是被<code>static</code>修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int value &#x3D; 123;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final int value &#x3D; 123;</span><br></pre></td></tr></table></figure>

<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h4><p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h4><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器() 方法的过程。</p>
<p>在准备阶段，已经为类变量分配了系统所需的初始值，并且在初始化阶段，根据程序员通过程序进行的主观计划来初始化类变量和其他资源。</p>
<p><code>&lt;clinit&gt;()</code> 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i &#x3D; 0;                &#x2F;&#x2F; 给变量赋值可以正常编译通过</span><br><span class="line">        System.out.print(i);  &#x2F;&#x2F; 这句编译器会提示“非法向前引用”</span><br><span class="line">    &#125;</span><br><span class="line">    static int i &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父类的() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Parent &#123;</span><br><span class="line">    public static int A &#x3D; 1;</span><br><span class="line">    static &#123;</span><br><span class="line">        A &#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Sub extends Parent &#123;</span><br><span class="line">    public static int B &#x3D; A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     System.out.println(Sub.B);  &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</p>
<p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其它线程都会阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h3 id="三、类初始化时机"><a href="#三、类初始化时机" class="headerlink" title="三、类初始化时机"></a>三、类初始化时机</h3><h4 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1.主动引用"></a>1.主动引用</h4><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>
<ul>
<li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code> 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 <code>new</code> 关键字实例化对象的时候；读取或设置一个类的静态字段（被 <code>final</code> 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个主类；</li>
<li>当使用 <code>JDK 1.7</code> 的动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果为 <code>REF_getStatic</code>, <code>REF_putStatic</code>, <code>REF_invokeStatic</code> 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li>
</ul>
<h4 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2.被动引用"></a>2.被动引用</h4><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(SubClass.value);  &#x2F;&#x2F; value 字段在 SuperClass 中定义</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 <code>Object</code> 的子类，其中包含了数组的属性和方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SuperClass[] sca &#x3D; new SuperClass[10];</span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<h3 id="四、类与类加载器"><a href="#四、类与类加载器" class="headerlink" title="四、类与类加载器"></a>四、类与类加载器</h3><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 <code>equals()</code> 方法、<code>isAssignableFrom()</code> 方法、<code>isInstance()</code> 方法的返回结果为 <code>true</code>，也包括使用 <code>instanceof</code> 关键字做对象所属关系判定结果为 <code>true</code>。</p>
<h3 id="五、类加载分类"><a href="#五、类加载分类" class="headerlink" title="五、类加载分类"></a>五、类加载分类</h3><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ol>
<li><strong>启动类加载器</strong>（<code>Bootstrap ClassLoader</code>）：使用 C++ 实现，是虚拟机自身的一部分；</li>
<li>所有其它类加载器：使用 Java 实现，独立于虚拟机，继承自抽象类 <code>java.lang.ClassLoader</code>。</li>
</ol>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ol>
<li><strong>启动类加载器</strong>（<code>Bootstrap ClassLoader</code>）此类加载器负责将存放在 <code>&lt;JRE_HOME&gt;\lib</code> 目录中的，或者被<code>-Xbootclasspath</code> 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 <code>rt.jar</code>，名字不符合的类库即使放在 <code>lib</code> 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 <code>null</code> 代替即可。</li>
<li><strong>扩展类加载器</strong>（<code>Extension ClassLoader</code>）这个类加载器是由<code>ExtClassLoader</code>实现的。它负责将 <code>&lt;JAVA_HOME&gt;/lib/ext</code> 或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器</strong>（<code>Application ClassLoader</code>）这个类加载器是由 <code>AppClassLoader</code>实现的。由于这个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（<code>ClassPath</code>）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<h3 id="六、双亲委派模型"><a href="#六、双亲委派模型" class="headerlink" title="六、双亲委派模型"></a>六、双亲委派模型</h3><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents  Delegation  Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。类加载器之间的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<p><img src="/img/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="双亲委派"></p>
<h4 id="1-工作过程"><a href="#1-工作过程" class="headerlink" title="1. 工作过程"></a>1. 工作过程</h4><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<h4 id="2-好处"><a href="#2-好处" class="headerlink" title="2. 好处"></a>2. 好处</h4><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一，同时也避免了类的重复加载。</p>
<p>例如 <code>java.lang.Object</code> 存放在 <code>rt.jar</code> 中，如果编写另外一个 <code>java.lang.Object</code> 并放到 <code>ClassPath</code> 中，程序可以编译通过。由于双亲委派模型的存在，所以在 <code>rt.jar</code> 中的 <code>Object</code> 比在 <code>ClassPath</code> 中的 <code>Object</code> 优先级更高，这是因为 <code>rt.jar</code> 中的 <code>Object</code> 使用的是启动类加载器，而 <code>ClassPath</code> 中的 <code>Object</code> 使用的是应用程序类加载器。<code>rt.jar</code> 中的 <code>Object</code> 优先级更高，那么程序中所有的 <code>Object</code> 都是这个 <code>Object</code>。</p>
<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h4><p>以下是抽象类 <code>java.lang.ClassLoader</code> 的代码片段，其中的 <code>loadClass()</code> 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 <code>ClassNotFoundException</code>，此时尝试自己去加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class ClassLoader &#123;</span><br><span class="line">    &#x2F;&#x2F; The parent class loader for delegation</span><br><span class="line">    private final ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            &#x2F;&#x2F; First, check if the class has already been loaded</span><br><span class="line">            Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                    &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If still not found, then invoke findClass in order</span><br><span class="line">                    &#x2F;&#x2F; to find the class.</span><br><span class="line">                    c &#x3D; findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、自定义类加载器的实现"><a href="#七、自定义类加载器的实现" class="headerlink" title="七、自定义类加载器的实现"></a>七、自定义类加载器的实现</h3><p>为什么要实现自定义类加载器？原因如下：</p>
<ol>
<li>加密：  Java 代码可以轻易的被反编译，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码以某种加密算法加密，类加密后就不能再用  Java 的 ClassLoader 去加载类了，这时就需要自定义 ClassLoader 在加载类的时候先解密类，然后再加载类。</li>
<li>从非标准的来源加载代码：如果你的字节码是放在数据库甚至是云端，就可以自定义类加载器，从指定的来源加载类。</li>
<li>以上两种情况的综合运用：比如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节码，接着进行解密和验证，最后定义出 Java 虚拟机中运行的类。</li>
</ol>
<p><code>FileSystemClassLoader</code> 是自定义类加载器，继承自 <code>java.lang.ClassLoader</code>，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 <code>defineClass()</code> 方法来把这些字节代码转换成 <code>java.lang.Class</code> 类的实例。</p>
<p><code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 <code>findClass()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public class Fi&#96;</span><br></pre></td></tr></table></figure>



<h3 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h3><ol>
<li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener">Chapter 2. The Structure of the Java Virtual Machine</a></li>
<li><a href="https://www.slideshare.net/benewu/jvm-memory" target="_blank" rel="noopener">Jvm memory</a></li>
<li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a></li>
<li><a href="http://electrofriends.com/articles/jni/jni-part1-java-native-interface/" target="_blank" rel="noopener">JNI Part1: Java Native Interface Introduction and “Hello World” application</a></li>
<li><a href="https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/" target="_blank" rel="noopener">Memory Architecture Of JVM(Runtime Data Areas)</a></li>
<li><a href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/" target="_blank" rel="noopener">JVM Run-Time Data Areas</a></li>
<li><a href="http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271" target="_blank" rel="noopener">Android on x86: Java Native Interface and the Android Native Development Kit</a></li>
<li><a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener">深入理解 JVM(2)——GC 算法与内存分配策略</a></li>
<li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">深入理解 JVM(3)——7 种垃圾收集器</a></li>
<li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></li>
<li><a href="http://www.baeldung.com/java-weakhashmap" target="_blank" rel="noopener">Guide to WeakHashMap in Java</a></li>
<li><a href="https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml" target="_blank" rel="noopener">Tomcat example source code file (ConcurrentCache.java)</a></li>
</ol>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>由一道面试题理解类加载机制</title>
    <url>/2020/05/19/JVM04/</url>
    <content><![CDATA[<p>本文将以一道常见的面试题去剖析一下JVM中的类加载机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ClassLoadTest&#123;</span><br><span class="line">    private static ClassLoaderTest test &#x3D; new ClassLoad();</span><br><span class="line">    </span><br><span class="line">    static int x;</span><br><span class="line">    static int y &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    public ClassLoaderTest()&#123;</span><br><span class="line">        x++:</span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(test.x);</span><br><span class="line">        System.out.println(test.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>那么上面代码运行的结果x，y值是多少呢？可以先猜测一下答案，结果可能会出乎你的意料~</p>
<p><strong>类加载过程：</strong></p>
<p>先用一个图简单的描述一下类加载的这个过程</p>
<p><img src="/img/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD.png" alt="类加载"></p>
<p><strong>加载</strong></p>
<p>这个过程相当于从本地或者网络端去读取一个字节流，然后将一些静态存储结构转化成方法区中运行时期的数据，最后生成一个代表整个类的Class对象，作为方法区访问这个类的入口。</p>
<p>例如：</p>
<ul>
<li>咱们可以通过一个类的全限定名去加载类</li>
<li>通过jar、war包去加载类</li>
<li>通过http请求去第三方平台上拉取指定的类来加载</li>
<li>运行时计算生成，例如cglib动态代理等等</li>
</ul>
<p>针对上述例子，这里是加载一个<code>ClassLoaderTest.class</code>对象</p>
<p><strong>验证</strong></p>
<p>要理解这个环节其实并不难，一个东西要放到JVM上去运行，咱们肯定得对其进行一些过滤，不能什么都往上丢，这也是JVM自我保护的一种机制，这里的验证简单的举几个例子。</p>
<ul>
<li><p>文件格式的验证</p>
<p>（1）是否以魔数0xCAFEBABE开头。</p>
<p>（2）主次版本号是否在当前虚拟机处理范围内。</p>
<p>（3）常量池中的常量是否有不被支持的常量类型等等。</p>
</li>
<li><p>元数据的验证</p>
<p>（1）这个类是否有父类</p>
<p>（2）这个类的父类是否继承了不被允许继承的类（final修饰的类）</p>
<p>（3）这个类不是抽象类，是否实现了所有接口中要实现的方法等等。</p>
</li>
<li><p>字节码的验证</p>
<p>（1）保证跳转指令不会跳转到方法体以外的字节码指令上。</p>
<p>（2）保证方法体中的类型转换是有效的等等。</p>
</li>
<li><p>符号引用的验证</p>
<p>（1）能否通过类的全限定名去找到对应的类</p>
<p>（2）符号引用中的类、字段、方法是否可以被当前类访问等等。</p>
</li>
</ul>
<p><strong>准备过程</strong></p>
<p>这个过程相当于给类变量分配内存空间并设置变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>针对上述例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test &#x3D; null;</span><br><span class="line">x &#x3D; 0;</span><br><span class="line">y &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p><strong>解析过程</strong></p>
<p>将符号引用转化成直接引用的过程。这个有两个名词 <strong>符号引用</strong> 和<strong>直接引用</strong>。</p>
<ul>
<li>符号引用：符号引用与虚拟机的布局无关，甚至引用的目标不一定加载到了内存中。符号可以是任何形式的字面量，只要使用时能够准确的定位到目标即可。</li>
<li>直接引用：直接引用可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机布局有关，如果有了直接引用，那么引用的目标必定已经在内存中存在。</li>
</ul>
<p>而解析过程又会针对类、字段、方法进行解析，解析失败则会抛出相应的异常。例如在解析时发现没有访问权限会抛出 <code>java.lang.IllegalAccessException</code> 异常，查询不到引用字段会抛出 <code>java.lang.NoSuchFieldException</code> 异常，查询不到方法会抛出 <code>java.lang.NoSuchMethodException</code> 异常等等。</p>
<p><strong>初始化</strong></p>
<p>在准备阶段，变量已经赋值过系统要求的默认值，在初始化阶段，则会根据程序制定的主观计划去初始化类变量和其他资源。这句话听起来有些绕口，根据上述例子，实际上就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test &#x3D; new ClassLoaderTest();</span><br><span class="line">y &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p>这个过程，由于 <code>x</code> 咱们自己并没有去设定一个值，所以初始化阶段它不会发生任何改变,但是 <code>y</code> 咱们有设定一个值0，所以最后造成最终结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;x &#x3D; 1;y &#x3D; 0;&#96;</span><br></pre></td></tr></table></figure>

<p>ps：在同一个类加载器下，一个类只会初始化一次。多个线程同时初始化一个类，只有一个线程能正常初始化，其他线程都会进行阻塞等待，直到活动线程执行初始化方法完毕。</p>
<p><strong>总结</strong></p>
<p>对于上面这个面试题，咱们用流程图简单的描述一下：</p>
<p><img src="/img/JVM/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM性能监控与故障处理工具</title>
    <url>/2020/05/19/JVM05/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在给一个系统定位问题的时候，知识、经验是关键基础，而工具是运用知识去处理数据的手段，这里的数据在  JVM  中包括：运行日志、异常堆栈、GC日志、线程快照（threaddump/javacore文件）、堆转储快照（headdump/hprof文件）等。经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据、定位解决问题的速度。但是下面介绍的所有工具，都只是对知识技能的一层“封装”，吃透底层原理才是最重要的，工具的使用是次要的。</p>
<a id="more"></a>

<h1 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h1><p>一般来说，Java 开发人员在初学 Java 的时候就知道有<code>java.exe</code>和<code>javac.exe</code>两个命令行工具，这是最开始我们写<code>Hello World</code>的时候用到的，但是却并不是所有 Java 程序员都知道除了这两个命令行工具外，JDK 自带的<code>bin</code>目录下的其它很多<code>exe</code>工具的数量和功能是在不断的增加和提升的。</p>
<p>由于我个人使用的是<code>JDK1.8</code>版本，所以我们以windows下<code>JDK1.8</code>版本下<code>bin</code>目录工具为例，如果是linux或者macOS可能看到的不太一样。</p>
<p><img src="/img/JVM/jdk-bin.png" alt="jdk-bin"></p>
<p>其中细心的人可以发现好像大多数工具都是 17KB，嘿，难道是 JDK 开发团队在刻意跟我们炫耀高超编程技巧？其实当然不是，这只是因为上面的 exe 命令行工具大多数都是<code>jdk/lib/tools.jar</code>工具的一层很薄的封装而已，其中主要的功能实现都是在<code>tools</code>类库中实现的。</p>
<blockquote>
<p>那么为啥要采用 java 代码来实现这些监控工具呢？</p>
</blockquote>
<p>其实啊，主要是因为实际应用程序部署到生产环境后，无论是直接接触物理服务器还是远程 Telnet 到服务器上都可能受到限制，而借助<code>tools.jar</code>类库里面的工具，我们就可以直接在应用程序中实现强大的监控分析工具。</p>
<p>如果使用的是 JDK1.5 及之前版本的 JDK 的话，在程序启动的时候需要添加参数<code>-Dcom.sun.management.jmxremote</code>来开启 JMX 管理功能，因为其中监控工具大多数都是基于 JMX 的，而如果是 JDK1.6 之后的版本，那么 JMX 管理是默认开启的，即不需要手动添加参数。</p>
<h2 id="常用的JDK监控和故障处理工具"><a href="#常用的JDK监控和故障处理工具" class="headerlink" title="常用的JDK监控和故障处理工具"></a>常用的JDK监控和故障处理工具</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jps（JVM Process Status Tool）</td>
<td align="center">显示指定系统内所有的HotSpot虚拟机进程</td>
</tr>
<tr>
<td align="center">jstat（JVM Statistics Monitoring Tool）</td>
<td align="center">用于收集HotSpot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td align="center">jinfo（Configuration Info for Java）</td>
<td align="center">显示虚拟机配置信息</td>
</tr>
<tr>
<td align="center">jmap（Memory Map for Java）</td>
<td align="center">生成虚拟机的内存转储快照（heapdump文件）</td>
</tr>
<tr>
<td align="center">jhat（JVM Heap Dump Browser）</td>
<td align="center">用于分析heapdump文件，会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td>
</tr>
<tr>
<td align="center">jstack（Stack Trace for Java）</td>
<td align="center">显示虚拟机的线程快照</td>
</tr>
</tbody></table>
<h3 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h3><p>ps  取名其实和 Unix 的 ps 命令一样，也就是用来列出正在运行的虚拟机进程，并显示虚拟机执行主类，其实在 windows 下或者 linux  下 ps 命令也可以查询到虚拟机进程的id，但是如果同时启动了多个虚拟机进程，且无法通过进程名称定位时，那就只能依赖 jps  命令显示主类来查询虚拟机进程了。</p>
<p>jps 命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>

<p>用法比较简单，比如我在本地启动了两个虚拟机进程，主类名称分别是<code>cn.bestzuo.MultiThread</code>和<code>cn.bestzuo.SynAddRunnable</code>，在使用<code>jps -l</code>命令查看进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;C:\Program Files\Java\jdk1.8.0_191\bin&gt; j&#96;</span><br></pre></td></tr></table></figure>

<p>上面绿色的两个进程就是虚拟机启动的进程，前面的数字表示进程 id。</p>
<p>那么后面的<code>-l</code>是选择使用的参数，jps 命令可以使用的参数如下：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-q</td>
<td align="center">只输出 LVMID ，省略主类的名称</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">输出虚拟机进程启动时传递给主类 main() 函数的参数</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">输出主类的全名，如果进程执行的是 jar 包，输出 Jar 路径</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">输出虚拟机进程启动时 JVM 参数</td>
</tr>
</tbody></table>
<h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><p>jstat 用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有 GUI 图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p>
<p>jstat 命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat [option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure>

<p>对于命令格式中的 VMID 和 LVMID 需要特别说明一下，如果是本地虚拟机进程，那么 VMID 和 LVMID 是一致的，如果是远程虚拟机进程，那么 VMID 的格式应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[protocol:][&#x2F;&#x2F;]lvmid[@hostname[:port]&#x2F;servername]</span><br></pre></td></tr></table></figure>

<p>其中参数 interval 和 count 代表查询间隔和次数，如果省略这两个参数，说明只查询一次。</p>
<p>假设需要每 250 毫秒查询一次进程 id 为 2764 垃圾收集情况，一共查询 20 次，那么命令应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure>

<p>选项 option 代表用户想要查询的虚拟机信息，主要分三类：类装载、垃圾收集和运行期编译情况。</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-class</td>
<td align="center">监视类装载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td align="center">-gc</td>
<td align="center">监视 java 堆状况，包括 Eden 区、两个 Survivor 区、老年代、永久代容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td align="center">-gccapacity</td>
<td align="center">监视内容与 -gc 基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcutil</td>
<td align="center">监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td align="center">-gccause</td>
<td align="center">与 -gcutil 工具一样，但是会额外输出导致上一次 GC 产生的原因</td>
</tr>
<tr>
<td align="center">-gcnew</td>
<td align="center">监视新生代 GC 状况</td>
</tr>
<tr>
<td align="center">-gcnewcapacity</td>
<td align="center">监视内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcold</td>
<td align="center">监视老年代 GC 状况</td>
</tr>
<tr>
<td align="center">-gcoldcapacity</td>
<td align="center">监视内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcpermcapacity</td>
<td align="center">输出永久代使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-compiler</td>
<td align="center">输出 JIT 编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td align="center">-printcompilation</td>
<td align="center">输出已经被 JIT 编译过的方法</td>
</tr>
</tbody></table>
<p>由于 jstat 监视选项太多，因此只测试一下其中一项观察结果，依然测试主类<code>cn.bestzuo.SyncAddRunnable</code>主类，我们可以看到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_191\bin&gt; jstat -gcutil 12256</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00  15.47  58.71   0.01  66.07  68.03      1    0.001     0    0.000    0.001</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>S0 、 S1 表示两个 Survivor 区，其中 S1 区使用了 15.47% 的空间</li>
<li>E 代表 Eden 区，即新生代使用了 58.71% 的空间</li>
<li>O 代表老年代，老年代中使用了 0.01% 的空间</li>
<li>M 表示元数据区，即 metaspace ，使用了 66.07% 的空间</li>
<li>CCS 表示压缩使用比例</li>
<li>YGC 即 Minor GC，表示发生过一次</li>
<li>YGCT 表示新生代 GC 耗时时间</li>
<li>FGC 表示 Full GC</li>
<li>FGCT 表示 Full GC 耗时时间</li>
<li>GCT 表示所有 GC 的总耗时</li>
</ul>
<p>虽然 jstat 命令行工具不如后面提到的 VisualVM 直观，但是很多服务器管理员在没有 GUI 图形界面时，依然会使用该命令行工具来进行监视。</p>
<h3 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h3><p>jinfo 的作用是实时地查看和调整虚拟机各项参数。使用 jps 的 -v 参数可以查看虚拟机启动的时候显式指定的参数列表，但是如果想知道未被显示指定的参数的系统默认值，除了找资料外，就只能使用 jinfo 的 -flag 选项进行查询了。</p>
<p>jinfo 的命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jinfo [option] pid</span><br></pre></td></tr></table></figure>

<p>比如我们查询<code>CMSInitialingOccupancyFraction</code>参数值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;C:\Program Files\Java\jdk1.8.0_191\bi&#96;</span><br></pre></td></tr></table></figure>

<h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>jmap 命令用于生成堆转储快照（一般称为 headdump 或 dump 文件）。如果不适用 jmap 命令，要想获取 Java 堆转储快照，也可以采取其它一些比较”暴力“的手段，比如使用<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，通过<code>-XX:+HeapDumpOnCtrlBreak</code>参数则可以使用<code>[Ctrl]+[Break]</code>键让虚拟机生成dump文件，又或者在 Linux 系统下通过<code>Kill -3</code>命令发送进程退出信号”吓唬“一下虚拟机，也能拿到 dump 文件。</p>
<p>当然，jmap 的作用并不仅仅是拿到 dump 文件，它还可以查询<code>finalize</code>执行队列、Java 堆和永久代的详细信息，如空间使用率、当前用的哪种收集器等。</p>
<p>和  jinfo 一样，jmap 不少功能在 windows 平台下都是受限的，除了生成 dump 文件的 -dump  选项和用于查看每个类的实例、空间占用统计的 -histo 选项在所有操作系统都提供之外，其余选项只能在 Linux/Solaris 下使用。</p>
<p>jmap 命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap [option] vmid</span><br></pre></td></tr></table></figure>

<p>其中 option 选项的合法值和具体含义如下：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-dump</td>
<td align="center">生成Java堆转储快照</td>
</tr>
<tr>
<td align="center">-finliazeinfo</td>
<td align="center">显示在F-Queue中等待的Finalizer线程执行finalize方法的对象，只在Linux/Solaris平台下生效</td>
</tr>
<tr>
<td align="center">-heap</td>
<td align="center">显示Java堆详细信息，如使用哪种垃圾收集器、参数配置、分代状况等，只在Linux/Solaris下有效</td>
</tr>
<tr>
<td align="center">-histo</td>
<td align="center">显示堆中对象统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td align="center">-permstat</td>
<td align="center">以ClassLoader为统计口径显示永久代内存状态，Linux/Solaris下有效</td>
</tr>
<tr>
<td align="center">-F</td>
<td align="center">当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，Linux/Solris下有效</td>
</tr>
</tbody></table>
<p>比如如下测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;C:\Users\Ic&#96;</span><br></pre></td></tr></table></figure>

<h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>jhat 命令主要与 jmap 命令搭配使用，可以分析 jmap 生成的堆转储快照。 jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 文件的分析结果后可以在浏览器中查看。</p>
<p>不过实际使用中，除非真的没有其它工具可以使用，否则一般不会直接使用  jhat 命令来分析 dump 文件，原因一是一般不会在部署应用程序的服务器上直接分析 dump 文件，即使可以这样做，也会尽量将 dump  文件复制到其它机器上进行分析，因为分析工作本身就是一个耗时并且消耗硬件资源的过程，既然能到其它机器上分析，那就没必要受到命令行工具的限制了；另外一个原因是  jhat 的分析功能较为简陋，其它更多的工具能分析出来的东西更多。</p>
<h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><p>jstack  命令用于生成虚拟机当前时刻的线程快照（一般称之为 yhreaddump 或者 javacore  文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿后可以使用  jstack 来查看各个线程间的调用堆栈，就可以知道没有响应的线程到底在后台做些什么，或者在等待什么资源。</p>
<p>jstack 的命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstack [option] vmid</span><br></pre></td></tr></table></figure>

<p>jstack 工具主要选项：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-F</td>
<td align="center">当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">如果调用到本地方法的话，可以显示C/C++的堆栈</td>
</tr>
</tbody></table>
<p>比如我们运行一段死锁的程序，然后查看其锁的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;PS C:&#96;</span><br></pre></td></tr></table></figure>

<p>注意：在 JDK1.5 中，<code>java.lang.Thread</code>类新增了一个<code>getAllStackTraces()</code>方法用于获取虚拟机中所有线程的<code>StackTraceElement</code>对象。使用这个方法可以通过简单的几行代码就完成<code>jstack</code>的大部分功能，在实际项目中不妨调用这个方法做一个管理员页面，可以随时使用浏览器来查看线程堆栈。</p>
<h1 id="JDK可视化工具"><a href="#JDK可视化工具" class="headerlink" title="JDK可视化工具"></a>JDK可视化工具</h1><p>JDK 中除了提供大量的命令行工具外，还有两个功能非常强大的可视化工具：<code>JConsole</code>和<code>VisualVM</code>，这两个是 JDK 的正式成员。</p>
<p>其中<code>JConsole</code>是 JDK1.5 时期就已经提供的虚拟机监控工具，而<code>VisualVM</code>在 JDK1.6 Update7 中才首次发布，现在已经成为 Sun（Oracle）主力推动的多合一故障处理工具，并且已经从 JDK 中分离出来成为可以独立发展的开源项目。</p>
<p>上面两者由于是可视化工具，所以这里就不再赘述，内置功能相当于把前面提到的 JDK 命令行工具实现可视化。</p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>破坏双亲委派加载机制</title>
    <url>/2020/05/10/JVM06/</url>
    <content><![CDATA[<p>双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 的世界中大部分类加载器都遵循这个原则，但是显然也有例外。</p>
<p>在《深入理解 JVM 虚拟机》一书中，作者提出双亲委派模型目前出现过 3 次较大规模的“被破坏”情况。</p>
<h3 id="第一次被破坏"><a href="#第一次被破坏" class="headerlink" title="第一次被破坏"></a>第一次被破坏</h3><p>第一次被破坏其实发生在双亲委派模型出现之前，也就是 JDK 1.2  发布之前，由于双亲委派模型在 JDK 1.2 之后才引入，而类加载器和抽象类 java.lang.ClassLoader 在 JDK 1.0  时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者在引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK 1.2  之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()  方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法 loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的  loadClass()。双亲委派的具体逻辑就在这个方法之中，JDK 1.2 之后已经不再提倡用户再去覆盖 loadClass()  方法，而应当把自己的类加载器逻辑写到 findClass() 方法来完成加载，这样就可以保证写出来的类加载器都是符合双亲委派规则的。</p>
<a id="more"></a>

<h3 id="第二次被破坏"><a href="#第二次被破坏" class="headerlink" title="第二次被破坏"></a>第二次被破坏</h3><p>第二次被破坏是由于这个模型自身的问题导致的，双亲委派很好地解决了各个类加载器的基础类统一的问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的  API，但世事往往没有绝对的完美，如果基础类又要调回用户的代码，那该怎么办？</p>
<p>这不是没有可能的事情，比如 JNDI 服务，JNDI  目前已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进去的 rt.jar），但 JNDI  的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI  接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能“认识”这些代码啊，那可怎么办？</p>
<p>为了解决这个问题，Java  设计团队只好引入另外一个不太优雅的设计：线程上下文加载器（Thread Context ClassLoader）。这个类加载器可以通过  java.lang.Thread 类的 setContextClassLoader()（原文在这里写成 setContextLoaser）  方法进行设置，如果创建线程时还未设置，它将从父线程中继承一个，如果在应用程序的全局范围内没有设置过的话，那么这个类加载器默认就是应用程序类加载器。</p>
<p>通过这个线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI  服务使用这个线程上下文类加载去加载所需要的 SPI  代码，也就是通过父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打破了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情，Java  中所有涉及 SPI 的加载动作都是采用的这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。</p>
<h3 id="第三次被破坏"><a href="#第三次被破坏" class="headerlink" title="第三次被破坏"></a>第三次被破坏</h3><p>第三次被破坏是由于用户对程序动态性追求而导致的，这里所说的“动态性”是指当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（Hot  Deployment）等，说白了就是希望应用程序能像我们的计算机外设一样，插上鼠标和 U  盘不用重启机器就能立即使用。鼠标有问题就升级或者换个鼠标，不用停机也不用重启。对于实际生产系统来说，关机重启一次可能就要被列为生产事故。因此这种情况下热部署就非常有吸引力。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。当接收到类加载请求时，OSGI 将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以 java.* 开头的类委派给父类加载器加载</li>
<li>否则，将委派列表名单内的类委派给父类加载器进行加载</li>
<li>否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载</li>
<li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载</li>
<li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应的 Bundle 的类加载器加载</li>
<li>否则，类查找失败</li>
</ol>
<p>上述的查找顺序只有开头两点仍然符合双亲委派模型，其余的类查找都是在平级的类加载器中进行的。</p>
<h3 id="破坏双亲委派的原理"><a href="#破坏双亲委派的原理" class="headerlink" title="破坏双亲委派的原理"></a>破坏双亲委派的原理</h3><p>针对书中介绍的三种情况，往往使用最多的是线程上下文类加载器（TCCL，ThreadContextClassLoader）来破坏双亲委派机制。</p>
<blockquote>
<p>ava 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。</p>
<p>这些  SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar  包被包含进类路径（CLASSPATH）里。SPI 接口中的代码经常需要加载具体的实现类。那么问题来了，SPI 的接口是 Java  核心库的一部分，是由<strong>启动类加载器(Bootstrap Classloader)来加载的；SPI 的实现类是由系统类加载器(System ClassLoader)</strong>来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader 无法委派 AppClassLoader 来加载类。</p>
<p>而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。</p>
</blockquote>
<p>那么我们来以 JDBC 源码来看看是如何破坏双亲委派模型的。 JDBC 也属于 SPI，其 Driver 接口是 Java 核心类库的一部分，但是 Driver 的实现类却是由第三方实现，是需要使用系统类加载器进行加载的，符合上述说的情况。</p>
<h4 id="JDBC-案例分析"><a href="#JDBC-案例分析" class="headerlink" title="JDBC 案例分析"></a>JDBC 案例分析</h4><p>我们先来看平时是如何使用 MySQL 获取数据库连接的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 加载Class到AppClassLoader（系统类加载器），然后注册驱动类</span><br><span class="line">&#x2F;&#x2F; Class.forName(&quot;com.mysql.jdbc.Driver&quot;).newInstance(); </span><br><span class="line">String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testdb&quot;;    </span><br><span class="line">&#x2F;&#x2F; 通过java库获取数据库连接</span><br><span class="line">Connection conn &#x3D; java.sql.DriverManager.getConnection(url, &quot;name&quot;, &quot;password&quot;);</span><br></pre></td></tr></table></figure>

<p>以上就是 MySQL 注册驱动及获取 Connection 的过程，各位可以发现经常写的 Class.forName  被注释掉了，但依然可以正常运行，这是为什么呢？这是因为从 JDK 1.6 开始自带的 JDBC 4.0 版本已支持 SPI 服务加载机制，只要  MySQL 的 jar 包在类路径中，就可以注册 MySQL 驱动。</p>
<p>那到底是在哪一步自动注册了 MySQL Driver  的呢？重点就在 DriverManager.getConnection()  方法中。我们都知道调用一个类的静态方法会自动初始化该类（前提是该类还没有被初始化过），进而执行其静态代码块，DriverManager  中的静态代码块如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;static &#123;&#96;</span><br></pre></td></tr></table></figure>

<p>初始化方法 loadInitialDrivers() 的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;private static void loadInitialDrivers() &#123;    S&#96;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出 JDBC 中的 DriverManager 的加载 Driver 的步骤顺序依次是：</p>
<ol>
<li>通过 SPI 方式，读取 META-INF/services 下文件中的类名，使用 TCCL（线程上下文类加载器） 加载；</li>
<li>通过 System.getProperty(“jdbc.drivers”) 获取设置，然后通过系统类加载器加载。</li>
</ol>
<p>下面详细分析 SPI 加载的那段代码。</p>
<h5 id="JDBC-中的-SPI"><a href="#JDBC-中的-SPI" class="headerlink" title="JDBC 中的 SPI"></a>JDBC 中的 SPI</h5><p>上面说了那么多 SPI，可能你还没弄懂什么是 SPI，所以先来看看什么是 SPI 机制，引用一段博文中的介绍：</p>
<blockquote>
<p><strong>SPI 机制简介</strong><br>SPI  的全名为 Service Provider  Interface，主要是应用于厂商自定义组件或插件中。在java.util.ServiceLoader 的文档里有比较详细的介绍。简单的总结下  java SPI 机制的思想：我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、xml 解析模块、JDBC  模块等方案。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。  Java SPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似 IOC  的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</p>
<p><strong>SPI 具体约定</strong><br>Java  SPI 的具体约定为：当服务的提供者提供了服务接口的一种实现之后，在 jar 包的 META-INF/services/  目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该 jar 包  META-INF/services/  里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。JDK  提供服务实现查找的一个工具类：java.util.ServiceLoader。</p>
</blockquote>
<p>知道 SPI 的机制后，我们来看刚才的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ServiceLoa&#96;</span><br></pre></td></tr></table></figure>

<p>注意 driversIterator.next() 最终就是调用 Class.forName(DriverName, false,  loader) 方法，也就是最开始我们注释掉的 Class.forName 加载驱动的方法。好，那句因 SPI  而省略的代码现在解释清楚了，那我们继续看给这个方法传的 loader 是怎么来的。</p>
<p>因为这句  Class.forName(DriverName, false, loader) 代码所在的类在 java.util.ServiceLoader  类中，而ServiceLoader.class 又加载在 BootrapLoader 中，因此传给 forName 的 loader  必然不能是 BootrapLoader。这时候只能使用 TCCL 了，也就是说把自己加载不了的类加载到 TCCL 中（通过  Thread.currentThread() 获取，简直作弊啊！）。</p>
<p>可以再看下 ServiceLoader.load(Class) 的代码，发现的确如此：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public &#96;</span><br></pre></td></tr></table></figure>

<p>ContextClassLoader 默认存放了 AppClassLoader  的引用，由于它是在运行时被放在了线程中，所以不管当前程序处于何处（BootstrapClassLoader 或是 ExtClassLoader  等），在任何需要的时候都可以用 Thread.currentThread().getContextClassLoader()  取出应用程序类加载器来完成需要的操作。</p>
<p>到这儿差不多把 SPI  机制解释清楚了。直白一点说就是，我（JDK）提供了一种帮你（第三方实现者）加载服务（如数据库驱动、日志库）的便捷方式，只要你遵循约定（把类名写在  /META-INF 里），那当我启动时我会去扫描所有 jar 包里符合约定的类名，再调用 forName 加载，但我的 ClassLoader  是没法加载的，那就把它加载到当前执行线程的 TCCL 里，后续你想怎么操作（驱动实现类的 static 代码块）就是你的事了。</p>
<p>好，刚才说的驱动实现类就是 com.mysql.jdbc.Driver，它的静态代码块里头又写了什么呢？是否又用到了 TCCL 呢？我们继续看下一个例子。</p>
<h5 id="校验实例的归属"><a href="#校验实例的归属" class="headerlink" title="校验实例的归属"></a>校验实例的归属</h5><p>com.mysql.jdbc.Driver 加载后运行的静态代码块:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;stati&#96;</span><br></pre></td></tr></table></figure>

<p>registerDriver 方法将 driver 实例注册到系统的 java.sql.DriverManager 类中，其实就是 add 到它的一个名为 registeredDrivers 的静态成员 CopyOnWriteArrayList 中 。</p>
<p>到此驱动注册基本完成，接下来我们回到最开始的那段样例代码：java.sql.DriverManager.getConnection()。它最终调用了以下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;private s&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) &#123;</span><br><span class="line">    boolean result &#x3D; false;</span><br><span class="line">    if(driver !&#x3D; null) &#123;</span><br><span class="line">        Class&lt;?&gt; aClass &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">	    &#x2F;&#x2F; 传入的classLoader为调用getConnetction的当前类加载器，从中寻找driver的class对象</span><br><span class="line">            aClass &#x3D;  Class.forName(driver.getClass().getName(), true, classLoader);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            result &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">	&#x2F;&#x2F; 注意，只有同一个类加载器中的Class使用&#x3D;&#x3D;比较时才会相等，此处就是校验用户注册Driver时该Driver所属的类加载器与调用时的是否同一个</span><br><span class="line">	&#x2F;&#x2F; driver.getClass()拿到就是当初执行Class.forName(&quot;com.mysql.jdbc.Driver&quot;)时的应用AppClassLoader</span><br><span class="line">        result &#x3D; ( aClass &#x3D;&#x3D; driver.getClass() ) ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 TCCL 本质就是当前应用类加载器，所以之前的初始化就是加载在当前的类加载器中，这一步就是校验存放的 driver 是否属于调用者的  Classloader。例如在下文中的 Tomcat 里，多个 webapp 都有自己的 Classloader，如果它们都自带  mysql-connect.jar 包，那底层 Classloader 的 DriverManager 里将注册多个不同类加载器的 Driver  实例，想要区分只能靠 TCCL 了。</p>
<h4 id="Tomcat与Spring的类加载案例"><a href="#Tomcat与Spring的类加载案例" class="headerlink" title="Tomcat与Spring的类加载案例"></a>Tomcat与Spring的类加载案例</h4><h5 id="Tomcat-中的类加载器"><a href="#Tomcat-中的类加载器" class="headerlink" title="Tomcat 中的类加载器"></a>Tomcat 中的类加载器</h5><p>在 Tomcat 目录结构中，有三组目录（<code>/common/*</code>,<code>/server/*</code>和<code>shared/*</code>）可以存放公用 Java 类库，此外还有第四组 Web 应用程序自身的目录 <code>/WEB-INF/*</code> ，把 Java 类库放置在这些目录中的含义分别是：</p>
<ul>
<li>放置在 common 目录中：类库可被 Tomcat 和所有的 Web 应用程序共同使用。</li>
<li>放置在 server 目录中：类库可被 Tomcat 使用，但对所有的 Web 应用程序都不可见。</li>
<li>放置在 shared 目录中：类库可被所有的 Web 应用程序共同使用，但对 Tomcat 自己不可见。</li>
<li>放置在 /WebApp/WEB-INF 目录中：类库仅仅可以被此 Web 应用程序使用，对 Tomcat 和其他 Web 应用程序都不可见。</li>
</ul>
<p>为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat 自定义了多个类加载器，这些类加载器按照经典的双亲委派模型来实现，如下图所示：</p>
<p><img src="/img/JVM/tomcat-classloader.png" alt="tomcat-classloader"></p>
<p>灰色背景的 3 个类加载器是 JDK 默认提供的类加载器，这 3 个加载器的作用前面已经介绍过了。而  CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和  WebAppClassLoader 则是 Tomcat 自己定义的类加载器，它们分别加载 <code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code> 和 <code>/WebApp/WEB-INF/*</code> 中的 Java 类库。其中 WebApp 类加载器和 JSP 类加载器通常会存在多个实例，每一个 Web 应用程序对应一个 WebApp 类加载器，每一个 JSP 文件对应一个 JSP 类加载器。</p>
<p>从图中的委派关系中可以看出，CommonClassLoader  能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用，而  CatalinaClassLoader 和 SharedClassLoader  自己能加载的类则与对方相互隔离。WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个  WebAppClassLoader 实例之间相互隔离。而 JasperLoader 的加载范围仅仅是这个 JSP 文件所编译出来的那一个  Class，它出现的目的就是为了被丢弃：当服务器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader  的实例，并通过再建立一个新的 JSP 类加载器来实现 JSP 文件的 HotSwap 功能。</p>
<h5 id="Spring-加载问题"><a href="#Spring-加载问题" class="headerlink" title="Spring 加载问题"></a>Spring 加载问题</h5><p>Tomcat  加载器的实现清晰易懂，并且采用了官方推荐的“正统”的使用类加载器的方式。这时作者提一个问题：如果有 10 个 Web 应用程序都用到了  Spring 的话，可以把 Spring 的 jar 包放到 common 或 shared 目录下让这些程序共享。Spring  的作用是管理每个 web 应用程序的 bean， getBean 时自然要能访问到应用程序的类，而用户的程序显然是放在<code>/WebApp/WEB-INF</code>  目录中的（由 WebAppClassLoader 加载），那么在 CommonClassLoader 或 SharedClassLoader  中的 Spring 容器如何去加载并不在其加载范围的用户程序（/WebApp/WEB-INF/）中的 Class 呢？</p>
<p>实际上，Spring  根本不会去管自己被放在哪里，它统统使用 TCCL 来加载类，而 TCCL 默认设置为了 WebAppClassLoader，也就是说哪个  WebApp 应用调用了 Spring，Spring 就去取该应用自己的 WebAppClassLoader 来加载 bean，简直完美~</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>有兴趣的可以接着看看具体实现：</p>
<p>在 web.xml 中定义的 listener 为 <code>org.springframework.web.context.ContextLoaderListener</code>，它最终调用了 <code>org.springframework.web.context.ContextLoader</code> 类来装载 bean，具体方法如下（删去了部分不相关内容）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public &#96;</span><br></pre></td></tr></table></figure>

<p>具体说明都在注释中，Spring 考虑到了自己可能被放到其他位置，所以直接用 TCCL 来解决所有可能面临的情况。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面的两个案例分析，我们可以总结出线程上下文类加载器的适用场景：</p>
<ol>
<li>当高层提供了统一接口让低层去实现，同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的 ClassLoader 找到并加载该类。</li>
<li>当使用本类托管类加载，然而加载本类的 ClassLoader 未知时，为了隔离不同的调用者，可以取调用者各自的线程上下文类加载器代为托管。</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">真正理解线程上下文类加载器（多案例分析）</a></li>
<li><a href="http://dengchengchao.com/?p=1014" target="_blank" rel="noopener">JVM双亲委派机制与Tomcat</a></li>
</ol>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：单例模式</title>
    <url>/2020/04/26/designPattern01/</url>
    <content><![CDATA[<h3 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h3><p>在标准的23种设计模式种，单例设计模式在应用中是非常常见的，而我们在学习单例模式中，一定要考虑到和多线程结合起来时可能存在的各种问题以及其解决办法，这样我们才能写出一个在多线程环境下安全、正确的单例模式。</p>
<p>单例模式常见的有八种写法(更多时候分为六种，此处更加细分了)：</p>
<ul>
<li>饿汉式（静态常量）</li>
<li>饿汉式（静态代码块）</li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法）</li>
<li>懒汉式（线程安全，同步代码块）</li>
<li>双重检查锁</li>
<li>静态内部类</li>
<li>枚举</li>
</ul>
<a id="more"></a>

<h3 id="二、单例模式的基本实现思路："><a href="#二、单例模式的基本实现思路：" class="headerlink" title="二、单例模式的基本实现思路："></a>二、单例模式的基本实现思路：</h3><p>单例模式要求类能够有返回对象的一个引用（并且永远是同一个）和一个获得该实例的方法（必须是静态方法，往往使用<code>getInstance()</code>这个方法）</p>
<p>单例模式的实现主要通过以下步骤：</p>
<p>（1）将该类的构造方法定义为<strong>私有方法</strong>，这样其它的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p>
<p>（2）在该类种提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋值给该类保持的引用。</p>
<p>注意事项：单例模式在多线程的环境下必须小心使用，如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被创建了出来，从而违反了单例模式种实例唯一的原则，解决的办法显而易见是加锁。</p>
<h3 id="三、单例模式的八种写法"><a href="#三、单例模式的八种写法" class="headerlink" title="三、单例模式的八种写法"></a>三、单例模式的八种写法</h3><h4 id="1、饿汉式（静态常量）"><a href="#1、饿汉式（静态常量）" class="headerlink" title="1、饿汉式（静态常量）"></a>1、饿汉式（静态常量）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class singleton()&#123;</span><br><span class="line">    private final static Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;注意构造方法必须私有</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：写法简单，就是在类加载的时候完成实例化，避免了线程同步问题。</p>
<p>缺点：没有达到懒加载的效果，如果从始至终都未使用过这个实例，会造成内存的浪费。</p>
<h4 id="2、饿汉式（静态代码块）"><a href="#2、饿汉式（静态代码块）" class="headerlink" title="2、饿汉式（静态代码块）"></a>2、饿汉式（静态代码块）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    static&#123;</span><br><span class="line">        instance &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式跟第一种方式类似，都是在类加载的时候完成的，只不过将实例化的过程放在了静态代码块种，优缺点跟上面一样。</p>
<h4 id="3、懒汉式（线程不安全）"><a href="#3、懒汉式（线程不安全）" class="headerlink" title="3、懒汉式（线程不安全）"></a>3、懒汉式（线程不安全）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法在单线程环境下可以使用，但是多线程环境下显然会产生多个实例。</p>
<h4 id="4、懒汉式（线程安全，同步方法）"><a href="#4、懒汉式（线程安全，同步方法）" class="headerlink" title="4、懒汉式（线程安全，同步方法）"></a>4、懒汉式（线程安全，同步方法）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法是对上面的线程不安全的懒汉式的改进。</p>
<p>由于每次去获取实例的时候都会进入<code>synchronized</code>代码块而不管实例是否为null，而其实这个方法只需要执行一次实例化代码就可以，因此这样的开销非常大，所以不推荐使用。</p>
<h4 id="5、懒汉式（线程安全，同步代码块）"><a href="#5、懒汉式（线程安全，同步代码块）" class="headerlink" title="5、懒汉式（线程安全，同步代码块）"></a>5、懒汉式（线程安全，同步代码块）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                instance &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并不能起到线程同步的作用，跟第三种方式遇到的情形一致。假如两个线程同时进入了<code>if(instance == null)</code>代码块，那么还是会产生多个实例，因此同样不推荐使用。</p>
<h4 id="6、双重检查锁"><a href="#6、双重检查锁" class="headerlink" title="6、双重检查锁"></a>6、双重检查锁</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static volatile Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(singleton &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(singleton &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    singleton &#x3D; new Singleton():</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重检查锁对于多线程开发者来说并不陌生，我们进行了两次<code>if(singleton == null)</code>判断，并通过将实例singleton设置为<code>volatile</code>变量，这样可以实现变量的可见性并且禁止编译器指令重排序造成的其它问题。</p>
<p>优点：线程安全，延迟加载，效率较高。</p>
<h4 id="7、静态内部类"><a href="#7、静态内部类" class="headerlink" title="7、静态内部类"></a>7、静态内部类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static class SingletonInstance&#123;</span><br><span class="line">        private static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading（懒加载）的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p>
<p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，<strong>JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</strong></p>
<p>优点：避免了线程不安全，延迟加载，效率高。</p>
<h4 id="8、枚举"><a href="#8、枚举" class="headerlink" title="8、枚举"></a>8、枚举</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，使用枚举实现单例模式很少出现。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：工厂模式</title>
    <url>/2020/05/05/designPattern02/</url>
    <content><![CDATA[<p>创建型设计模式中的工厂模式可以细分为三种：分别是简单工厂模式、工厂方法模式、抽象工厂模式。</p>
<h3 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h3><p><strong>定义</strong>：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<p>简单工厂模式属于类的创建型模式，又叫做静态工厂模式。通过专门定义一个工厂类来负责创建其它类的实例，被创建的实例通常都具有共同的父类。需要注意的是，简单工厂模式不属于23种GOF设计模式之一。</p>
<p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例，简单工厂模式是工厂模式家族种最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</p>
<a id="more"></a>

<p>简单工厂模式包含三种角色：</p>
<p>（1）<strong>工厂角色</strong>（Creator）</p>
<p>这是简单工厂模式的核心，它用来负责创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。</p>
<p>（2）<strong>抽象角色</strong>（Product）</p>
<p>这是简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。该类可以是接口，也可以是抽象类。</p>
<p>（3）<strong>具体产品角色</strong>（Concrete Product）</p>
<p><img src="/img/designPattern/simple.png" alt="simple"></p>
<p>简单工厂模式所创建的具体的实例对象。</p>
<p><img src="/img/designPattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="简单工厂模式"></p>
<p>以上面的UML为例，表示的是一个用简单工厂方法模式实现的加减乘除计算器程序。</p>
<p>其中Operator是一个抽象类，其中包含属性numberA及numberB，以及一个getResult( )方法用于返回计算结果。它的角色就是抽象角色（Product）。</p>
<p>下面的AddOperator、SubOperator、MulOperator、DivOperator是Operator的子类，分别代表加减乘除四种运算，他们的角色是具体产品角色（Concrete Peoduct）。</p>
<p>OperatorFactory是工厂类，其中的createOperator( )方法用于创建计算器对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 计算器抽象类</span><br><span class="line">*&#x2F;</span><br><span class="line">public abstract class Operator&#123;</span><br><span class="line">    private double numberA;</span><br><span class="line">    private double numberB;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;获取结果的抽象方法</span><br><span class="line">    protected abstract double getResult() throws Exception;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; getter和setter方法省略</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*  加法计算类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class AddOperator extends Operator&#123;</span><br><span class="line">    &#x2F;&#x2F;实现父类的抽象方法</span><br><span class="line">    @Override</span><br><span class="line">    protected double getResult()&#123;</span><br><span class="line">        return getNumberA() + getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*  减法计算类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class SubOperator extends Operator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected double getResult()&#123;</span><br><span class="line">        return getNumberA() + getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*  乘法计算类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class MulOperator extends Operator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected double getResult()&#123;</span><br><span class="line">        return getNumberA() * getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*  除法计算类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class MulOperator extends Operator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected double getResult() throws Exception&#123;</span><br><span class="line">        if(getNmberB() &#x3D;&#x3D; 0.0)&#123;</span><br><span class="line">            throw new Exception(&quot;除数不能为0&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return getNumberA() &#x2F; getNumberB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 简单工厂类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class OperatorFactory &#123;</span><br><span class="line">    public static Operator createOperator(String operation)&#123;</span><br><span class="line">        Operator operator &#x3D; null;</span><br><span class="line">        switch (operation)&#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                operator &#x3D; new AddOperator();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                operator &#x3D; new SubOperator();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                operator &#x3D; new MulOperator();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;&#x2F;&quot;:</span><br><span class="line">                operator &#x3D; new DivOperator();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return operator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试简单工厂类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class OperatorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Operator operator &#x3D; OperatorFactory.createOperator(&quot;+&quot;);</span><br><span class="line">        operator.setNumberA(10);</span><br><span class="line">        operator.setNumberB(5);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(operator.getResult());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延伸：试想一下，当我们在coding的时候，如果在A类里面new了一个B类的对象，那么A类在某种程度上说就是依赖于B类。如果在后期开发的时候需求变化或者是维护的时候，需要修改B类的时候，我们就需要打开源代码修改所有与这个类有关的类了，做过重构的朋友就知道，这样的事情虽然无法避免，但是确实是一件让人心碎的事情。</p>
<p>通过以上分析，我们可以得出简单工厂模式的优缺点：</p>
<ul>
<li>在简单工厂模式中，工厂类是整个模式的关键，它包含了必要的逻辑判断，能够根据外界给定的条件去判断应该创建哪个具体类的实例，用户使用时可以直接根据工厂类去创建所需的实例，而无需关心这些对象是如何组织并创建的，从这一点来说，这有利于整个软件体系结构的优化。</li>
<li>但是，简单工厂模式的缺点也正体现在工厂类上，<strong>由于工厂类集中了所有实例的创建逻辑</strong>，当我们增加一个新的具体类时，需要同时修改工厂类（多加几个if判断），这违反了”开闭原则“。</li>
</ul>
<hr>
<h3 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h3><p><strong>定义</strong>：定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<p>工厂方法模式又称<strong>多态性工厂模式</strong>，是对普通工厂方法模式的改进，在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p>
<p><img src="/img/designPattern/factory.png" alt="factory"></p>
<p>依旧以上面计算器为例：</p>
<p><img src="/img/designPattern/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="工厂方法模式"></p>
<p>我们对OperatorFactory类更改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public c&#96;</span><br></pre></td></tr></table></figure>

<p>此时不会出现简单工厂模式中因为字符串传错而不能正常创建对象的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;publ&#96;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：与简单工厂模式相比，工厂方法模式避免了因为传入字符串错误而导致无法正常创建对象的问题，并且由于多态的存在，客户端代码可以做到与特定应用无关，适用于任何实体类。缺点是每次增加一个产品时，都需要增加一个具体产品类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<hr>
<h3 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h3><p>定义：提供一个接口，用于创建 <strong>相关的对象家族</strong> 。</p>
<p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<p><img src="/img/designPattern/abs.gif.jpg" alt="abs.gif"></p>
<p>抽象工厂模式中包含的角色及职责：</p>
<p>（1）<strong>抽象工厂角色</strong>（Creator）</p>
<p>这是抽象工厂模式的核心，任何工厂类必须实现这个接口。</p>
<p>（2）<strong>具体工厂角色</strong>（Concrete Creator）</p>
<p>它是抽象工厂的一个实现，负责实例化产品对象。</p>
<p>（3）<strong>抽象角色</strong>（Product）</p>
<p>抽象工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</p>
<p>（4）<strong>具体产品角色</strong>（Concrete Product）</p>
<p>抽象工厂模式所创建的具体的实例对象。</p>
<p>下面结合实例理解一下：</p>
<p>我们将创建Shape和Color接口和实现这些接口的实现类，下一步是创建抽象工厂类AbastractFactory。接着定义工厂类ShapeFactory和ColorFactory，这两个工厂类都是扩展了AbstractFactory。然后创建一个工厂生成器FactoryProducer。</p>
<p>下面结合UML图理解一下：</p>
<p><img src="/img/designPattern/uml.jpg" alt="uml"></p>
<p>根据上面的步骤，我们先为形状创建一个接口（抽象角色）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public interf&#96;</span><br></pre></td></tr></table></figure>

<p>然后创建接口的实体类（具体产品角色）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Rectangle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        System.out.println(&quot;矩形形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Square implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        System.out.println(&quot;方形形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Circle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        System.out.println(&quot;园形形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为颜色创建一个接口（抽象角色）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Color&#123;</span><br><span class="line">    void fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建接口的实体类（具体产品角色）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Red implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill()&#123;</span><br><span class="line">        System.out.println(&quot;红色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Blue implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill()&#123;</span><br><span class="line">        System.out.println(&quot;蓝色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Green implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill()&#123;</span><br><span class="line">        System.out.println(&quot;绿色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们继续创建抽象工厂角色和具体工厂角色：</p>
<p>先为Color和Shape对象创建抽象类来获取工厂：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractFactory&#123;</span><br><span class="line">    public abstract Color getColor(String color);</span><br><span class="line">    public abstract Shape getShape(String shape);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建扩展了AbstractFactory的工厂类（具体工厂类），基于给定的信息生成实体类的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ShapeFactory extends AbstractFactory&#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape(String shapeType)&#123;</span><br><span class="line">        if(shapeType &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(shapeType.equalsIgnoreCase(&quot;circle&quot;))&#123;</span><br><span class="line">            return new Circle();</span><br><span class="line">        &#125;esle if(shapeType.equalsIgnoreCase(&quot;rectangle&quot;))&#123;</span><br><span class="line">            return new Rectangle();</span><br><span class="line">        &#125;else if(shapeType.equalsIgnoreCase(&quot;square&quot;))&#123;</span><br><span class="line">            return new Square();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Color getColor(String color)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ColorFactory extends AbstractFactory &#123;</span><br><span class="line">    </span><br><span class="line">   @Override</span><br><span class="line">   public Shape getShape(String shapeType)&#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   public Color getColor(String color) &#123;</span><br><span class="line">      if(color &#x3D;&#x3D; null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;        </span><br><span class="line">      if(color.equalsIgnoreCase(&quot;red&quot;))&#123;</span><br><span class="line">         return new Red();</span><br><span class="line">      &#125; else if(color.equalsIgnoreCase(&quot;green&quot;))&#123;</span><br><span class="line">         return new Green();</span><br><span class="line">      &#125; else if(color.equalsIgnoreCase(&quot;blue&quot;))&#123;</span><br><span class="line">         return new Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建工厂生成器，通过传递形状或颜色信息来获取工厂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;publ&#96;</span><br></pre></td></tr></table></figure>

<p>然后我们使用FactoryProducer来获取AbstractFactory，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;publ&#96;</span><br></pre></td></tr></table></figure>

<h3 id="4、三种工厂模式的区别"><a href="#4、三种工厂模式的区别" class="headerlink" title="4、三种工厂模式的区别"></a>4、三种工厂模式的区别</h3><p>GOF在《设计模式》一书种将工厂模式分为两类：工厂方法模式（FactoryMethod）和抽象工厂模式（AbstractFactory）。</p>
<p>因此将简单工厂模式看为是工厂方法模式的一种特例，两者归为一类。</p>
<p><strong>工厂方法模式</strong></p>
<p>（1）一个抽象产品类，可以派生出多个具体产品类。</p>
<p>（2）一个抽象工厂类，可以派生出多个具体工厂类。</p>
<p>每个具体工厂类只能创建一个具体产品类的实例。</p>
<p><strong>抽象工厂模式</strong></p>
<p>（1）多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。</p>
<p>（2）一个抽象工厂类，每个可以派生出多个具体工厂类。</p>
<p>（3）每个具体工厂类可以创建多个具体产品类的实例。</p>
<p><strong>区别</strong></p>
<p>（1）工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。</p>
<p>（2）工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</p>
<hr>
<h3 id="5、形象化总结三种工厂模式"><a href="#5、形象化总结三种工厂模式" class="headerlink" title="5、形象化总结三种工厂模式"></a>5、形象化总结三种工厂模式</h3><p>下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。</p>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。</p>
<p>比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。</p>
<p><img src="/img/designPattern/simpleFactory.png" alt="simpleFactory"></p>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。</p>
<p>戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。</p>
<p>生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。</p>
<p>后续直接调用<strong>鼠标工厂.生产鼠标()</strong>即可</p>
<p><img src="/img/designPattern/factoryMethod.png" alt="factoryMethod"></p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>抽象工厂模式也就是不仅生产鼠标，同时生产键盘。</p>
<p>也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。</p>
<p>戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。</p>
<p>创建工厂时，由戴尔工厂创建。</p>
<p>后续<strong>工厂.生产鼠标()</strong>则生产戴尔鼠标，<strong>工厂.生产键盘()</strong>则生产戴尔键盘。</p>
<p><img src="/img/designPattern/abstractFactory.png" alt="abstractFactory"></p>
<p><strong>在抽象工厂中，假如我们要增加一个工厂：</strong></p>
<p>假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。</p>
<p>之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。</p>
<p><img src="/img/designPattern/abstractFactory2.png" alt="abstractFactory2"></p>
<p><strong>在抽象工厂模式中，假如我们要增加一个产品：</strong></p>
<p>假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。</p>
<p>之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 </p>
<p><img src="/img/designPattern/abstractFactory3.png" alt="abstractFactory3"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：装饰者模式</title>
    <url>/2020/05/07/designPattern03/</url>
    <content><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h3 id="1、意图"><a href="#1、意图" class="headerlink" title="1、意图"></a>1、意图</h3><p>动态的给一个对象添加额外的功能，装饰者模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<h3 id="2、适用环境"><a href="#2、适用环境" class="headerlink" title="2、适用环境"></a>2、适用环境</h3><ol>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li>
<li>处理那些可以撤销的职责</li>
<li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类的数量爆炸增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li>
</ol>
<a id="more"></a>

<h3 id="3、参与者"><a href="#3、参与者" class="headerlink" title="3、参与者"></a>3、参与者</h3><ol>
<li><p>Component（抽象构件角色）</p>
<p>真实对象和装饰对象有相同的接口，这样，客户端对象就能够以与真实对象相同的方式同装饰对象进行交互。</p>
</li>
<li><p>ConcreteComponent（具体构件角色，即真实对象）</p>
<p>IO流中的FileInputStream、FileOutputStream</p>
</li>
<li><p>Decorator（装饰角色）</p>
<p>持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。</p>
</li>
<li><p>ConcreteDecorator（具体装饰角色）</p>
<p>负责给构件对象增加新的责任。</p>
</li>
</ol>
<h3 id="4、类图"><a href="#4、类图" class="headerlink" title="4、类图"></a>4、类图</h3><p><img src="/img/designPattern/051850035172757.png" alt="051850035172757"></p>
<h3 id="5、涉及角色"><a href="#5、涉及角色" class="headerlink" title="5、涉及角色"></a>5、涉及角色</h3><ol>
<li>抽象组件：定义一个抽象接口，来规范准备附加功能的类。</li>
<li>具体组件：将要被附加功能的类，实现抽象构件角色接口。</li>
<li>抽象装饰者：持有对具体构件角色的引用并定义与抽象构件角色一致的接口。</li>
<li>具体装饰：实现抽象装饰者角色，负责对具体构件添加额外功能。</li>
</ol>
<h3 id="6、代码举例"><a href="#6、代码举例" class="headerlink" title="6、代码举例"></a>6、代码举例</h3><p>对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。 举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，<strong>在香肠上面加一点奶油，再放一点蔬菜，最后再用两片面包夹一下</strong>，很丰盛的一顿午饭，营养又健康。那我们应该怎么来写代码呢？ 首先，我们需要写一个Food类，让其他所有食物都来继承这个类，看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Food &#123;</span><br><span class="line"></span><br><span class="line">   private String food_name;</span><br><span class="line"></span><br><span class="line">   public Food() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Food(String food_name) &#123;</span><br><span class="line">       this.food_name &#x3D; food_name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String make() &#123;</span><br><span class="line">       return food_name;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，我就不解释了，然后我们写几个子类继承它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;面包类</span><br><span class="line">public class Bread extends Food &#123;</span><br><span class="line"></span><br><span class="line">   private Food basic_food;</span><br><span class="line"></span><br><span class="line">   public Bread(Food basic_food) &#123;</span><br><span class="line">       this.basic_food &#x3D; basic_food;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String make() &#123;</span><br><span class="line">       &#x2F;&#x2F;加入子类实现的具体逻辑</span><br><span class="line">       return basic_food.make()+&quot;+面包&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;奶油类</span><br><span class="line">public class Cream extends Food &#123;</span><br><span class="line"></span><br><span class="line">   private Food basic_food;</span><br><span class="line"></span><br><span class="line">   public Cream(Food basic_food) &#123;</span><br><span class="line">       this.basic_food &#x3D; basic_food;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String make() &#123;</span><br><span class="line">       &#x2F;&#x2F;加入子类实现的具体逻辑</span><br><span class="line">       return basic_food.make()+&quot;+奶油&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;蔬菜类</span><br><span class="line">public class Vegetable extends Food &#123;</span><br><span class="line"></span><br><span class="line">   private Food basic_food;</span><br><span class="line"></span><br><span class="line">   public Vegetable(Food basic_food) &#123;</span><br><span class="line">       this.basic_food &#x3D; basic_food;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String make() &#123;</span><br><span class="line">       &#x2F;&#x2F;加入子类实现的具体逻辑</span><br><span class="line">       return basic_food.make()+&quot;+蔬菜&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑，如果你还是看不懂为什么这么写，不急，你看看我的Test类是怎么写的，一看你就明白了 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       Food food &#x3D; new Bread(new Vegetable(new Cream(new Food(&quot;香肠&quot;))));</span><br><span class="line">       System.out.println(food.make());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用继承去实现的话，会产生什么样的结果呢？</p>
<p>首先，肯定是需要创建一个Food类，然后去创建Food类的子类叫香肠奶油蔬菜三明治，但是如果我每天都不想吃同一种菜，那么每天都需要创建一个子类去继承Food类，这样下去肯定是会产生子类爆炸的。而利用装饰者模式，比如我个人就偏爱吃蔬菜、奶油、鸡蛋、面包等这几个具体的类，那么我们只需要对这几种类进行继承或者实现即可，而不用单独去一一创建组合的子类，具体吃啥则有我们自己对基本food进行自由装饰。  </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：适配器模式</title>
    <url>/2020/05/09/designPattern04/</url>
    <content><![CDATA[<p>将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是20V，但是正常的电压是220V，这时候就需要一个变压器，将220V的电压转换成20V的电压，这样，变压器就将20V的电压和手机联系起来了。</p>
<h3 id="什么是适配器模式？"><a href="#什么是适配器模式？" class="headerlink" title="什么是适配器模式？"></a>什么是适配器模式？</h3><p>将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h3 id="模式中的角色"><a href="#模式中的角色" class="headerlink" title="模式中的角色"></a>模式中的角色</h3><ol>
<li><strong>目标接口（Target）</strong>：客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口。</li>
<li><strong>需要适配的类（Adaptee）</strong>：需要适配的类或适配者类</li>
<li><strong>适配器（Adapter）</strong>：通过包装一个需要适配的对象，把原接口转换成目标接口。</li>
</ol>
<a id="more"></a>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;&#x2F;手机类public &#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;变压器</span><br><span class="line">public class VoltageAdapter&#123;</span><br><span class="line">    &#x2F;&#x2F;改变电压的功能</span><br><span class="line">    public void changeVoltage()&#123;</span><br><span class="line">        System.out.println(&quot;正在充电...&quot;);</span><br><span class="line">        System.out.println(&quot;原始电压:&quot; + Phone.V + &quot;V&quot;);</span><br><span class="line">        Ststem.out.println(&quot;经过变压器转换后的电压:&quot; + (Phone.V - 200) + &quot;V&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实现适配器模式的测试类，client调用</span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Phone phone &#x3D; new Phone();</span><br><span class="line">        VoltageAdapter adapter &#x3D; new VoltageAdapter();</span><br><span class="line">        phone.setAdapter(adpter);</span><br><span class="line">        phone.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：代理模式</title>
    <url>/2020/05/13/designPattern05/</url>
    <content><![CDATA[<h1 id="代理模式简介"><a href="#代理模式简介" class="headerlink" title="代理模式简介"></a>代理模式简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>通过代理，控制对对象的访问！使用代理模式可以详细控制某个（某类）对象的方法，在调用这个方法之前做前置处理，调用这个方法之后做后置处理（这也就是Spring的AOP的微观实现）。</p>
<p><img src="D:%5Cblog%5Csource_posts%5Cimg%5CdesignPattern%5C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p>
<a id="more"></a>

<h2 id="核心角色"><a href="#核心角色" class="headerlink" title="核心角色"></a>核心角色</h2><ol>
<li>抽象角色：定义代理角色和真实角色的公共对外方法。</li>
<li>真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。主要是关注真正的业务逻辑！</li>
<li>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以添加自己的操作，即将统一的流程控制放到代理角色中处理。</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法调用（RMI）</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>静态代理</p>
</li>
<li><p>动态代理：<br>​ （1）JDK自带的字节码操作库实现</p>
<p> （2）javaassist字节码操作库的实现</p>
<p> （3）CGLIB第三方代理库</p>
<p> （4）ASM（底层使用指令，可维护性较差）</p>
</li>
</ul>
<h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2><p>这里可以举一个简单的例子，比如明星和经纪人的关系，明星的面谈、签合同、唱歌、订票以及收钱等行为（方法），其中面谈、签合同、订票以及收钱等方法都可以由经纪人代理，但是唱歌需要由明星本人执行，这种显式代理的方式就是静态代理模式。</p>
<p><img src="/img/designPattern/staticProxy.png" alt="staticProxy"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象明星角色</span><br><span class="line">public interface Star &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 面谈</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void confer();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 签合同</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void signContract();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 订票</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void bookTicket();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 唱歌</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void sing();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 收钱</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void collectMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;真实明星</span><br><span class="line">public class RealStar implements Star&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void confer() &#123;</span><br><span class="line">		System.out.println(&quot;realStar面谈&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void signContract() &#123;</span><br><span class="line">		System.out.println(&quot;realStar签合同&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void bookTicket() &#123;</span><br><span class="line">		System.out.println(&quot;realStar订票&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sing() &#123;</span><br><span class="line">		System.out.println(&quot;周杰伦本人唱歌&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void collectMoney() &#123;</span><br><span class="line">		System.out.println(&quot;realStar收钱&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;明星经纪人</span><br><span class="line">public class ProxyStar implements Star&#123;</span><br><span class="line">	</span><br><span class="line">	private Star star;</span><br><span class="line">	</span><br><span class="line">	public ProxyStar(Star star)&#123;</span><br><span class="line">		this.star &#x3D; star;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void confer() &#123;</span><br><span class="line">		System.out.println(&quot;代理人面谈&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void signContract() &#123;</span><br><span class="line">		System.out.println(&quot;代理人签合同&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void bookTicket() &#123;</span><br><span class="line">		System.out.println(&quot;代理人订票&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sing() &#123;</span><br><span class="line">		&#x2F;&#x2F;唱歌需要真实的明星来唱，其它都可以代理</span><br><span class="line">		star.sing();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void collectMoney() &#123;</span><br><span class="line">		System.out.println(&quot;代理人收钱&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端测试类</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Star real &#x3D; new RealStar();</span><br><span class="line">		Star proxy &#x3D; new ProxyStar(real);</span><br><span class="line">		</span><br><span class="line">		proxy.confer();</span><br><span class="line">		proxy.signContract();</span><br><span class="line">		proxy.bookTicket();</span><br><span class="line">		proxy.sing();   &#x2F;&#x2F;周杰伦本人唱歌</span><br><span class="line">		proxy.collectMoney();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态代理模式"><a href="#动态代理模式" class="headerlink" title="动态代理模式"></a>动态代理模式</h2><ol>
<li>JDK自带的动态代理</li>
</ol>
<ul>
<li>java.lang.reflect.Proxy：动态生成代理类和对象</li>
<li>java.lang.reflect.InvocationHandler：处理器接口，可以通过invoke方法实现对真实角色的访问，每次通过proxy生成代理类对象时都要指定对应的处理器对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Star realStar &#96;</span><br></pre></td></tr></table></figure>

<p>实现代码：</p>
<p>使用JDK方法实现的动态代理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;publi&#96;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public class Client &#123;	&#96;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：观察者模式</title>
    <url>/2020/05/13/designPattern06/</url>
    <content><![CDATA[<p>观察者模式定义了对象之间一对多的关系，这样一来，当一个对象状态改变时，它的所有依赖者都会收到通知并自动更新。</p>
<p>我们可以举个例子，比如报纸或者杂志的订阅，我们读者属于订阅者，报纸或者杂志属于出版者，那么：</p>
<ol>
<li>向某家报纸社订阅报纸，只要他们有新报纸出版，就会给读者送过去，只要你是他的订阅者，那么你就一直会收到新报纸。</li>
<li>当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸过来了。</li>
<li>只要报纸社还在运营，就会一直有人向他们订阅报纸或者取消订阅报纸。</li>
</ol>
<a id="more"></a>

<p>以上就是一个典型的适用于观察者模式的案例，我们画个图说明一下：</p>
<p><img src="/img/designPattern/newspaper.png" alt="newspaper"></p>
<p>对于这种一对多的关系，我们常用 Subject 和 Observer 接口的类设计来进行实现：</p>
<p><img src="/img/designPattern/observer.png" alt="observer"></p>
<ul>
<li>Subject：这是主题接口，对象使用此接口注册为观察者，或者自己从观察者中删除</li>
<li>Observer：所有潜在的观察者都必须实现观察者接口，这个接口只有 update() 一个方法，当主题状态改变时它被调用</li>
<li>ConcreteSubject：一个具体主题总是实现主题接口，除了注册和撤销方法之外，具体主题还实现了 notifyObserver() 方法，此方法用于在改变状态时更新所有当前的观察者</li>
<li>ConcreteObserver：具体的观察者可以是实现此接口的任意类，观察者必须注册具体主题，以便接收更新</li>
</ul>
<blockquote>
<p>观察者模式提供一种对象设计，让主题和观察者之间松耦合。我们可以在代码中随时实现一个实现了 Observer 接口的新观察者，运行时也可以使用新观察者取代现有的观察者，主题不会收到任何的影响，同样可以在任何时候删除某些观察者。</p>
</blockquote>
<p>下面我们以微信公众号为例子，假设微信用户就是观察者，微信公众号是发布者，有多个用户关注了 Sanarous 这个公众号，当这个公众号更新时就会通知这些订阅者。</p>
<p>先抽象一个观察者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Observer&#123;</span><br><span class="line">	public void update(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个具体的观察者实现观察者接口，这个接口实现了更新的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class VXUser implements Observer&#123;</span><br><span class="line">	private String vxName;</span><br><span class="line"></span><br><span class="line">	public VXUser(String vxName)&#123;</span><br><span class="line">		this.vxName &#x3D; vxName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void update(String message)&#123;</span><br><span class="line">		System.out.println(name + &quot;，您专注的&quot; + message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了观察者之后，我们再定义发布者，也就是微信公众号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Subject&#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;增加订阅者</span><br><span class="line">	public void registerObserver(Observer observer);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;删除订阅者</span><br><span class="line">	public void  removeObserver(Observer observer);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;更新消息时通知订阅者</span><br><span class="line">	public void notify(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同上我们再定义一个具体的发布者类——微信公共号，内部维护了一个订阅该公众号的 list，并实现了接口中的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class VXSubscriptionSubject implements Subject&#123;</span><br><span class="line">	&#x2F;&#x2F;存储订阅公众号的微信用户</span><br><span class="line">	private List&lt;Observer&gt; vxUserList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void registerObserver(Observer observer)&#123;</span><br><span class="line">		vxUserList.add(observer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void removeObserver(Observer observer)&#123;</span><br><span class="line">		vxUserList.remove(observer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void notify(String message)&#123;</span><br><span class="line">		for(Observer ob : vxUserList)&#123;</span><br><span class="line">			observer.update(message);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就完成了整个观察者模式的基本功能，我们可以写一个客户端程序试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		VXSubscriptionSubject vxSub &#x3D; new VXSubscriptionSubject();</span><br><span class="line">		&#x2F;&#x2F;创建一个微信用户</span><br><span class="line">		VXUser user1 &#x3D; new VXUser(&quot;码农人生&quot;);</span><br><span class="line">		VXUser user2 &#x3D; new VXUser(&quot;kily-007&quot;);</span><br><span class="line">		VXUser user3 &#x3D; new VXUser(&quot;Chenzy&quot;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;订阅整个公众号</span><br><span class="line">		vxSub.registerObserver(user1);</span><br><span class="line">		vxSub.registerObserver(user2);</span><br><span class="line">		vxSub.registerObserver(user3);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;公共号发布新消息</span><br><span class="line">		vxSub.notify(&quot;Sanarous的专栏更新啦&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">码农人生，您关注的Sanarous的专栏更新啦</span><br><span class="line">kily-007，您关注的Sanarous的专栏更新啦</span><br><span class="line">Chenzy，您关注的Sanarous的专栏更新啦</span><br></pre></td></tr></table></figure>

<p>综上我们可以看到，观察者模式的实现接触了耦合，让双方都依赖于抽象，从而使得各自的变换都不会影响到另一方。但是在应用的时候需要考虑一下开发效率和运行效率的问题，程序中包含一个发布者，多个观察者，开发、调试等内容会比较复杂，而且在Java 中消息的通知一般是顺序执行，那么一个观察者卡顿了，会影响整体的执行效率，在这种情况下需要使用异步实现。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的索引</title>
    <url>/2020/04/21/MySQL01/</url>
    <content><![CDATA[<h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>   MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>   索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL  必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL  能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。</p>
<p>   我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear  search），这种复杂度为 O(n)  的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary  search）、二叉树查找（binary tree  search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>   索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。由于  MySQL 默认存储引擎为 InnoDB，因此下文只讨论 InnoDB  存储引擎下索引的实现。索引是应用程序设计和开发中的一个重要方面，若索引太多，应用程序的性能可能会受到影响，而索引太少，对查询性能又会产生影响。要找到一个合适的平衡点，这对应用程序性能至关重要。</p>
<a id="more"></a>

<h3 id="InnoDB存储引擎索引概述"><a href="#InnoDB存储引擎索引概述" class="headerlink" title="InnoDB存储引擎索引概述"></a>InnoDB存储引擎索引概述</h3><p>InnoDB 存储引擎支持以下几种常见的索引：</p>
<ul>
<li>B+ 树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<p>其中，InnoDB 存储引擎支持的哈希索引是自适应的， InnoDB 存储引擎会根据表的使用情况自动生成哈希索引，不能人为干预是否在一张表中生成哈希索引。<br>而 B+ 树索引就是传统意义上的索引，这是目前关系型数据库系统中查找最为常用和最为有效的索引，B+ 树索引的构造类似于二叉树，根据键值（key value）快速找到数据。</p>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>在介绍 B+ 树原理之前，有必要先介绍与其相近的二叉树相关知识，以便于更好的理解为什么数据库要选择 B+ 树作为索引的数据结构的原理。</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉查找树也称为有序二叉查找树，满足二叉查找树的一般性质，是指一棵空树具有如下性质：</p>
<ol>
<li>任意节点左子树不为空，则左子树的值均小于根节点的值；</li>
<li>任意节点右子树不为空，则右子树的值均大于于根节点的值；</li>
<li>任意节点的左右子树也分别是二叉查找树；</li>
<li>没有键值相等的节点；</li>
</ol>
<p><img src="/img/MySQL/binary-search-tree.png" alt="binary-search-tree"></p>
<p>上图为一个普通的二叉查找树，按照中序遍历的方式可以从小到大的顺序排序输出：2、3、5、6、7、8。</p>
<p>对上述二叉树进行查找，如查键值为  5 的记录，先找到根，其键值是 6，6 大于 5，因此查找 6 的左子树，找到 3；而 5 大于 3，再找其右子树；一共找了 3 次。如果按  2、3、5、6、7、8 的顺序来找同样需求 3 次。用同样的方法在查找键值为 8 的这个记录，这次用了 3 次查找，而顺序查找需要  6次。计算平均查找次数得：顺序查找的平均查找次数为<code>（1+2+3+4+5+6）/ 6 = 3.3</code>次，二叉查找树的平均查找次数为<code>（3+3+3+2+2+1）/ 6= 2.3</code>次。二叉查找树的平均查找速度比顺序查找来得更快。</p>
<p>二叉查找树可以任意构造，同样是上述数字，也可以构造为如下：</p>
<p><img src="/img/MySQL/binary-search-tree-2.png" alt=""></p>
<p>而上图的平均查找次数为<code>(1+2+3+4+5+5) / 6 = 3.16</code>次，和顺序查找差不多，显然这样构造的查询效率就比较低了。因此若想最大性能的构造一颗二叉查找树，需要这个二叉树是平衡的，也就是必须是平衡二叉树（AVL 树）。</p>
<h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>AVL  树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过  1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过  1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道 AVL  树适合用于插入删除次数比较少，但查找多的情况。</p>
<p>如下是插入新值 9 后平衡二叉树的变化：</p>
<p><img src="/img/MySQL/binary-tree-1.png" alt="binary-tree-1"></p>
<p>如下是需要多次旋转的 AVL 树：</p>
<p><img src="/img/MySQL/avl-2.png" alt="avl-2"></p>
<p>由上可知，由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么 AVL 还是较优于红黑树。</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是  red 或  black。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是若平衡，可以推出，相同的节点情况下，AVL  树的高度低于红黑树)，相对于要求严格的 AVL 树来说，它的旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。</p>
<p>红黑树具有以下性质：</p>
<ul>
<li>每个节点非红即黑；</li>
<li>根节点是黑的；</li>
<li>每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；</li>
<li>如果一个节点是红的,那么它的两儿子都是黑的；</li>
<li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；</li>
<li>每条路径都包含相同的黑节点；</li>
</ul>
<p>红黑树构造如下：</p>
<p><img src="/img/MySQL/1355319681_6107.png" alt="1355319681_6107"></p>
<p>其应用较为广泛：</p>
<ol>
<li>广泛用于 C++ 的 STL 中，Map 和 Set 都是用红黑树实现的；</li>
<li>著名的 Linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间；</li>
<li>IO 多路复用 epoll 的实现采用红黑树组织管理 sockfd，以支持快速的增删改查；</li>
<li>Nginx 中用红黑树管理 timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器；</li>
<li>Java 中 TreeMap、HashMap、ConcurrentHashMap 的实现；</li>
</ol>
<h3 id="B-B-树"><a href="#B-B-树" class="headerlink" title="B/B+ 树"></a>B/B+ 树</h3><p>说了上述的三种树：二叉查找树、AVL和红黑树，似乎我们还没有摸到 MySQL 为什么要使用 B+ 树作为索引的实现，不要急，接下来我们就先探讨一下什么是 B 树。</p>
<p>我们在  MySQL  中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过  B 树进行优化，提高磁盘读取时定位的效率。</p>
<p>为什么 B 类树可以进行优化呢？我们可以根据 B 类树的特点，构造一个多阶的 B  类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的 I/O 操作也少一些，而且 B  类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p>
<p>总的来说，B/B+  树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B 树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗  B/B+ 树的高度远远小于红黑树的高度(在下面 B/B+ 树的性能分析中会提到)。B/B+ 树上操作的时间通常由存取磁盘的时间和 CPU  计算时间这两部分构成，而 CPU 的速度非常快，所以 B 树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下 B 树的高度越小，磁盘  I/O 所花的时间越少。</p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B 树的性质：</p>
<ol>
<li>定义任意非叶子结点最多只有M个儿子，且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<p><img src="/img/MySQL/20180305203757434.png" alt="20180305203757434"></p>
<p>这里只是一个简单的 B 树，在实际中 B 树节点中关键字很多的，上面的图中比如 35 节点，35 代表一个 key (索引)，而小黑块代表的是这个 key 所指向的内容在内存中实际的存储位置，是一个指针。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+ 树是应文件系统所需而产生的一种 B 树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，这不就是文件系统文件的查找吗?</p>
<p>我们就举个文件查找的例子：有 3 个文件夹a、b、c， a包含b，b包含c，一个文件 yang.c，a、b、c就是索引（存储在非叶子节点）， a、b、c只是要找到的 yang.c 的key，而实际的数据 yang.c 存储在叶子节点上。</p>
<p>所有的非叶子节点都可以看成索引部分！</p>
<p>B+ 树有以下性质：</p>
<ol>
<li>非叶子节点的子树指针与关键字个数相同；</li>
<li>非叶子节点的子树指针 p[i] ,指向关键字值属于 [k[i],k[i+1]] 的子树。(B 树是开区间,也就是说B树不允许关键字重复，B+ 树允许重复)；</li>
<li>为所有叶子节点增加一个链指针；</li>
<li>所有关键字都在叶子节点出现（稠密索引）。 (且链表中的关键字恰好是有序的)；</li>
<li>非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据的数据层；</li>
<li>更适合于文件系统；</li>
</ol>
<p><img src="/img/MySQL/20180305204104694.png" alt="20180305204104694"></p>
<p>非叶子节点（比如5，28，65）只是一个key（索引），实际的数据存在叶子节点上（5，8，9）才是真正的数据或指向真实数据的指针。</p>
<h4 id="为什么说B-树比B树更适合数据库索引？"><a href="#为什么说B-树比B树更适合数据库索引？" class="headerlink" title="为什么说B+树比B树更适合数据库索引？"></a>为什么说B+树比B树更适合数据库索引？</h4><ol>
<li>B+  树的磁盘读写代价更低：B+  树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对  I/O 读写次数就降低了。</li>
<li>B+ 树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
<li>由于  B+ 树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是  B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以 B+ 树更加适合在区间查询的情况，所以通常 B+  树用于数据库索引。</li>
</ol>
<p>简而言之，数据库索引采用 B+ 树的主要原因是：B树在提高了 I/O  性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+ 树应用而生。B+  树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作或者说效率太低。</p>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>以下使用的 MySQL 数据库为 5.7.26 版本，不同版本显示结果略有不同。</p>
<h5 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a>创建表的时候创建索引</h5><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名[字段名 数据类型]  [UNIQUE|FULLTEXT|SPATIAL|...] [INDEX|KEY] [索引名字] (字段名[length]) 　　[ASC|DESC]</span><br></pre></td></tr></table></figure>

<p>对应意思如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通创建表语句　　设置什么样的索引(唯一、全文等)　　索引关键字　 索引名字　对哪个字段设置索引　　对索引进行排序</span><br></pre></td></tr></table></figure>

<h6 id="创建普通索引"><a href="#创建普通索引" class="headerlink" title="创建普通索引"></a>创建普通索引</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE book</span><br><span class="line">(</span><br><span class="line">   bookid INT NOT NULL,</span><br><span class="line">   bookname VARCHAR(255) NOT NULL,</span><br><span class="line">   authors VARCHAR(255) NULL,</span><br><span class="line">   info VARCHAR(255) NULL,</span><br><span class="line">   comment VARCHAR(255) NULL,</span><br><span class="line">   year_publication YEAR NOT NULL,</span><br><span class="line">   </span><br><span class="line">   INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者使用如下命令：</p>
<p>CREATE TABLE book<br>(<br>   bookid INT NOT NULL,<br>   bookname VARCHAR(255) NOT NULL,<br>   authors VARCHAR(255) NULL,<br>   info VARCHAR(255) NULL,<br>   comment VARCHAR(255) NULL,<br>   year_publication YEAR NOT NULL,</p>
<p>   KEY(year_publication)<br>);</p>
<p>创建之后，我们使用<code>Explain</code>查看创建的索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM book WHERE year_publication &#x3D; 2019\G;</span><br></pre></td></tr></table></figure>

<p>其输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM book where year_publication &#x3D; 2019\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: book</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: year_publication</span><br><span class="line">          key: year_publication</span><br><span class="line">      key_len: 1</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>其中每个符号代表的意义如下：</p>
<ol>
<li>id：SELECT 识别符。这是 SELECT 的查询序列号,也就是一条语句中，该 select 是第几次出现。在次语句中，select 就只有一个，所以是 1。</li>
<li>select_type：所使用的 SELECT 查询类型，SIMPLE 表示为简单的 SELECT，不实用 UNION 或子查询，就为简单的 SELECT。也就是说在该 SELECT 查询时会使用索引。其他取值，<code>PRIMARY</code>：最外面的 SELECT。拥有子查询时，就会出现两个以上的 SELECT。<code>UNION</code>：union (两张表连接)中的第二个或后面的 select 语句 <code>SUBQUERY</code>：在子查询中，第二 SELECT。</li>
<li>table：数据表的名字。他们按被读取的先后顺序排列，这里因为只查询一张表，所以只显示 book。</li>
<li>type：指定本数据表和其他数据表之间的关联关系，该表中所有符合检索值的记录都会被取出来和从上一个表中取出来的记录作联合。ref  用于连接程序使用键的最左前缀或者是该键不是 primary key 或  unique索引（换句话说，就是连接程序无法根据键值只取得一条记录）的情况。当根据键值只查询到少数几条匹配的记录时，这就是一个不错的连接类型。(注意，个人这里不是很理解，百度了很多资料，全是大白话，等以后用到了这类信息时，在回过头来补充，这里不懂对后面的影响不大。)可能的取值有  system、const、eq_ref、index和All。</li>
<li>possible_keys：MySQL 在搜索数据记录时可以选用的各个索引，该表中就只有一个索引 year_publication。</li>
<li>key：实际选用的索引</li>
<li>key_len：显示了  MySQL 使用索引的长度(也就是使用的索引个数)，当 key 字段的值为 null 时，索引的长度就是 null。注意，key_len  的值可以告诉你在联合索引中 mysql 会真正使用了哪些索引。这里就使用了 1 个索引，所以为 1。</li>
<li>ref：给出关联关系中另一个数据表中数据列的名字。常量（const），这里使用的是 1990，就是常量。</li>
<li>rows：MySQL 在执行这个查询时预计会从这个数据表里读出的数据行的个数。</li>
<li>extra：提供了与关联操作有关的信息，没有则什么都不写。　　　</li>
</ol>
<p>上面的一大堆东西能看懂多少看多少，我们最主要的是看 possible_keys 和 key 这两个属性，上面显示了 key 为year_publication。说明使用了索引。</p>
<h6 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;CREATE TABLE t1&#96;</span><br></pre></td></tr></table></figure>

<p>解释：对 id 字段使用了索引，并且索引名字为 UniqIdx。</p>
<p>我们使用命令<code>SHOW CREATE TABLE t1\G</code>查看建表语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;mysql&gt; SHOW CREATE TABLE t1\G********&#96;</span><br></pre></td></tr></table></figure>

<p>要查看其中查询时使用的索引，必须先往表中插入数据，然后在查询数据，不然查找一个没有的id值，是不会使用索引的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;INSE&#96;</span><br></pre></td></tr></table></figure>

<p>上述 EXPLAIN 结果为：</p>
<p><img src="/img/MySQL/111.png" alt="111"></p>
<p>可以看到，通过id查询时，会使用唯一索引。</p>
<h6 id="创建主键索引"><a href="#创建主键索引" class="headerlink" title="创建主键索引"></a>创建主键索引</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;CREATE TABLE &#96;</span><br></pre></td></tr></table></figure>

<p>分析后结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;mys&#96;</span><br></pre></td></tr></table></figure>

<p>通过这个主键索引，我们就应该反应过来，其实我们以前声明的主键约束，就是一个主键索引，只是之前我们没学过，不知道而已。</p>
<h6 id="创建单列索引"><a href="#创建单列索引" class="headerlink" title="创建单列索引"></a>创建单列索引</h6><p>这个其实就不用在说了，前面几个就是单列索引。</p>
<h6 id="创建组合索引"><a href="#创建组合索引" class="headerlink" title="创建组合索引"></a>创建组合索引</h6><p>组合索引就是在多个字段上创建一个索引。</p>
<p>创建一个表 t3，在表中的 id、name 和 age 字段上建立组合索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t3</span><br><span class="line">(</span><br><span class="line">  id INT NOT NULL,</span><br><span class="line">  name CHAR(30) NOT NULL,</span><br><span class="line">  age INT NOT NULL,</span><br><span class="line">  info VARCHAR(255),</span><br><span class="line">  INDEX MultiIdx(id,name,age)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW CREATE TABLE t3\G;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;mysq&#96;</span><br></pre></td></tr></table></figure>

<p>解释最左前缀：组合索引就是遵从了最左前缀，利用索引中最左边的列集来匹配行，这样的列集称为最左前缀，不明白没关系，举几个例子就明白了，例如，这里由id、name  和 age 3 个字段构成的索引，索引行中就按id/name/age  的顺序存放，索引可以索引下面字段组合(id，name，age)、(id，name)或者(id)。如果要查询的字段不构成索引最左面的前缀，那么就不会是用索引，比如，age  或者（name，age）组合就不会使用索引查询。</p>
<p>在 t3 表中，查询 id 和 name 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t3 where id &#x3D; 1 AND name &#x3D; &quot;zuoxiang&quot;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t3</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: MultiIdx   &#x2F;&#x2F;使用了组合索引</span><br><span class="line">          key: MultiIdx   &#x2F;&#x2F;使用了组合索引</span><br><span class="line">      key_len: 34</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>而 在t3表中，查询(age，name)字段，这样就不会使用索引查询。来看看结果 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;m&#96;</span><br></pre></td></tr></table></figure>

<h6 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h6><p>全文索引可以用于全文搜索，但只有 MyISAM 存储引擎支持 FULLTEXT 索引，并且只为 CHAR、VARCHAR 和TEXT 列服务。索引总是对整个列进行，不支持前缀索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;CREAT&#96;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;m&#96;</span><br></pre></td></tr></table></figure>

<p>使用一下什么叫做全文搜索。就是在很多文字中，通过关键字就能够找到该记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO t4 VALUES(8,&#39;AAA&#39;,3,&#39;text is so good，hei，my name is bob&#39;),(9,&#39;BBB&#39;,4,&#39;my name is gorlr&#39;);</span><br></pre></td></tr></table></figure>

<p>分析一下：</p>
<p><img src="/img/MySQL/222.png" alt="222"></p>
<p>注意：在使用全文搜索时，需要借助 MATCH 函数，并且其全文搜索的限制比较多，比如只能通过 MyISAM 引擎，比如只能在 CHAR ,  VARCHAR , TEXT 上设置全文索引。比如搜索的关键字默认至少要 4 个字符，比如搜索的关键字太短就会被忽略掉。</p>
<h6 id="创建空间索引"><a href="#创建空间索引" class="headerlink" title="创建空间索引"></a>创建空间索引</h6><p>空间索引也必须使用 MyISAM 引擎， 并且空间类型的字段必须为非空。 这个空间索引具体能干嘛我也不知道，可能跟游戏开发有关，可能跟别的东西有关，等遇到了自然就知道了，现在只要求能够创建出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;CREAT&#96;</span><br></pre></td></tr></table></figure>

<h5 id="在已经存在的表上创建索引"><a href="#在已经存在的表上创建索引" class="headerlink" title="在已经存在的表上创建索引"></a>在已经存在的表上创建索引</h5><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：ALTER TABLE 表名 ADD[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [索引名] (索引字段名)[ASC|DESC]</span><br></pre></td></tr></table></figure>

<p>有了上面的基础，这里就不用过多陈述了。</p>
<h6 id="为表添加索引"><a href="#为表添加索引" class="headerlink" title="为表添加索引"></a>为表添加索引</h6><p>就拿上面的book表来说。本来已经有了一个year_publication，现在我们为该表在加一个普通索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX BkNameIdx(bookname(30));</span><br></pre></td></tr></table></figure>

<p>看一下 book 表的索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;mysql&gt; s&#96;</span><br></pre></td></tr></table></figure>

<p>看输出结果，就能知道，添加索引成功了。</p>
<p>这里只是拿普通索引做个例子，添加其他索引也是一样的。依葫芦画瓢而已。这里就不一一做讲解了。</p>
<h6 id="使用CREATE-INDEX创建索引"><a href="#使用CREATE-INDEX创建索引" class="headerlink" title="使用CREATE INDEX创建索引"></a>使用CREATE INDEX创建索引</h6><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：CREATE [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] 索引名称 ON 表名(创建索引的字段名[length])[ASC|DESC]</span><br></pre></td></tr></table></figure>

<p>解释：其实就是换汤不换药，格式改变了一下而已，做的事情跟上面完全一样，做一个例子：在为 book 表增加一个普通索引，字段为 authors。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX BkBookNameIdx ON book(bookname);</span><br><span class="line">SHOW INDEX FROM book\G;　　&#x2F;&#x2F;查看book表中的索引</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM book\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: book</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: year_publication</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: year_publication</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: book</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: BkBookNameIdx</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: bookname</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><h5 id="ALTER-TABLE-表名-DROP-INDEX-索引名。"><a href="#ALTER-TABLE-表名-DROP-INDEX-索引名。" class="headerlink" title="ALTER TABLE 表名 DROP INDEX 索引名。"></a>ALTER TABLE 表名 DROP INDEX 索引名。</h5><p>很简单的语句，现在通过一个例子来看看，还是对book表进行操作，删除我们刚才为其添加的索引。</p>
<p>删除 book 表中的名称为 BkBookNameIdx 的索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ALTER TABL&#96;</span><br></pre></td></tr></table></figure>

<h5 id="DROP-INDEX-索引名-ON-表名；"><a href="#DROP-INDEX-索引名-ON-表名；" class="headerlink" title="DROP INDEX 索引名 ON 表名；"></a>DROP INDEX 索引名 ON 表名；</h5><p>删除book表中名为BkNameIdx的索引 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX BkNameIdx ON book;</span><br><span class="line">SHOW INDEX FROM book\G;</span><br></pre></td></tr></table></figure>

<h3 id="索引使用策略及优化"><a href="#索引使用策略及优化" class="headerlink" title="索引使用策略及优化"></a>索引使用策略及优化</h3><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。</p>
<h4 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h4><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p>
<p><img src="/img/MySQL/12.png" alt="12"></p>
<p>MySQL官方文档中关于此数据库的页面为<a href="http://dev.mysql.com/doc/employee/en/employee.html。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。" target="_blank" rel="noopener">http://dev.mysql.com/doc/employee/en/employee.html。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。</a></p>
<h4 id="最左前缀原理与相关优化"><a href="#最左前缀原理与相关优化" class="headerlink" title="最左前缀原理与相关优化"></a>最左前缀原理与相关优化</h4><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和 B+Tree 中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p>
<p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL  中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …,  an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p>
<p>以 employees.titles 表为例，下面先查看其上都有哪些索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM employees.titles;</span><br><span class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br><span class="line">| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |</span><br><span class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br><span class="line">| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |</span><br><span class="line">| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |</span><br><span class="line">| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |</span><br><span class="line">| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |</span><br><span class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br></pre></td></tr></table></figure>

<p>从结果中可以到titles表的主索引为&lt;emp_no, title,<br>from_date&gt;，还有一个辅助索引<emp_no>。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE employees.titles DROP INDEX emp_no;</span><br></pre></td></tr></table></figure>

<p>这样就可以专心分析索引PRIMARY的行为了。</p>
<h5 id="情况一：全列匹配。"><a href="#情况一：全列匹配。" class="headerlink" title="情况一：全列匹配。"></a>情况一：全列匹配。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title&#x3D;&#39;Senior Engineer&#39; AND from_date&#x3D;&#39;1986-06-26&#39;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br></pre></td></tr></table></figure>

<p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;EXP&#96;</span><br></pre></td></tr></table></figure>

<p>效果是一样的。</p>
<h5 id="情况二：最左前缀匹配。"><a href="#情况二：最左前缀匹配。" class="headerlink" title="情况二：最左前缀匹配。"></a>情况二：最左前缀匹配。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;EXPLAIN SELECT * FR&#96;</span><br></pre></td></tr></table></figure>

<p>当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或&lt;emp_no,  title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p>
<h5 id="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"><a href="#情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。" class="headerlink" title="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"></a>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;EXPLAIN&#96;</span><br></pre></td></tr></table></figure>

<p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no,   from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p>
<p>首先我们看下title一共有几种不同的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;SE&#96;</span><br></pre></td></tr></table></figure>

<p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;EX&#96;</span><br></pre></td></tr></table></figure>

<p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;SH&#96;</span><br></pre></td></tr></table></figure>

<p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p>
<h5 id="情况四：查询条件没有指定索引第一列。"><a href="#情况四：查询条件没有指定索引第一列。" class="headerlink" title="情况四：查询条件没有指定索引第一列。"></a>情况四：查询条件没有指定索引第一列。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;EXPLAI&#96;</span><br></pre></td></tr></table></figure>

<p>由于不是最左前缀，索引这样的查询显然用不到索引。</p>
<h5 id="情况五：匹配某列的前缀字符串。"><a href="#情况五：匹配某列的前缀字符串。" class="headerlink" title="情况五：匹配某列的前缀字符串。"></a>情况五：匹配某列的前缀字符串。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;EXPL&#96;</span><br></pre></td></tr></table></figure>

<p>此时可以用到索引，<del>但是如果通配符不是只出现在末尾，则无法使用索引。</del>（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p>
<h5 id="情况六：范围查询。"><a href="#情况六：范围查询。" class="headerlink" title="情况六：范围查询。"></a>情况六：范围查询。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; &#39;10010&#39; and title&#x3D;&#39;Senior Engineer&#39;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;EXPLAIN SE&#96;</span><br></pre></td></tr></table></figure>

<p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;EXPL&#96;</span><br></pre></td></tr></table></figure>

<p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p>
<h5 id="情况七：查询条件中含有函数或表达式。"><a href="#情况七：查询条件中含有函数或表达式。" class="headerlink" title="情况七：查询条件中含有函数或表达式。"></a>情况七：查询条件中含有函数或表达式。</h5><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND left(title, 6)&#x3D;&#39;Senior&#39;;</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+&#96;EXPLAIN SELECT * &#96;</span><br></pre></td></tr></table></figure>

<p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1&#x3D;&#39;10000&#39;;</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure>

<p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p>
<h4 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h4><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p>
<p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p>
<p>Index Selectivity = Cardinality / #T</p>
<p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;SELECT&#96;</span><br></pre></td></tr></table></figure>

<p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p>
<p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p>
<p>从图12可以看到employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;EXP&#96;</span><br></pre></td></tr></table></figure>

<p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;SELE&#96;</span><br></pre></td></tr></table></figure>

<p><first_name>显然选择性太低，&lt;first_name,  last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name,  left(last_name, 3)&gt;，看看其选择性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;SELE&#96;</span><br></pre></td></tr></table></figure>

<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))&#x2F;count(*) AS Selectivity FROM employees.employees;+--&#96;</span><br></pre></td></tr></table></figure>

<p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;AL&#96;</span><br></pre></td></tr></table></figure>

<p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;SHO&#96;</span><br></pre></td></tr></table></figure>

<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<h4 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h4><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>
<p><img src="/img/MySQL/13.png" alt="13"></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p>
<p><img src="/img/MySQL/14.png" alt="14"></p>
<p>此时 MySQL  不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过  OPTIMIZE TABLE 来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在 InnoDB 上采用自增字段做主键。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈HTTP中Get与Post的区别</title>
    <url>/2020/03/19/http02/</url>
    <content><![CDATA[<p>HTTP定义了与服务器交互的不同方法，最基本的方法通常是GET、POST、PUT和DELETE四种。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源。而HTTP中的四种基本操作，就对应于这个资源的增删改查。因此可以先简单理解为GET请求用于查询/获取资源信息，而POST请求一般用于新增资源信息。另外的PUT请求用于更新资源信息，DELETE请求用于删除个人信息。</p>
<a id="more"></a>

<h4 id="1、根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的"><a href="#1、根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的" class="headerlink" title="1、根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的"></a>1、根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的</h4><p>（1）所谓的安全意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不会产生有害的副作用，就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改、增加数据，不会影响资源状态。</p>
<p><strong>注意</strong>：这里的安全的含义仅仅是指不修改信息。</p>
<p>（2）幂等意味着对同一URL的多个请求应该返回同样的结果。</p>
<blockquote>
<p><strong>幂等</strong>（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。</p>
<p>幂等有一下几种定义： 　　</p>
<p> 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。 　　</p>
<p> 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。</p>
</blockquote>
<p>看完上述幂等的含义后，应该可以理解GET请求中的幂等含义的。</p>
<p>但是在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。</p>
<h4 id="2、根据HTTP规范，POST表示可能修改服务器上的资源的请求"><a href="#2、根据HTTP规范，POST表示可能修改服务器上的资源的请求" class="headerlink" title="2、根据HTTP规范，POST表示可能修改服务器上的资源的请求"></a>2、根据HTTP规范，POST表示可能修改服务器上的资源的请求</h4><p>继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。</p>
<p>上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：</p>
<ol>
<li>很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。</li>
<li>对资源的增删改查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。</li>
<li>另外一个是，早期的<code>Web MVC</code>框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的<code>Web MVC</code>框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。</li>
</ol>
<p>以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范），随着架构的发展，现在出现<code>REST</code>(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。</p>
<p><strong>说完原理性的问题，我们再从表面现象上面看看GET和POST的区别：</strong></p>
<p>（1）GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：<code>login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD</code>。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：<code>%E4%BD%A0%E5%A5%BD</code>，其中<code>％XX</code>中的<code>XX</code>为该符号以16进制表示的<code>ASCII</code>。</p>
<p>POST把提交的数据则放置在是HTTP包的<code>Request Body</code>（请求体）中。</p>
<p>（2）”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！</p>
<p>以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的：</p>
<p>首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如<code>Netscape</code>、<code>FireFox</code>等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。</p>
<p>理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在<code>80K/100K</code>的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用<code>Request.BinaryRead</code>则没有这个限制。由这个延伸出去，对于<code>IIS 6.0</code>，微软出于安全考虑，加大了限制。我们还需要注意：</p>
<ul>
<li>IIS 6.0默认ASP POST数据量最大为200KB，每个表单域限制是100KB。</li>
<li>IIS 6.0默认上传文件的最大大小是4MB。</li>
<li>IIS 6.0默认最大请求头是16KB。</li>
</ul>
<p>而IIS 6.0之前没有这些限制。</p>
<p>所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。</p>
<p>在ASP中，服务端获取GET请求参数用<code>Request.QueryString</code>，获取POST请求参数用<code>Request.Form</code>。在JSP中，用<code>request.getParameter(\&quot;XXXX\&quot;)</code>来获取，虽然jsp中也有<code>request.getQueryString()</code>方法，但使用起来比较麻烦，比如：传一个<code>test.jsp?name=hyddd&amp;password=hyddd</code>，用<code>request.getQueryString()</code>得到的是：<code>name=hyddd&amp;password=hyddd</code>。在PHP中，可以用<code>$_GET</code>和<code>$_POST</code>分别获取GET和POST中的数据，而<code>$_REQUEST</code>则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用<code>$_REQUEST</code>都会有隐患。</p>
<p>POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成<code>Cross-site request forgery</code>攻击。</p>
<p>总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP为什么是三次握手，而不是两次或者四次？</title>
    <url>/2020/04/22/tcp01/</url>
    <content><![CDATA[<p>TCP握手基本是应届生面试必问的一道计算机网络相关的问题，而TCP三次握手和四次挥手原理则是要求必须掌握的，但是当问及为什么是三次握手而不是四次握手或者两次握手的时候，很多人可能会搬出网上流传的高赞答案：</p>
<p><img src="/img/tcp/QQ%E5%9B%BE%E7%89%8720190403171729.png" alt="QQ图片20190403171729"></p>
<a id="more"></a>

<p>其实从原理上说，这种“大白话”解释真的对吗？</p>
<blockquote>
<p>实际上这种解释是不对的，下面来一一分析。</p>
</blockquote>
<p>随着对计算机网络的理解深入，我们实际上开始明白TCP报文是交由IP网络来负责运输，IP网络并不能保证TCP报文达到目的地，那么既然IP网络指望不上了，TCP就只能自己自力更生了，TCP必须依赖自身的努力来保证数据传输的可靠性。</p>
<p>TCP看似复杂，其实可以归纳为以下五种报文：</p>
<ol>
<li>SYN</li>
<li>Data（唯一携带用户数据）</li>
<li>FIN</li>
<li>Reset</li>
<li>ACK</li>
</ol>
<p>其中1、2、3分别为<strong>建立连接</strong>、<strong>数据传输</strong>、<strong>断开连接</strong>，这三种报文对方接收到一定要ACK确认，为何要确认，因为这就是可靠传输的依赖的机制。如果对方在超时时间内不确认，发送方会一直重发，直到对方确认为止、或达到重传上线次数而Reset连接。</p>
<h3 id="为何Reset报文不需要ACK确认？"><a href="#为何Reset报文不需要ACK确认？" class="headerlink" title="为何Reset报文不需要ACK确认？"></a>为何Reset报文不需要ACK确认？</h3><p>因为发送Reset报文的一端，在发送完这个报文之后，和该TCP Session有关的内存结构瞬间全部释放，无论对方收到或者没收到，关系并不大。</p>
<p>如果对方收到了Reset报文，也会释放该TCP Session的相关内存结构体。</p>
<p>如果对方没有收到Reset报文，也能会继续发送让接收方弹射出Reset报文的报文，到最后对方一样会收到Reset报文，并最终释放内存。</p>
<h3 id="为何ACK报文不需要ACK确认？"><a href="#为何ACK报文不需要ACK确认？" class="headerlink" title="为何ACK报文不需要ACK确认？"></a>为何ACK报文不需要ACK确认？</h3><p>这里的ACK报文，是指没有携带任何数据的裸ACK报文，对方收到这样的ACK报文，自然也不需要ACK，否则，对方为了ACK己方的ACK，那么己方收到对方的ACK，也要ACK对方的ACK，这就是一个死循环，永无止息。</p>
<p>所以为了避免这个死循环，一律不允许ACK对方的裸ACK报文。</p>
<p>有同学会说，按照这么说，TCP连接应该是四次信息交互啊。</p>
<table>
<thead>
<tr>
<th align="center">顺序</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">A发送给SYN给B，这是第一次报文交互</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">B发送ACK确认A的SYN报文，这是第二次报文交互</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">B发送自己的SYN报文给A，这是第三次报文交互</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">A需要ACK确认B的SYN报文，这是第四次报文交互</td>
</tr>
</tbody></table>
<p>以上的演绎没有问题，但是报文2、3为什么要分开发送呢？增加了延迟不说，同时还白白浪费了网络的带宽，完全可以将2和3合并起来，不就是在报文2的ACK状态位置“1”不就完事了吗？</p>
<p>这就是三次消息交互的由来！</p>
<p><strong>原文：</strong></p>
<p>TCP作为一种可靠传输控制协议，其<strong>核心思想</strong>：既要保证数据可靠传输，又要提高传输的效率，而用<strong>三次恰恰可以满足以上两方面的需求！</strong></p>
<p><strong>TCP可靠传输的精髓</strong>：TCP连接的一方A，由操作系统动态随机选取一个<strong>32位长的序列号（Initial Sequence Number），</strong>假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，让<strong>B有一个思想准备</strong>，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p>
<p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p>
<p>一句话概括：TCP握手连接，握的是啥？握的不就是通信双方数据原点的序列号嘛！</p>
<p>以此核心思想我们来分析二、三、四次握手的过程。</p>
<p>以A和B进行通信为例。</p>
<p><strong>四次握手的过程：</strong></p>
<table>
<thead>
<tr>
<th align="center">时序</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.1</td>
<td align="center">A 发送同步信号<strong>SYN</strong> + <strong>A’sInitial sequence number</strong></td>
</tr>
<tr>
<td align="center">1.2</td>
<td align="center">B 确认收到A的同步信号，并记录A’s ISN 到本地，命名 <strong>B’s ACK sequence number</strong></td>
</tr>
<tr>
<td align="center">1.3</td>
<td align="center">B发送同步信号<strong>SYN</strong> + <strong>B’s Initial sequence number</strong></td>
</tr>
<tr>
<td align="center">1.4</td>
<td align="center">A确认收到B的同步信号，并记录B’s ISN 到本地，命名 <strong>A’s ACK sequence number</strong></td>
</tr>
</tbody></table>
<p>很显然1.2和1.3 这两个步骤可以合并，<strong>只需要三次握手，</strong>可以提高连接的速度与效率。</p>
<p><strong>二次握手的过程：</strong></p>
<p><strong>2.1</strong> A 发送同步信号<strong>SYN</strong> + <strong>A’sInitial sequence number</strong></p>
<p><strong>2.2</strong> B发送同步信号<strong>SYN</strong> + <strong>B’sInitial sequence number</strong> + <strong>B’s ACK sequence number</strong></p>
<p>这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。<strong>但是</strong>B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，<strong>A和B就B的初始序列号将无法达成一致。</strong></p>
<p>于是TCP的设计者将<strong>SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是）</strong>，既然是一个字节的数据，按照TCP对有数据的TCP segment 必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。</p>
<p>有童鞋会说，如果A发给B的确认丢了，该如何？<br>A会超时重传这个ACK吗？不会！<strong>TCP不会为没有数据的ACK超时重传</strong>。</p>
<p>那该如何是好？<strong>B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</strong></p>
<p><strong>补充阅读</strong></p>
<p><strong>第一个包，即A发给B的SYN 中途被丢，没有到达B</strong></p>
<p>答：A会周期性超时重传，直到收到B的确认</p>
<p><strong>第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A</strong></p>
<p>答：B会周期性超时重传，直到收到A的确认</p>
<p><strong>第三个包，即A发给B的ACK 中途被丢，没有到达B</strong></p>
<p>答：A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：</p>
<p>a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。</p>
<p>b. 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data。</p>
<p>c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</p>
<p>本文转载自微信文章：<a href="https://mp.weixin.qq.com/s/NIjxgx4NPn7FC4PfkHBAAQ" target="_blank" rel="noopener">TCP 为什么是三次握手，而不是两次或四次？</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的I/O</title>
    <url>/2020/04/27/IO/</url>
    <content><![CDATA[<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<a id="more"></a>

<h1 id="二、磁盘操作"><a href="#二、磁盘操作" class="headerlink" title="二、磁盘操作"></a>二、磁盘操作</h1><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p>
<p>递归地列出一个目录下所有文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void listAllFiles(File dir) &#123;</span><br><span class="line">    if (dir &#x3D;&#x3D; null || !dir.exists()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dir.isFile()) &#123;</span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (File file : dir.listFiles()) &#123;</span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。</p>
<h1 id="三、字节操作"><a href="#三、字节操作" class="headerlink" title="三、字节操作"></a>三、字节操作</h1><h2 id="实现文件复制"><a href="#实现文件复制" class="headerlink" title="实现文件复制"></a>实现文件复制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public&#96;</span><br></pre></td></tr></table></figure>

<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<p><img src="/img/IO/9709694b-db05-4cce-8d2f-1c8b09f4d921.png" alt="9709694b-db05-4cce-8d2f-1c8b09f4d921"></p>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Fi&#96;</span><br></pre></td></tr></table></figure>

<p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p>
<h1 id="四、字符操作"><a href="#四、字符操作" class="headerlink" title="四、字符操作"></a>四、字符操作</h1><h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
<p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p>
<p>Java  的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be  进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<h2 id="String-的编码方式"><a href="#String-的编码方式" class="headerlink" title="String 的编码方式"></a>String 的编码方式</h2><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;String st&#96;</span><br></pre></td></tr></table></figure>

<p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char  存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes()  的默认编码方式与平台有关，一般为 UTF-8。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte[] bytes &#x3D; str1.getBytes();</span><br></pre></td></tr></table></figure>

<h2 id="Reader-与-Writer"><a href="#Reader-与-Writer" class="headerlink" title="Reader 与 Writer"></a>Reader 与 Writer</h2><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流；</li>
<li>OutputStreamWriter 实现字符流编码成为字节流。</li>
</ul>
<h2 id="实现逐行输出文本文件的内容"><a href="#实现逐行输出文本文件的内容" class="headerlink" title="实现逐行输出文本文件的内容"></a>实现逐行输出文本文件的内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public sta&#96;</span><br></pre></td></tr></table></figure>

<h1 id="五、对象操作"><a href="#五、对象操作" class="headerlink" title="五、对象操作"></a>五、对象操作</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    A a1 &#x3D; new A(123, &quot;abc&quot;);</span><br><span class="line">    String objectFile &#x3D; &quot;file&#x2F;a1&quot;;</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(objectFile));</span><br><span class="line">    objectOutputStream.writeObject(a1);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(objectFile));</span><br><span class="line">    A a2 &#x3D; (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class A implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private int x;</span><br><span class="line">    private String y;</span><br><span class="line"></span><br><span class="line">    A(int x, String y) &#123;</span><br><span class="line">        this.x &#x3D; x;</span><br><span class="line">        this.y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;x &#x3D; &quot; + x + &quot;  &quot; + &quot;y &#x3D; &quot; + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private transient Object[] elementData;</span><br></pre></td></tr></table></figure>

<h1 id="六、网络操作"><a href="#六、网络操作" class="headerlink" title="六、网络操作"></a>六、网络操作</h1><p>Java 中的网络支持：</p>
<ul>
<li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li>
<li>URL：统一资源定位符；</li>
<li>Sockets：使用 TCP 协议实现网络通信；</li>
<li>Datagram：使用 UDP 协议实现网络通信。</li>
</ul>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>没有公有的构造函数，只能通过静态方法来创建实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;InetAddress.getBy&#96;</span><br></pre></td></tr></table></figure>

<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>可以直接从 URL 中读取字节流数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;publi&#96;</span><br></pre></td></tr></table></figure>

<h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><ul>
<li>ServerSocket：服务器端类</li>
<li>Socket：客户端类</li>
<li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li>
</ul>
<p><img src="/img/IO/1e6affc4-18e5-4596-96ef-fb84c63bf88a.png" alt="1e6affc4-18e5-4596-96ef-fb84c63bf88a"></p>
<h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><ul>
<li>DatagramSocket：通信类</li>
<li>DatagramPacket：数据包类</li>
</ul>
<h1 id="七、NIO"><a href="#七、NIO" class="headerlink" title="七、NIO"></a>七、NIO</h1><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
<h2 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h2><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h2 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h2><h3 id="1-通道"><a href="#1-通道" class="headerlink" title="1. 通道"></a>1. 通道</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li>FileChannel：从文件中读写数据；</li>
<li>DatagramChannel：通过 UDP 读写网络中数据；</li>
<li>SocketChannel：通过 TCP 读写网络中数据；</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h3 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2. 缓冲区"></a>2. 缓冲区</h3><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区包括以下类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h2 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h2><ul>
<li>capacity：最大容量；</li>
<li>position：当前已经读写的字节数；</li>
<li>limit：还可以读写的字节数。</li>
</ul>
<p>状态变量的改变过程举例：</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p><img src="/img/IO/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="1bea398f-17a7-4f67-a90b-9e2d243eaa9a"></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p>
<p><img src="/img/IO/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="80804f52-8815-4096-b506-48eef3eed5c6"></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p><img src="/img/IO/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="952e06bd-5a65-4cab-82e4-dd1536462f38"></p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p><img src="/img/IO/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="b5bdcbe2-b958-4aef-9151-6ad963cb28b4"></p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p><img src="/img/IO/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="67bf5487-c45d-49b6-b9c0-a058d8c68902"></p>
<h2 id="文件-NIO-实例"><a href="#文件-NIO-实例" class="headerlink" title="文件 NIO 实例"></a>文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public&#96;</span><br></pre></td></tr></table></figure>

<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<p><img src="/img/IO/093f9e57-429c-413a-83ee-c689ba596cef.png" alt="093f9e57-429c-413a-83ee-c689ba596cef"></p>
<h3 id="1-创建选择器"><a href="#1-创建选择器" class="headerlink" title="1. 创建选择器"></a>1. 创建选择器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Selector selector &#x3D; Selector.open();</span><br></pre></td></tr></table></figure>

<h3 id="2-将通道注册到选择器上"><a href="#2-将通道注册到选择器上" class="headerlink" title="2. 将通道注册到选择器上"></a>2. 将通道注册到选择器上</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ServerSock&#96;</span><br></pre></td></tr></table></figure>

<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;publi&#96;</span><br></pre></td></tr></table></figure>

<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int interestSet &#x3D; SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<h3 id="3-监听事件"><a href="#3-监听事件" class="headerlink" title="3. 监听事件"></a>3. 监听事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num &#x3D; selector.select();</span><br></pre></td></tr></table></figure>

<p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h3 id="4-获取到达的事件"><a href="#4-获取到达的事件" class="headerlink" title="4. 获取到达的事件"></a>4. 获取到达的事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Set&lt;Sel&#96;</span><br></pre></td></tr></table></figure>

<h3 id="5-事件循环"><a href="#5-事件循环" class="headerlink" title="5. 事件循环"></a>5. 事件循环</h3><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;whil&#96;</span><br></pre></td></tr></table></figure>

<h2 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NIOClient &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket &#x3D; new Socket(&quot;127.0.0.1&quot;, 8888);</span><br><span class="line">        OutputStream out &#x3D; socket.getOutputStream();</span><br><span class="line">        String s &#x3D; &quot;hello world&quot;;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MappedByteBuffer mbb &#x3D; fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);</span><br></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>NIO 与普通 I/O 的区别主要有以下两点：</p>
<ul>
<li>NIO 是非阻塞的；</li>
<li>NIO 面向块，I/O 面向流。</li>
</ul>
<h1 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h1><ol>
<li>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</li>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM: NIO 入门</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO Tutorial</a></li>
<li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO 浅析</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">IBM: 深入分析 Java I/O 的工作机制</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html" target="_blank" rel="noopener">IBM: 深入分析 Java 中的中文编码问题</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener">IBM: Java 序列化的高级认识</a></li>
<li><a href="http://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener">NIO 与传统 IO 的区别</a></li>
<li><a href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document" target="_blank" rel="noopener">Decorator Design Pattern</a></li>
<li><a href="http://labojava.blogspot.com/2012/12/socket-multicast.html" target="_blank" rel="noopener">Socket Multicast</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP与HTTPS</title>
    <url>/2020/03/17/http01/</url>
    <content><![CDATA[<h1 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h1><ul>
<li>通信使用明文传输（不加密），内容可能会被窃听。</li>
<li>不验证通信方的身份，因此可能遭遇伪装。</li>
<li>无法证明报文的完整性，所以有可能已经遭遇篡改。</li>
</ul>
<p>这些问题不仅在HTTP上出现，其它未经加密的协议种也会存在这类问题。除此之外，HTTP本身还有很多缺点，而且，还有像某些特定的Web服务器和特定的Web浏览器在实际应用种存在的不足（也可以说成是脆弱性或安全漏洞），另外，用Java和PHP等编程语言开发的Web应用也可能存在安全漏洞。</p>
<a id="more"></a>

<h2 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h2><p>由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密，即：HTTP报文使用明文（指未经加密过的报文）方式发送。</p>
<h3 id="TCP-IP是可能被窃听的网络"><a href="#TCP-IP是可能被窃听的网络" class="headerlink" title="TCP/IP是可能被窃听的网络"></a>TCP/IP是可能被窃听的网络</h3><p>如果要问为什么通信时不加密是一个缺点，这是因为，按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭遇窥视。所谓互联网，是由能联通到全世界的网络组成的，无论世界上哪一个角落的服务器在和客户端进行通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能时个人的私有物，所以不排除某个环节遭到恶意窥视行为。</p>
<p>即使是已经加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法看到破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。</p>
<p><img src="/img/http/http%E9%81%AD%E9%81%87%E7%AA%83%E5%90%AC.png" alt="http遭遇窃听"></p>
<p>窃听相同段上的通信并非难事，只需要收集在互联网上流动的数据包（帧）就可以。对于收集来的数据包的解析工作，可以交给那些抓包（Packet Capture）或嗅探器（Sniffer）工具。</p>
<h3 id="加密处理防止被窃听"><a href="#加密处理防止被窃听" class="headerlink" title="加密处理防止被窃听"></a>加密处理防止被窃听</h3><p>在目前大家正在研究的如何防止窃听保护信息的几种对策种，最普及的就是加密技术，加密的对象可以有这么几个。</p>
<h4 id="通信的加密"><a href="#通信的加密" class="headerlink" title="通信的加密"></a>通信的加密</h4><p>一种方式就是将通信加密。HTTP协议种没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。</p>
<p>用SSL建立安全通信线路后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTPS over SSL。</p>
<p><img src="/img/http/https.png" alt="https"></p>
<h4 id="内容的加密"><a href="#内容的加密" class="headerlink" title="内容的加密"></a>内容的加密</h4><p>还有一种将参与通信的内容本身加密的方式。由于HTTP协议种没有加密机制，那么就对HTTP协议传输的内容本身进行加密。即把HTTP报文里所含的内容跟进行加密处理。</p>
<p>在这种情况下，客户端要对HTTP报文进行加密处理后再发送请求。</p>
<p><img src="/img/http/1.png" alt="1"></p>
<p>诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制，主要应用在Web服务种。有一点必须引起注意，由于该方式不同于SSL或TLS将整个通信线路进行加密处理，所以内容仍然有被篡改的风险。</p>
<h2 id="不验证通信方的身份就可能遭遇伪装"><a href="#不验证通信方的身份就可能遭遇伪装" class="headerlink" title="不验证通信方的身份就可能遭遇伪装"></a>不验证通信方的身份就可能遭遇伪装</h2><p>HTTP协议种的请求和响应不会对通信方进行确认，也就是说存在“服务器是否就是发送请求种URI真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。</p>
<h3 id="任何人可以发起请求"><a href="#任何人可以发起请求" class="headerlink" title="任何人可以发起请求"></a>任何人可以发起请求</h3><p>在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）。</p>
<p><img src="/img/http/2.png" alt="2"></p>
<p>HTTP协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。</p>
<ul>
<li>无法确定请求发送至目标的Web服务器是否是按照真实意图返回响应的那台服务器。有可能是已经伪装的Web服务器。</li>
<li>无法确定响应返回到的那台客户端是否是按真实意图接收响应的那个客户端。有可能是已经伪装的客户端。</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。</li>
<li>无法判定请求是来自何方、出自谁手。</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的Dos（Denial of Service，拒绝服务攻击）。</li>
</ul>
<h3 id="查明对手的证书"><a href="#查明对手的证书" class="headerlink" title="查明对手的证书"></a>查明对手的证书</h3><p>虽然使用HTTP协议无法确认通信方，但是如果使用SSL则可以，SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。</p>
<p>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。</p>
<p><img src="/img/http/3.png" alt="3"></p>
<p>通过使用证书，以证明通信方就是意料中的服务器，这对使用者个人来讲，也减少了个人信息泄露的危险性。</p>
<p>另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节。</p>
<h2 id="无法证明报文完整性，可能已遭篡改"><a href="#无法证明报文完整性，可能已遭篡改" class="headerlink" title="无法证明报文完整性，可能已遭篡改"></a>无法证明报文完整性，可能已遭篡改</h2><p>所谓完整性是指信息的准确度，若无法证明其完整性，通常也就意味着无法判断信息是否准确。</p>
<h3 id="接收到的内容可能有误"><a href="#接收到的内容可能有误" class="headerlink" title="接收到的内容可能有误"></a>接收到的内容可能有误</h3><p>由于HTTP协议无法证明通信报文的完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。</p>
<p>换句话说，没有任何办法确认，发送的请求/响应和接收到的请求/响应是前后相同的。</p>
<p><img src="/img/http/4.png" alt="4"></p>
<p>比如，从某个 Web 网站上下载内容，是无法确定客户端下载文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle<br>attack，MITM）。</p>
<p><img src="/img/http/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="中间人攻击"></p>
<h3 id="如何防止篡改"><a href="#如何防止篡改" class="headerlink" title="如何防止篡改"></a>如何防止篡改</h3><p>虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。</p>
<p><img src="/img/http/5.png" alt="5"></p>
<p>提供文件下载服务的 Web 网站也会提供相应的以 PGP（PrettyGood Privacy，完美隐私）创建的数字签名及 MD5  算法生成的散列值。PGP 是用来证明创建文件的数字签名，MD5  是由单向函数生成的散列值。不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为  PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。为了有效防止这些弊端，有必要使用  HTTPS。SSL提供认证和加密处理及摘要功能。仅靠 HTTP  确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。下节我们介绍HTTPS 的相关内容。</p>
<h1 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+ 加密 + 认证 + 完整性保护 = HTTPS"></a>HTTP+ 加密 + 认证 + 完整性保护 = HTTPS</h1><p>如果在  HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。另外，对于  HTTP  来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。为了统一解决上述这些问题，需要在  HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTPSecure）。</p>
<p><img src="/img/http/https%E9%80%9A%E4%BF%A1.png" alt="https通信"></p>
<p>经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用HTTPS 通信时，不再用 http://，而是改用  https://。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS  的显示方式会因浏览器的不同而有所改变。</p>
<p><img src="/img/http/https%E7%BD%91%E7%AB%99.png" alt="https网站"></p>
<h2 id="HTTPS是身披外壳的HTTP"><a href="#HTTPS是身披外壳的HTTP" class="headerlink" title="HTTPS是身披外壳的HTTP"></a>HTTPS是身披外壳的HTTP</h2><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p>
<p>通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通信，再由 SSL和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL协议这层外壳的 HTTP。</p>
<p><img src="/img/http/6.png" alt="6"></p>
<p>在采用 SSL后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p>
<p>SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是当今世界上应用最为广泛的网络安全技术。</p>
<h2 id="HTTPS的加密"><a href="#HTTPS的加密" class="headerlink" title="HTTPS的加密"></a>HTTPS的加密</h2><h3 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<p><img src="/img/http/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86.png" alt="对称密钥加密"></p>
<h3 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<p><img src="/img/http/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86.png" alt="非对称密钥加密"></p>
<h3 id="HTTPS采用的加密方式"><a href="#HTTPS采用的加密方式" class="headerlink" title="HTTPS采用的加密方式"></a>HTTPS采用的加密方式</h3><p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）</p>
<p><img src="/img/http/HTTPS%E5%8A%A0%E5%AF%86.png" alt="HTTPS加密"></p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<p><img src="/img/http/%E8%AE%A4%E8%AF%81.png" alt="认证"></p>
<h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h2 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h2><ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的容器</title>
    <url>/2020/03/26/collection/</url>
    <content><![CDATA[<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/img/collection/Collection.png" alt="Collection"></p>
<a id="more"></a>

<h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><ol>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li>
</ol>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/img/collection/Map.png" alt="Map"></p>
<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和  HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable  并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且  ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h1 id="二、容器中的设计模式"><a href="#二、容器中的设计模式" class="headerlink" title="二、容器中的设计模式"></a>二、容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><img src="/img/collection/Iterator.png" alt="Iterator"></p>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Lis&#96;</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;@SafeV&#96;</span><br></pre></td></tr></table></figure>

<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Int&#96;</span><br></pre></td></tr></table></figure>

<p>也可以使用以下方式调用 asList()：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List list &#x3D; Arrays.asList(1, 2, 3);</span><br></pre></td></tr></table></figure>

<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p>
<p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>实现了 RandomAccess 接口，因此支持随机访问。这是理所当然的，因为 ArrayList 是基于数组实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;pub&#96;</span><br></pre></td></tr></table></figure>

<p>数组的默认大小为 10。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;private static final int DEFAULT_CAPACITY &#x3D; 10;&#96;</span><br></pre></td></tr></table></figure>

<p><img src="/img/collection/ArrayList.png" alt="ArrayList"></p>
<h3 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public&#96;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h3><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public E rem&#96;</span><br></pre></td></tr></table></figure>

<h3 id="4-Fail-Fast"><a href="#4-Fail-Fast" class="headerlink" title="4. Fail-Fast"></a>4. Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;privat&#96;</span><br></pre></td></tr></table></figure>

<h3 id="5-序列化"><a href="#5-序列化" class="headerlink" title="5. 序列化"></a>5. 序列化</h3><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access</span><br></pre></td></tr></table></figure>

<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;privat&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException&#123;</span><br><span class="line">    &#x2F;&#x2F; Write out element count, and any hidden stuff</span><br><span class="line">    int expectedModCount &#x3D; modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out all elements in the proper order.</span><br><span class="line">    for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modCount !&#x3D; expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而  writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject()  来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ArrayList list &#x3D; new&#96;</span><br></pre></td></tr></table></figure>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h3><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;pub&#96;</span><br></pre></td></tr></table></figure>

<h3 id="2-与-ArrayList-的比较"><a href="#2-与-ArrayList-的比较" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h3><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="3-替代方案"><a href="#3-替代方案" class="headerlink" title="3. 替代方案"></a>3. 替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;List&#96;</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public bool&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">    return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;priv&#96;</span><br></pre></td></tr></table></figure>

<p>每个链表存储了 first 和 last 指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;tra&#96;</span><br></pre></td></tr></table></figure>

<p><img src="/img/collection/LinkedList.png" alt="LinkedList"></p>
<h3 id="2-与-ArrayList-的比较-1"><a href="#2-与-ArrayList-的比较-1" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h3><ul>
<li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li>
<li>ArrayList 支持随机访问，LinkedList 不支持；</li>
<li>LinkedList 在任意位置添加删除元素更快。</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p>
<h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p>内部包含了一个 Entry 类型的数组 table。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient Entry[] table;</span><br></pre></td></tr></table></figure>

<p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值相同的 Entry。</p>
<p><img src="/img/collection/HashMap.jpg" alt="HashMap"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    int hash;</span><br><span class="line"></span><br><span class="line">    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value &#x3D; v;</span><br><span class="line">        next &#x3D; n;</span><br><span class="line">        key &#x3D; k;</span><br><span class="line">        hash &#x3D; h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue &#x3D; value;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (!(o instanceof Map.Entry))</span><br><span class="line">            return false;</span><br><span class="line">        Map.Entry e &#x3D; (Map.Entry)o;</span><br><span class="line">        Object k1 &#x3D; getKey();</span><br><span class="line">        Object k2 &#x3D; e.getKey();</span><br><span class="line">        if (k1 &#x3D;&#x3D; k2 || (k1 !&#x3D; null &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 &#x3D; getValue();</span><br><span class="line">            Object v2 &#x3D; e.getValue();</span><br><span class="line">            if (v1 &#x3D;&#x3D; v2 || (v1 !&#x3D; null &amp;&amp; v1.equals(v2)))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() &#123;</span><br><span class="line">        return getKey() + &quot;&#x3D;&quot; + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;HashMa&#96;</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<p><img src="/img/collection/%E6%8B%89%E9%93%BE%E6%B3%95.jpg" alt="拉链法"></p>
<h3 id="3-put-操作"><a href="#3-put-操作" class="headerlink" title="3. put 操作"></a>3. put 操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public V &#96;</span><br></pre></td></tr></table></figure>

<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        if (e.key &#x3D;&#x3D; null) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(0, null, value, 0);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;v&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value &#x3D; v;</span><br><span class="line">    next &#x3D; n;</span><br><span class="line">    key &#x3D; k;</span><br><span class="line">    hash &#x3D; h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h3><p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;int &#96;</span><br></pre></td></tr></table></figure>

<p><strong>4.1 计算 hash 值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;final int hash(Object k) &#123;    &#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int hashCode() &#123;</span><br><span class="line">    return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 取模</strong></p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;x  &#96;</span><br></pre></td></tr></table></figure>

<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;y&#96;</span><br></pre></td></tr></table></figure>

<p>这个性质和 y 对 x 取模效果是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;y&#96;</span><br></pre></td></tr></table></figure>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;st&#96;</span><br></pre></td></tr></table></figure>

<h3 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h3><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">capacity</td>
<td align="left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td align="center">size</td>
<td align="left">键值对数量。</td>
</tr>
<tr>
<td align="center">threshold</td>
<td align="left">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td align="center">loadFactor</td>
<td align="left">装载因子，table 能够使用的比例，threshold = capacity * loadFactor。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;sta&#96;</span><br></pre></td></tr></table></figure>

<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;void addEntry(int hash, K key, V value, int bucketIndex) &#123;&#96;</span><br></pre></td></tr></table></figure>

<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;vo&#96;</span><br></pre></td></tr></table></figure>

<h3 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h3><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;capacit&#96;</span><br></pre></td></tr></table></figure>

<p>对于一个 Key，</p>
<ul>
<li>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；</li>
<li>如果为 1，那么得到的结果为原来的结果 +16。</li>
</ul>
<h3 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h3><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;mask |&#96;</span><br></pre></td></tr></table></figure>

<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;nu&#96;</span><br></pre></td></tr></table></figure>

<p>以下是 HashMap 中计算数组容量的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;sta&#96;</span><br></pre></td></tr></table></figure>

<h3 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h3><p>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</p>
<h3 id="9-与-HashTable-的比较"><a href="#9-与-HashTable-的比较" class="headerlink" title="9. 与 HashTable 的比较"></a>9. 与 HashTable 的比较</h3><ul>
<li>HashTable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    volatile V value;</span><br><span class="line">    volatile HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap  采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是  Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line"></span><br><span class="line">    static final int MAX_SCAN_RETRIES &#x3D;</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</span><br><span class="line"></span><br><span class="line">    transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    transient int count;</span><br><span class="line"></span><br><span class="line">    transient int modCount;</span><br><span class="line"></span><br><span class="line">    transient int threshold;</span><br><span class="line"></span><br><span class="line">    final float loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;&#96;</span><br></pre></td></tr></table></figure>

<p><img src="/img/collection/ConcurrentHashMap.jpg" alt="ConcurrentHashMap"></p>
<h3 id="2-size-操作"><a href="#2-size-操作" class="headerlink" title="2. size 操作"></a>2. size 操作</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;**&#96;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;**&#96;</span><br></pre></td></tr></table></figure>

<h3 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;**&#96;</span><br></pre></td></tr></table></figure>

<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;&#96;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;void a&#96;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;void a&#96;</span><br></pre></td></tr></table></figure>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap  并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;pr&#96;</span><br></pre></td></tr></table></figure>

<h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;clas&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache &#x3D; new LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(1, &quot;a&quot;);</span><br><span class="line">    cache.put(2, &quot;b&quot;);</span><br><span class="line">    cache.put(3, &quot;c&quot;);</span><br><span class="line">    cache.get(1);</span><br><span class="line">    cache.put(4, &quot;d&quot;);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3, 1, 4]</span><br></pre></td></tr></table></figure>

<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h3><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;public&#96;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002.</li>
<li><a href="https://www.w3resource.com/java-tutorial/java-collections.php" target="_blank" rel="noopener">Java Collection Framework</a></li>
<li><a href="https://openhome.cc/Gossip/DesignPattern/IteratorPattern.htm" target="_blank" rel="noopener">Iterator 模式</a></li>
<li><a href="https://tech.meituan.com/java_hashmap.html" target="_blank" rel="noopener">Java 8 系列之重新认识 HashMap</a></li>
<li><a href="http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html" target="_blank" rel="noopener">What is difference between HashMap and Hashtable in Java?</a></li>
<li><a href="http://www.zhangchangle.com/2018/02/07/Java集合之HashMap/" target="_blank" rel="noopener">Java 集合之 HashMap</a></li>
<li><a href="http://www.programering.com/a/MDO3QDNwATM.html" target="_blank" rel="noopener">The principle of ConcurrentHashMap analysis</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="noopener">探索 ConcurrentHashMap 高并发性的实现机制</a></li>
<li><a href="https://www.jianshu.com/p/75adf47958a7" target="_blank" rel="noopener">HashMap 相关面试题及其解答</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html" target="_blank" rel="noopener">Java 集合细节（二）：asList 的缺陷</a></li>
<li><a href="http://javaconceptoftheday.com/java-collection-framework-linkedlist-class/" target="_blank" rel="noopener">Java Collection Framework – The LinkedList Class</a></li>
</ol>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP必知必会的10个问题</title>
    <url>/2020/05/08/tcp02/</url>
    <content><![CDATA[<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p>TCP/IP 协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是 Internet 的核心协议。</p>
<p>基于 TCP/IP 的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示 TCP/IP 模型与 OSI 模型各层的对照关系。</p>
<p><img src="/img/tcp/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt="0fa6c237-a909-4e2a-a771-2c5485cd8ce0"></p>
<a id="more"></a>

<p>TCP/IP 协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有 HTTP，FTP  等等我们熟悉的协议。而第二层则是传输层，著名的 TCP 和 UDP 协议就在这个层次。第三层是网络层，IP 协议就在这里，它负责对数据加上 IP  地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行 CRC  编码，为最后的数据传输做准备。</p>
<p>其动态传输过程如下图所示：</p>
<p><img src="/img/tcp/computer-network.gif" alt="computer-network"></p>
<p>上图清楚地表示了 TCP/IP 协议中每个层的作用，而 TCP/IP<br>协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>物理层负责 0、1 比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将 0、1 序列划分为数据帧从一个节点传输到临近的另一个节点，这些节点是通过 MAC 来唯一标识的（MAC，物理地址，一个主机会有一个 MAC 地址）。</p>
<ul>
<li>封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源 MAC 地址和目的 MAC 地址。</li>
<li>透明传输:零比特填充、转义字符。</li>
<li>可靠传输: 在出错率很低的链路上很少用，但是无线链路 WLAN 会保证可靠传输。</li>
<li>差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP  协议是 TCP/IP 协议的核心，所有的 TCP，UDP，IMCP，IGMP 的数据都以 IP 数据格式传输。要注意的是，IP  不是可靠的协议，这是说，IP 协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP 或 UDP 要做的事情。</p>
<p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p>
<p>32 位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p>
<p>A 类 IP 地址：0.0.0.0<del>127.0.0.0<br>B 类 IP 地址：128.0.0.1</del>191.255.0.0<br>C 类 IP 地址：192.168.0.0~239.255.255.0</p>
<p>IP 协议头如下：</p>
<p><img src="/img/tcp/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="85c05fb1-5546-4c50-9221-21f231cdc8c5"></p>
<p>这里只介绍八位的 TTL 字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个 IP 数据包每穿过一个路由器，该数据包的 TTL 数值就会减少 1，当该数据包的TTL成为零，它就会被自动抛弃。</p>
<p>这个字段的最大值也就是 255，也就是说一个协议包也就在路由器里面穿行 255 次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是 32 或者是 64。</p>
<h4 id="ARP及RARP协议"><a href="#ARP及RARP协议" class="headerlink" title="ARP及RARP协议"></a>ARP及RARP协议</h4><p>ARP 是根据 IP 地址获取 MAC 地址的一种协议。</p>
<p>ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个 IP 对应的是哪个主机的哪个接口，当主机要发送一个 IP 包的时候，会首先查一下自己的ARP高速缓存（就是一个 IP-MAC 地址对应表缓存）。</p>
<p>如果查询的  IP－MAC 值对不存在，那么主机就向网络发送一个 ARP 协议广播包，这个广播包里面就有待查询的 IP  地址，而直接收到这份广播的包的所有主机都会查询自己的 IP 地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的 MAC  地址的 ARP 包传送给发送 ARP 广播的主机。</p>
<p>而广播主机拿到 ARP 包后会更新自己的 ARP 缓存（就是存放 IP-MAC 对应表的地方）。发送广播的主机就会用新的 ARP 缓存数据准备好数据链路层的的数据包发送工作。</p>
<p>RARP 协议的工作与此相反，不做赘述。</p>
<h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><p>IP 协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是 ICMP(网络控制报文)协议。ICMP 不是高层协议，而是 IP 层的协议。</p>
<p>当传送 IP 数据包发生错误。比如主机不可达，路由不可达等等，ICMP 协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在 IP 层以上的协议是可能做到安全的原因。</p>
<h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>ping 可以说是 ICMP 的最著名的应用，是 TCP/IP 协议的一部分。利用 ping 命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p>
<p>例如：当我们某一个网站上不去的时候。通常会 ping 一下这个网站。ping 会回显出一些有用的信息。</p>
<p>ping 这个单词源自声纳定位，而这个程序的作用也确实如此，它利用 ICMP 协议包来侦测另一个主机是否可达。原理是用类型码为 0 的 ICMP 发请 求，受到请求的主机则用类型码为 8 的 ICMP 回应。</p>
<p>ping 程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping 给出来了传送的时间和 TTL 的数据。</p>
<h3 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h3><p>Traceroute 是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p>
<p>Traceroute  的原理是非常非常的有意思，它收到到目的主机的 IP 后，首先给目的主机发送一个 TTL=1 的 UDP  数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减 1，而 TTL 变为 0 以后，路由器就把这个包给抛弃了，并同时产生  一个主机不可达的 ICMP 数据报给主机。主机收到这个数据报以后再发一个 TTL=2 的 UDP 数据报给目的主机，然后刺激第二个路由器给主机发  ICMP 数据报。如此往复直到到达目的主机。这样，traceroute 就拿到了所有的路由器 IP。</p>
<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><p>TCP/UDP 都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景。</p>
<ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议  TCP（Transmission Control  Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条  TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h4 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h4><p>面向报文的传输方式是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则 IP 层需要分片，降低效率。若太短，会是 IP 太小。</p>
<h4 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h4><p>面向字节流的话，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。</p>
<p>关于拥塞控制，流量控制，是 TCP 的重点，后面讲解。</p>
<h4 id="什么时候应该使用TCP"><a href="#什么时候应该使用TCP" class="headerlink" title="什么时候应该使用TCP"></a>什么时候应该使用TCP</h4><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。</p>
<h4 id="什么时候应该使用UDP"><a href="#什么时候应该使用UDP" class="headerlink" title="什么时候应该使用UDP"></a>什么时候应该使用UDP</h4><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP，比如网络直播。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS（Domain  Name System，域名系统），因特网上作为域名和 IP  地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。通过主机名，最终得到该主机名对应的  IP 地址的过程叫做域名解析（或主机名解析）。DNS 协议运行在 UDP 协议之上，使用端口号 53。</p>
<h3 id="TCP连接的建立与终止"><a href="#TCP连接的建立与终止" class="headerlink" title="TCP连接的建立与终止"></a>TCP连接的建立与终止</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP/IP 协议中， TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。</p>
<p><img src="/img/tcp/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif" alt="tcp三次握手"></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p><img src="/img/tcp/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="e92d0ebc-7d46-413b-aec1-34a39602f787"></p>
<h4 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h4><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/img/tcp/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.gif" alt="tcp四次挥手"></p>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<p><img src="/img/tcp/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="f87afe72-c2df-4c12-ac03-9b8d581a8af8"></p>
<h4 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h4><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>利用<strong>滑动窗口机制</strong>可以很方便地在 TCP 连接上实现对发送方的流量控制。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认（累积确认），例如接收窗口已经收到的字节为  {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31  进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="/img/tcp/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="a3253deb-8d21-40a1-aae4-7d178e4aa319"></p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p><img src="/img/tcp/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" alt="51e2ed95-65b8-4ae9-8af3-65602d452a25"></p>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<p><img src="/img/tcp/910f613f-514f-4534-87dd-9b4699d59d31.png" alt="910f613f-514f-4534-87dd-9b4699d59d31"></p>
<h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将  cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限  ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<p><img src="/img/tcp/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" alt="f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP知识点总结</title>
    <url>/2020/05/02/http03/</url>
    <content><![CDATA[<h1 id="一-、基础概念"><a href="#一-、基础概念" class="headerlink" title="一 、基础概念"></a>一 、基础概念</h1><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>URI 包含 URL 和 URN。</p>
<p><img src="/img/http/f66f9f573436858aeeb2ac3da732f5a9_720w.jpg" alt="f66f9f573436858aeeb2ac3da732f5a9_720w"></p>
<h2 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h2><h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1. 请求报文"></a>1. 请求报文</h3><p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f485454505f526571756573744d6573736167654578616d706c652e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f485454505f526571756573744d6573736167654578616d706c652e706e67"></p>
<a id="more"></a>

<h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2. 响应报文"></a>2. 响应报文</h3><p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f485454505f526573706f6e73654d6573736167654578616d706c652e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f485454505f526573706f6e73654d6573736167654578616d706c652e706e67"></p>
<h1 id="二、HTTP-方法"><a href="#二、HTTP-方法" class="headerlink" title="二、HTTP 方法"></a>二、HTTP 方法</h1><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><blockquote>
<p>获取资源</p>
</blockquote>
<p>当前网络请求中，绝大部分使用的是 GET 方法。</p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><blockquote>
<p>获取报文首部</p>
</blockquote>
<p>和 GET 方法类似，但是不返回报文实体主体部分。</p>
<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><blockquote>
<p>传输实体主体</p>
</blockquote>
<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>
<p>更多 POST 与 GET 的比较请见第九章。</p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><blockquote>
<p>上传文件</p>
</blockquote>
<p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;new.html HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text&#x2F;html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line">&lt;p&gt;New File&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><blockquote>
<p>对资源进行部分修改</p>
</blockquote>
<p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATCH &#x2F;file.txt HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application&#x2F;example</span><br><span class="line">If-Match: &quot;e0023aa4e&quot;</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure>

<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><blockquote>
<p>删除文件</p>
</blockquote>
<p>与 PUT 功能相反，并且同样不带验证机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;file.html HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><blockquote>
<p>查询支持的方法</p>
</blockquote>
<p>查询指定的 URL 能够支持的方法。</p>
<p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>
<h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><blockquote>
<p>要求在与代理服务器通信时建立隧道</p>
</blockquote>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;CONNECT www.example.com:443 HTTP&#x2F;1.1&#96;</span><br></pre></td></tr></table></figure>

<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f64633030663730652d633563382d346432302d626166312d3264373030313461393765332e6a7067.jpg" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f64633030663730652d633563382d346432302d626166312d3264373030313461393765332e6a7067"></p>
<h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><blockquote>
<p>追踪路径</p>
</blockquote>
<p>服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>
<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h1 id="三、HTTP-状态码"><a href="#三、HTTP-状态码" class="headerlink" title="三、HTTP 状态码"></a>三、HTTP 状态码</h1><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
</ul>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h1 id="四、HTTP-首部"><a href="#四、HTTP-首部" class="headerlink" title="四、HTTP 首部"></a>四、HTTP 首部</h1><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p>
<h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web 认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定 URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP 服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的 URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h1 id="五、具体应用"><a href="#五、具体应用" class="headerlink" title="五、具体应用"></a>五、具体应用</h1><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f48545450315f785f436f6e6e656374696f6e732e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f48545450315f785f436f6e6e656374696f6e732e706e67"></p>
<h3 id="1-短连接与长连接"><a href="#1-短连接与长连接" class="headerlink" title="1. 短连接与长连接"></a>1. 短连接与长连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>
<ul>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li>
</ul>
<h3 id="2-流水线"><a href="#2-流水线" class="headerlink" title="2. 流水线"></a>2. 流水线</h3><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie  曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie  渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或  IndexedDB。</p>
<h3 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h3><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h3 id="2-创建过程"><a href="#2-创建过程" class="headerlink" title="2. 创建过程"></a>2. 创建过程</h3><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK</span><br><span class="line">Content-type: text&#x2F;html</span><br><span class="line">Set-Cookie: yummy_cookie&#x3D;choco</span><br><span class="line">Set-Cookie: tasty_cookie&#x3D;strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;GET &#x2F;sample_page.html HTTP&#x2F;1.1Host: w&#96;</span><br></pre></td></tr></table></figure>

<h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h3><ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>

<h3 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4. 作用域"></a>4. 作用域</h3><p>Domain  标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了  Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如  developer.mozilla.org）。</p>
<p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>
<ul>
<li>/docs</li>
<li>/docs/Web/</li>
<li>/docs/Web/HTTP</li>
</ul>
<h3 id="5-JavaScript"><a href="#5-JavaScript" class="headerlink" title="5. JavaScript"></a>5. JavaScript</h3><p>通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;do&#96;</span><br></pre></td></tr></table></figure>

<h3 id="6-HttpOnly"><a href="#6-HttpOnly" class="headerlink" title="6. HttpOnly"></a>6. HttpOnly</h3><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<h3 id="7-Secure"><a href="#7-Secure" class="headerlink" title="7. Secure"></a>7. Secure</h3><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<h3 id="8-Session"><a href="#8-Session" class="headerlink" title="8. Session"></a>8. Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意  Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID  值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session  管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h3 id="9-浏览器禁用-Cookie"><a href="#9-浏览器禁用-Cookie" class="headerlink" title="9. 浏览器禁用 Cookie"></a>9. 浏览器禁用 Cookie</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h3 id="10-Cookie-与-Session-选择"><a href="#10-Cookie-与-Session-选择" class="headerlink" title="10. Cookie 与 Session 选择"></a>10. Cookie 与 Session 选择</h3><ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ul>
<li>缓解服务器压力；</li>
<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li>
</ul>
<h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><ul>
<li>让代理服务器进行缓存；</li>
<li>让客户端浏览器进行缓存。</li>
</ul>
<h3 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3. Cache-Control"></a>3. Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<p><strong>3.1 禁止进行缓存</strong></p>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>

<p><strong>3.2 强制确认缓存</strong></p>
<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>

<p><strong>3.3 私有缓存和公共缓存</strong></p>
<p>private 指令规定了将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure>

<p>public 指令规定了将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>

<p><strong>3.4 缓存过期机制</strong></p>
<p>max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;31536000</span><br></pre></td></tr></table></figure>

<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure>

<ul>
<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
</ul>
<h3 id="4-缓存验证"><a href="#4-缓存验证" class="headerlink" title="4. 缓存验证"></a>4. 缓存验证</h3><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETag: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>

<p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>

<p>Last-Modified   首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为  ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since  来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200  OK。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p>
<h3 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h3><p><strong>1.1 服务端驱动型</strong></p>
<p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p>
<p>它存在以下问题：</p>
<ul>
<li>服务器很难知道客户端浏览器的全部信息；</li>
<li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li>
<li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li>
</ul>
<p><strong>1.2 代理驱动型</strong></p>
<p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p>
<h3 id="2-Vary"><a href="#2-Vary" class="headerlink" title="2. Vary"></a>2. Vary</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure>

<p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p>
<p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code>内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p>
<h2 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h2><p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p>
<p>常用的内容编码有：gzip、compress、deflate、identity。</p>
<p>浏览器发送  Accept-Encoding  首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送  Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，在响应的 Vary  首部至少要包含 Content-Encoding。</p>
<h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p>
<h3 id="1-Range"><a href="#1-Range" class="headerlink" title="1. Range"></a>1. Range</h3><p>在请求报文中添加 Range 首部字段指定请求的范围。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;GET &#x2F;&#96;</span><br></pre></td></tr></table></figure>

<p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;HTTP&#96;</span><br></pre></td></tr></table></figure>

<h3 id="2-Accept-Ranges"><a href="#2-Accept-Ranges" class="headerlink" title="2. Accept-Ranges"></a>2. Accept-Ranges</h3><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<h3 id="3-响应状态码"><a href="#3-响应状态码" class="headerlink" title="3. 响应状态码"></a>3. 响应状态码</h3><ul>
<li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li>
<li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li>
<li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li>
</ul>
<h2 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h2><p>Chunked Transfer Coding，可以把数据分割成多块，让浏览器逐步显示页面。</p>
<h2 id="多部分对象集合"><a href="#多部分对象集合" class="headerlink" title="多部分对象集合"></a>多部分对象集合</h2><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p>
<p>例如，上传多个表单时可以使用如下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Content-&#96;</span><br></pre></td></tr></table></figure>

<h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>
<h2 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h2><h3 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h3><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p>
<p>使用代理的主要目的是：</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>网络访问控制</li>
<li>访问日志记录</li>
</ul>
<p>代理服务器分为正向代理和反向代理两种：</p>
<ul>
<li>用户察觉得到正向代理的存在。</li>
</ul>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f61333134626237392d356231382d346536332d613937362d3334343862666661366631622e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f61333134626237392d356231382d346536332d613937362d3334343862666661366631622e706e67"></p>
<ul>
<li>而反向代理一般位于内部网络中，用户察觉不到。</li>
</ul>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f32643039613834372d623835342d343339632d393139382d6232396336353831303934342e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f32643039613834372d623835342d343339632d393139382d6232396336353831303934342e706e67"></p>
<h3 id="2-网关"><a href="#2-网关" class="headerlink" title="2. 网关"></a>2. 网关</h3><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p>
<h3 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3. 隧道"></a>3. 隧道</h3><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p>
<h1 id="六、HTTPS"><a href="#六、HTTPS" class="headerlink" title="六、HTTPS"></a>六、HTTPS</h1><p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p>
<p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f73736c2d6f66666c6f6164696e672e6a7067.jpg" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f73736c2d6f66666c6f6164696e672e6a7067"></p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1. 对称密钥加密"></a>1. 对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f37666666613462382d623336642d343731662d616430632d6138386565373633626237362e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f37666666613462382d623336642d343731662d616430632d6138386565373633626237362e706e67"></p>
<h3 id="2-非对称密钥加密"><a href="#2-非对称密钥加密" class="headerlink" title="2.非对称密钥加密"></a>2.非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f33396363623239392d656539392d346464312d623862342d3266396563393439356362342e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f33396363623239392d656539392d346464312d623862342d3266396563393439356362342e706e67"></p>
<h3 id="3-HTTPS-采用的加密方式"><a href="#3-HTTPS-采用的加密方式" class="headerlink" title="3. HTTPS 采用的加密方式"></a>3. HTTPS 采用的加密方式</h3><p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）</p>
<p>![认证</p>
<p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f323031372d30362d31312d63612e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f323031372d30362d31312d63612e706e67"></p>
<h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h2 id="HTTPS-的缺点"><a href="#HTTPS-的缺点" class="headerlink" title="HTTPS 的缺点"></a>HTTPS 的缺点</h2><ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h1 id="七、HTTP-2-0"><a href="#七、HTTP-2-0" class="headerlink" title="七、HTTP/2.0"></a>七、HTTP/2.0</h1><h2 id="HTTP-1-x-缺陷"><a href="#HTTP-1-x-缺陷" class="headerlink" title="HTTP/1.x 缺陷"></a>HTTP/1.x 缺陷</h2><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p>
<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>
<h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h2><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f38366536613931642d613238352d343437612d393334352d6335343834623864306334372e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f38366536613931642d613238352d343437612d393334352d6335343834623864306334372e706e67"></p>
<p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p>
<ul>
<li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li>
<li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li>
<li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li>
</ul>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f61663139386461312d323438302d343034332d623037662d6133623931613838623831352e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f61663139386461312d323438302d343034332d623037662d6133623931613838623831352e706e67"></p>
<h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f65336631363537632d383066632d346466612d393634332d6266353161626432303163362e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f65336631363537632d383066632d346466612d393634332d6266353161626432303163362e706e67"></p>
<h2 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h2><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>
<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>
<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>
<p><img src="/img/http/68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f5f75344530425f75384637442e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f437943323031382f43532d4e6f7465732f7261772f6d61737465722f646f63732f706963732f5f75344530425f75384637442e706e67"></p>
<h1 id="八、HTTP-1-1-新特性"><a href="#八、HTTP-1-1-新特性" class="headerlink" title="八、HTTP/1.1 新特性"></a>八、HTTP/1.1 新特性</h1><p>详细内容请见上文</p>
<ul>
<li>默认是长连接</li>
<li>支持流水线</li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age</li>
</ul>
<h1 id="九、GET-和-POST-比较"><a href="#九、GET-和-POST-比较" class="headerlink" title="九、GET 和 POST 比较"></a>九、GET 和 POST 比较</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>GET 用于获取资源，而 POST 用于传输实体主体。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;test&#x2F;demo_form.asp?name1&#x3D;value1&amp;name2&#x3D;value2 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;POST &#x2F;test&#x2F;demo_form.asp HTTP&#96;</span><br></pre></td></tr></table></figure>

<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。</p>
<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;GET &#x2F;pageX HT&#96;</span><br></pre></td></tr></table></figure>

<p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;POST &#x2F;add&#96;</span><br></pre></td></tr></table></figure>

<p>DELETE /idX/delete HTTP/1.1 是幂等的，即便不同的请求接收到的状态码不一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;DEL&#96;</span><br></pre></td></tr></table></figure>

<h2 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h2><p>如果要对响应进行缓存，需要满足以下条件：</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p>
<blockquote>
<p>XMLHttpRequest  是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL  来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX  中被大量使用。</p>
</blockquote>
<ul>
<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li>
<li>而 GET 方法 Header 和 Data 会一起发送。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">MDN : HTTP</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li>
<li><a href="http://php.net/manual/zh/function.htmlspecialchars.php" target="_blank" rel="noopener">htmlspecialchars</a></li>
<li><a href="http://java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java" target="_blank" rel="noopener">Difference between file URI and URL in java</a></li>
<li><a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement" target="_blank" rel="noopener">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li>
<li><a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener">浅谈 HTTP 中 Get 与 Post 的区别</a></li>
<li><a href="https://www.webdancers.com/are-http-and-www-necesary/" target="_blank" rel="noopener">Are http:// and www really necessary?</a></li>
<li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="noopener">HTTP (HyperText Transfer Protocol)</a></li>
<li><a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/" target="_blank" rel="noopener">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li>
<li><a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg" target="_blank" rel="noopener">File:HTTP persistent connection.svg</a></li>
<li><a href="https://en.wikipedia.org/wiki/Proxy_server" target="_blank" rel="noopener">Proxy server</a></li>
<li><a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html" target="_blank" rel="noopener">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li>
<li><a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/" target="_blank" rel="noopener">What is SSL Offloading?</a></li>
<li><a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html" target="_blank" rel="noopener">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li>
<li><a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication" target="_blank" rel="noopener">An Introduction to Mutual SSL Authentication</a></li>
<li><a href="https://danielmiessler.com/study/url-uri/" target="_blank" rel="noopener">The Difference Between URLs and URIs</a></li>
<li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment" target="_blank" rel="noopener">Cookie 与 Session 的区别</a></li>
<li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">COOKIE 和 SESSION 有什么区别</a></li>
<li><a href="https://harttle.land/2015/08/10/cookie-session.html" target="_blank" rel="noopener">Cookie/Session 的机制与安全</a></li>
<li><a href="https://shijianan.com/2017/06/11/https/" target="_blank" rel="noopener">HTTPS 证书原理</a></li>
<li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" target="_blank" rel="noopener">What is the difference between a URI, a URL and a URN?</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a></li>
<li><a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/" target="_blank" rel="noopener">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li>
<li><a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences" target="_blank" rel="noopener">Symmetric vs. Asymmetric Encryption – What are differences?</a></li>
<li><a href="https://www.kancloud.cn/digest/web-performance-http2" target="_blank" rel="noopener">Web 性能优化与 HTTP/2</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的NIO</title>
    <url>/2020/05/20/NIO/</url>
    <content><![CDATA[<h1 id="NIO-概述"><a href="#NIO-概述" class="headerlink" title="NIO 概述"></a>NIO 概述</h1><p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然  Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如  Pipe 和 FileLock，只不过是与三个核心组件共同使用的工具类。因此，在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。</p>
<a id="more"></a>

<h2 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h2><p>基本上，所有的 IO 在 NIO 中都从一个 Channel 开始。Channel 有点象流。 数据可以从 Channel 读到 Buffer 中，也可以从 Buffer 写到 Channel 中。这里有个图示：</p>
<p><img src="/img/NIO/overview-channels-buffers1.png" alt="overview-channels-buffers1"></p>
<p>Channel 和 Buffer 有好几种类型。下面是 JAVA NIO 中的一些主要 Channel 的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了 UDP 和 TCP 网络 IO，以及文件 IO。 与这些类一起的有一些有趣的接口，但为简单起见，我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。</p>
<p>以下是 Java NIO 里关键的 Buffer 实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些 Buffer 覆盖了你能通过 IO 发送的基本数据类型：byte, short, int, long, float, double 和 char。</p>
<p>Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件，我也不打算在概述中说明。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector 允许单线程处理多个 Channel，如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用 Selector 就会很方便。例如，在一个聊天服务器中。</p>
<p>这是在一个单线程中使用一个 Selector 处理 3 个 Channel 的图示：</p>
<p><img src="/img/NIO/overview-selectors.png" alt="overview-selectors"></p>
<p>要使用 Selector ，得向 Selector 注册 Channel ，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>Java NIO 的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写。</li>
<li>通道中的数据总是要先读到一个 Buffer ，或者总是要从一个 Buffer 中写入。</li>
</ul>
<p>正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。</p>
<h2 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a>Channel的实现</h2><p>这些是 Java NIO 中最重要的通道的实现：</p>
<ul>
<li>FileChannel：从文件中读写数据</li>
<li>DatagramChannel：能够通过 UDP 读写网络中的数据</li>
<li>SocketChannel：能通过 TCP 读写网络中的数据</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，像 Web 服务器那样。对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h2 id="基本的Channel实例"><a href="#基本的Channel实例" class="headerlink" title="基本的Channel实例"></a>基本的Channel实例</h2><p>下面是一个使用 FileChannel 读取数据到 Buffer 中的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Rand&#96;</span><br></pre></td></tr></table></figure>

<p>注意 buf.flip() 的调用，首先读取数据到 Buffer ，然后反转 Buffer ,接着再从 Buffer 中读取数据。下一节会深入讲解 Buffer 的更多细节。</p>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>Java NIO中的 Buffer 用于和 NIO 通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。</p>
<p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p>
<p>下面是 NIO Buffer 相关的话题列表：</p>
<ol>
<li><a href="http://ifeve.com/buffers/#basicusage" target="_blank" rel="noopener">Buffer 的基本用法</a></li>
<li><a href="http://ifeve.com/buffers/#cap-pos-limit" target="_blank" rel="noopener">Buffer 的 capacity,position和 limit</a></li>
<li><a href="http://ifeve.com/buffers/#buffertype" target="_blank" rel="noopener">Buffer 的类型</a></li>
<li><a href="http://ifeve.com/buffers/#allocate" target="_blank" rel="noopener">Buffer 的分配</a></li>
<li><a href="http://ifeve.com/buffers/#writetobuffer" target="_blank" rel="noopener">向Buffer 中写数据</a></li>
<li><a href="http://ifeve.com/buffers/#flip" target="_blank" rel="noopener">flip() 方法</a></li>
<li><a href="http://ifeve.com/buffers/#read" target="_blank" rel="noopener">从 Buffer 中读取数据</a></li>
<li><a href="http://ifeve.com/buffers/#clearandcompact" target="_blank" rel="noopener">clear() 与 compact() 方法</a></li>
<li><a href="http://ifeve.com/buffers/#markandreset" target="_blank" rel="noopener">mark() 与 reset() 方法</a></li>
<li><a href="http://ifeve.com/buffers/#equalsandcompareto" target="_blank" rel="noopener">equals() 与 compareTo() 方法</a></li>
</ol>
<h2 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h2><p>使用 Buffer 读写数据一般遵循以下四个步骤：</p>
<ol>
<li>写入数据到 Buffer</li>
<li>调用 flip() 方法</li>
<li>从 Buffer 中读取数据</li>
<li>调用 clear() 方法或者 compact() 方法</li>
</ol>
<p>当向 buffer 写入数据时，buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 Buffer 的所有数据。</p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用  clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact()  方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
<p>下面是一个使用 Buffer 的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RandomAccessFile aFile &#x3D; new RandomAccessFile(&quot;data&#x2F;nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel &#x3D; aFile.getChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;create buffer with capacity of 48 bytes</span><br><span class="line">ByteBuffer buf &#x3D; ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">int bytesRead &#x3D; inChannel.read(buf); &#x2F;&#x2F;read into buffer.</span><br><span class="line">while (bytesRead !&#x3D; -1) &#123;</span><br><span class="line"></span><br><span class="line">  buf.flip();  &#x2F;&#x2F;make buffer ready for read</span><br><span class="line"></span><br><span class="line">  while(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((char) buf.get()); &#x2F;&#x2F; read 1 byte at a time</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.clear(); &#x2F;&#x2F;make buffer ready for writing</span><br><span class="line">  bytesRead &#x3D; inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>

<h2 id="Buffer-的-capacity-position-和-limit"><a href="#Buffer-的-capacity-position-和-limit" class="headerlink" title="Buffer 的 capacity,position 和 limit"></a>Buffer 的 capacity,position 和 limit</h2><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p>
<p>为了理解 Buffer 的工作原理，需要熟悉它的三个属性：</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>position 和 limit 的含义取决于 Buffer 处在读模式还是写模式。不管 Buffer 处在什么模式，capacity 的含义总是一样的。</p>
<p>这里有一个关于 capacity，position 和 limit 在读写模式中的说明，详细的解释在插图后面。</p>
<p><img src="/img/NIO/buffers-modes.png" alt="buffers-modes"></p>
<h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><p>作为一个内存块，Buffer 有一个固定的大小值，也叫 “capacity” .你只能往里写 capacity 个byte、long，char 等类型。一旦 Buffer 满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>当你写数据到  Buffer 中时，position 表示当前的位置。初始的 position 值为 0。当一个 byte、long 等数据写到 Buffer  后， position 会向前移动到下一个可插入数据的 Buffer 单元。position 最大可为 capacity – 1。</p>
<p>当读取数据时，也是从某个特定位置读。当将 Buffer 从写模式切换到读模式，position 会被重置为 0 . 当从 Buffer 的 position 处读取数据时，position 向前移动到下一个可读的位置。</p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。 写模式下，limit 等于 Buffer 的 capacity 。</p>
<p>当切换  Buffer 到读模式时， limit 表示你最多能读到多少数据。因此，当切换 Buffer 到读模式时，limit 会被设置成写模式下的  position 值。换句话说，你能读到之前写入的所有数据（limit 被设置成已写数据的数量，这个值在写模式下就是 position ）</p>
<h2 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h2><p>Java NIO 有以下 Buffer 类型</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>如你所见，这些 Buffer 类型代表了不同的数据类型。换句话说，就是可以通过 char，short，int，long，float 或 double 类型来操作缓冲区中的字节。 MappedByteBuffer 有些特别，在涉及它的专门章节中再讲。</p>
<h2 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h2><p>要想获得一个 Buffer 对象首先要进行分配。 每一个 Buffer 类都有一个 allocate 方法。下面是一个分配 48 字节 capacity 的 ByteBuffer 的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteBuffer buf &#x3D; ByteBuffer.allocate(48);</span><br></pre></td></tr></table></figure>

<p>这是分配一个可存储 1024 个字符的 CharBuffer：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CharBuffer buf &#x3D; CharBuffer.allocate(1024);</span><br></pre></td></tr></table></figure>

<h2 id="向-Buffer-中写数据"><a href="#向-Buffer-中写数据" class="headerlink" title="向 Buffer 中写数据"></a>向 Buffer 中写数据</h2><p>写数据到 Buffer 有两种方式：</p>
<ul>
<li>从 Channel 写到 Buffer。</li>
<li>通过 Buffer 的 put() 方法写到 Buffer 里。</li>
</ul>
<p>从 Channel 写到 Buffer 的例子 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int bytesRead &#x3D; inChannel.read(buf); &#x2F;&#x2F;read into buffer.</span><br></pre></td></tr></table></figure>

<p>通过 put 方法写 Buffer 的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buf.put(127);</span><br></pre></td></tr></table></figure>

<p>put 方法有很多版本，允许你以不同的方式把数据写入到 Buffer 中。例如， 写到一个指定的位置，或者把一个字节数组写入到 Buffer 。 更多 Buffer 实现的细节参考 JavaDoc 。</p>
<h3 id="filp-方法"><a href="#filp-方法" class="headerlink" title="filp 方法"></a>filp 方法</h3><p>flip 方法将 Buffer 从写模式切换到读模式。调用 flip() 方法会将 position 设回 0，并将 limit 设置成之前 position 的值。</p>
<p>换句话说，position 现在用于标记读的位置，limit 表示之前写进了多少个 byte、char 等 —— 现在能读取多少个 byte、char 等。</p>
<h2 id="从-Buffer-中读取数据"><a href="#从-Buffer-中读取数据" class="headerlink" title="从 Buffer 中读取数据"></a>从 Buffer 中读取数据</h2><p>从 Buffer 中读取数据有两种方式：</p>
<ol>
<li>从 Buffer 读取数据到 Channel 。</li>
<li>使用 get() 方法从 Buffer 中读取数据。</li>
</ol>
<p>从 Buffer 读取数据到 Channel 的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#x2F;&#x2F;rea&#96;</span><br></pre></td></tr></table></figure>

<p>使用 get() 方法从 Buffer 中读取数据的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte aByte &#x3D; buf.get();</span><br></pre></td></tr></table></figure>

<p>get 方法有很多版本，允许你以不同的方式从 Buffer 中读取数据。例如，从指定 position 读取，或者从 Buffer 中读取数据到字节数组。更多 Buffer 实现的细节参考 JavaDoc。</p>
<h3 id="rewind方法"><a href="#rewind方法" class="headerlink" title="rewind方法"></a>rewind方法</h3><p><code>Buffer.rewind()</code>将 position 设回 0，所以你可以重读 Buffer 中的所有数据。limit 保持不变，仍然表示能从 Buffer 中读取多少个元素（byte、char等）。</p>
<h3 id="clear-和-compact-方法"><a href="#clear-和-compact-方法" class="headerlink" title="clear() 和 compact() 方法"></a>clear() 和 compact() 方法</h3><p>一旦读完 Buffer 中的数据，需要让 Buffer 准备好再次被写入。可以通过 clear() 或 compact() 方法来完成。</p>
<p>如果调用的是 clear() 方法，position 将被设回 0，limit 被设置成 capacity 的值。换句话说，Buffer 被清空了。Buffer 中的数据并未清除，只是这些标记告诉我们可以从哪里开始往 Buffer 里写数据。</p>
<p>如果 Buffer 中有一些未读的数据，调用 clear() 方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p>
<p>如果 Buffer 中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用 compact() 方法。</p>
<p>compact()  方法将所有未读的数据拷贝到 Buffer 起始处。然后将 position 设到最后一个未读元素正后面。limit 属性依然像 clear()  方法一样，设置成 capacity 。现在 Buffer 准备好写数据了，但是不会覆盖未读的数据。</p>
<h3 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h3><p>通过调用 Buffer.mark() 方法，可以标记 Buffer 中的一个特定 position。之后可以通过调用 Buffer.reset() 方法恢复到这个 position。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;buffer&#96;</span><br></pre></td></tr></table></figure>

<h3 id="equals-和-compareTo-方法"><a href="#equals-和-compareTo-方法" class="headerlink" title="equals() 和 compareTo() 方法"></a>equals() 和 compareTo() 方法</h3><p>可以使用 equals() 和 compareTo() 方法两个 Buffer。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>当满足下列条件时，表示两个 Buffer 相等：</p>
<ol>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer 中剩余的 byte、char 等的个数相等。</li>
<li>Buffer 中所有剩余的 byte、char 等都相同。</li>
</ol>
<p>如你所见，equals 只是比较 Buffer 的一部分，不是每一个在它里面的元素都比较。实际上，它只比较 Buffer 中的剩余元素。</p>
<h4 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo() 方法"></a>compareTo() 方法</h4><p>compareTo() 方法比较两个 Buffer 的剩余元素(byte、char等)， 如果满足下列条件，则认为一个 Buffer “小于”另一个 Buffer：</p>
<ol>
<li>第一个不相等的元素小于另一个 Buffer 中对应的元素 。</li>
<li>所有元素都相等，但第一个 Buffer 比另一个先耗尽(第一个 Buffer 的元素个数比另一个少)。</li>
</ol>
<p><em>（注：剩余元素是从 position到limit之间的元素）</em></p>
<h1 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h1><p>Java NIO 开始支持 scatter/gather ，scatter/gather 用于描述从 Channel （译者注：Channel在中文经常翻译为通道）中读取或者写入到 Channel 的操作。<br>分散（scatter）从 Channel 中读取是指在读操作时将读取的数据写入多个 buffer 中。因此，Channel 将从 Channel 中读取的数据“分散（scatter）”到多个 Buffer 中。<br>聚集（gather）写入 Channel 是指在写操作时将多个buffer的数据写入同一个 Channel ，因此，Channel 将多个 Buffer 中的数据“聚集（gather）”后发送到Channel。</p>
<p>scatter / gather 经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的 buffer 中，这样你可以方便的处理消息头和消息体。</p>
<h2 id="Scattering-Reads"><a href="#Scattering-Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h2><p>Scattering Reads 是指数据从一个 Channel 读取到多个 Buffer 中。如下图描述：</p>
<p><img src="/img/NIO/scatter.png" alt="scatter"></p>
<p>代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ByteBuffer &#96;</span><br></pre></td></tr></table></figure>

<p>注意 buffer 首先被插入到数组，然后再将数组作为 channel.read() 的输入参数。read() 方法按照 buffer  在数组中的顺序将从 channel 中读取的数据写入到 buffer ，当一个 buffer 被写满后，channel 紧接着向另一个  buffer 中写。</p>
<p>Scattering Reads 在移动下一个 buffer 前，必须填满当前的 buffer  ，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如  128byte），Scattering Reads 才能正常工作。</p>
<h2 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h2><p>Gathering Writes 是指数据从多个 buffer 写入到同一个 channel 。如下图描述：</p>
<p><img src="/img/NIO/gather.png" alt="gather"></p>
<p>代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ByteBu&#96;</span><br></pre></td></tr></table></figure>

<p>buffers 数组是 write() 方法的入参，write() 方法会按照 buffer 在数组中的顺序，将数据写入到  channel，注意只有 position 和 limit 之间的数据才会被写入。因此，如果一个 buffer  的容量为128byte，但是仅仅包含 58byte 的数据，那么这 58byte 的数据将被写入到 channel 中。因此与  Scattering Reads 相反，Gathering Writes 能较好的处理动态消息。</p>
<h1 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h1><p>在 Java NIO 中，如果两个通道中有一个是 FileChannel ，那你可以直接将数据从一个 channel（译者注：channel中文常译作通道）传输到另外一个 channel。</p>
<h2 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h2><p>FileChannel 的 transferFrom() 方法可以将数据从源通道传输到 FileChannel 中（译者注：这个方法在 JDK 文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;RandomA&#96;</span><br></pre></td></tr></table></figure>

<p>方法的输入参数 position 表示从 position 处开始向目标文件写入数据，count  表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。 此外要注意，在  SoketChannel 的实现中，SocketChannel 只会传输此刻准备好的数据（可能不足 count  字节）。因此，SocketChannel 可能不会将请求的所有数据(count 个字节)全部传输到 FileChannel 中。</p>
<h2 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h2><p>transferTo() 方法将数据从 FileChannel 传输到其他的 channel 中。下面是一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RandomAccessFile fromFile &#x3D; new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      fromChannel &#x3D; fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile &#x3D; new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      toChannel &#x3D; toFile.getChannel();</span><br><span class="line"></span><br><span class="line">long position &#x3D; 0;</span><br><span class="line">long count &#x3D; fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>

<p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的 FileChannel 对象不一样外，其他的都一样。</p>
<p>上面所说的关于 SocketChannel 的问题在 transferTo() 方法中同样存在。SocketChannel 会一直传输数据直到目标 buffer 被填满。</p>
<h1 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h1><p>Selector（选择器）是 Java NIO 中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个 channel，从而管理多个网络连接。</p>
<p>下面是本文所涉及到的主题列表：</p>
<ol>
<li><a href="http://ifeve.com/selectors/#Why" target="_blank" rel="noopener">为什么使用Selector?</a></li>
<li><a href="http://ifeve.com/selectors/#Creating" target="_blank" rel="noopener">Selector的创建</a></li>
<li><a href="http://ifeve.com/selectors/#Registering" target="_blank" rel="noopener">向Selector注册通道</a></li>
<li><a href="http://ifeve.com/selectors/#SelectionKey" target="_blank" rel="noopener">SelectionKey</a></li>
<li><a href="http://ifeve.com/selectors/#Selecting" target="_blank" rel="noopener">通过Selector选择通道</a></li>
<li><a href="http://ifeve.com/selectors/#wakeUp" target="_blank" rel="noopener">wakeUp()</a></li>
<li><a href="http://ifeve.com/selectors/#close" target="_blank" rel="noopener">close()</a></li>
<li><a href="http://ifeve.com/selectors/#Full" target="_blank" rel="noopener">完整的示例</a></li>
</ol>
<h2 id="为什么要使用-Selector？"><a href="#为什么要使用-Selector？" class="headerlink" title="为什么要使用 Selector？"></a>为什么要使用 Selector？</h2><p>仅用单个线程来处理多个 Channels 的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。</p>
<p>但是，需要记住，现代的操作系统和  CPU 在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个 CPU  有多个内核，不使用多任务可能是在浪费 CPU 能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用  Selector 能够处理多个通道就足够了。</p>
<p>下面是单线程使用一个 Selector 处理 3 个 channel 的示例图：</p>
<p><img src="/img/NIO/093f9e57-429c-413a-83ee-c689ba596cef.png" alt="093f9e57-429c-413a-83ee-c689ba596cef"></p>
<h2 id="Selector-的创建"><a href="#Selector-的创建" class="headerlink" title="Selector 的创建"></a>Selector 的创建</h2><p>通过调用 Selector.open() 方法创建一个 Selector，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Selector selector &#x3D; Selector.open();</span><br></pre></td></tr></table></figure>

<h2 id="向-Selector-注册通道"><a href="#向-Selector-注册通道" class="headerlink" title="向 Selector 注册通道"></a>向 Selector 注册通道</h2><p>为了将 Channel 和 Selector 配合使用，必须将 channel 注册到 selector 上。通过 SelectableChannel.register() 方法来实现，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;channel.configu&#96;</span><br></pre></td></tr></table></figure>

<p>与 Selector 一起使用时，Channel 必须处于非阻塞模式下。这意味着不能将 FileChannel 与 Selector 一起使用，因为 FileChannel 不能切换到非阻塞模式。而套接字通道都可以。</p>
<p>注意 register() 方法的第二个参数。这是一个“interest集合”，意思是在通过 Selector 监听 Channel 时对什么事件感兴趣。可以监听四种不同类型的事件：</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>通道触发了一个事件意思是该事件已经就绪。所以，某个  channel 成功连接到另一个服务器称为“连接就绪”。一个server socket  channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p>
<p>这四种事件用 SelectionKey 的四个常量来表示：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int interestSet &#x3D; SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<p>在下面还会继续提到 interest 集合。</p>
<h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>在上一小节中，当向 Selector 注册 Channel 时，register() 方法会返回一个 SelectionKey 对象。这个对象包含了一些你感兴趣的属性：</p>
<ul>
<li>interest集合</li>
<li>ready集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加的对象（可选)</li>
</ul>
<p>下面我会描述这些属性。</p>
<h3 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h3><p>就像向 Selector 注册通道一节中所描述的，interest 集合是你所选择的感兴趣的事件集合。可以通过 SelectionKey 读写 interest 集合，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;int inter&#96;</span><br></pre></td></tr></table></figure>

<p>可以看到，用“位与”操作 interest 集合和给定的 SelectionKey 常量，可以确定某个确定的事件是否在 interest 集合中。</p>
<h3 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h3><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个 ready set。Selection 将在下一小节进行解释。可以这样访问 ready 集合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;int&#96;</span><br></pre></td></tr></table></figure>

<p>可以用像检测 interest 集合那样的方法，来检测 channel 中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;sel&#96;</span><br></pre></td></tr></table></figure>

<h3 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h3><p>从 SelectionKey 访问 Channel 和 Selector 很简单。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Channe&#96;</span><br></pre></td></tr></table></figure>

<h3 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h3><p>从 SelectionKey 访问 Channel 和 Selector 很简单。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Channel  cha&#96;</span><br></pre></td></tr></table></figure>

<p>还可以在用 register() 方法向 Selector 注册 Channel 的时候附加对象。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SelectionKey key &#x3D; channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>

<h2 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h2><p>一旦向  Selector 注册了一或多个通道，就可以调用几个重载的 select()  方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()  方法会返回读事件已经就绪的那些通道。</p>
<p>下面是 select() 方法：</p>
<ul>
<li>int select()：阻塞到至少有一个通道在你注册的事件上就绪了</li>
<li>int select(long timeout)：和select()一样，除了最长会阻塞timeout毫秒(参数)。</li>
<li>int selectNow()：不会阻塞，不管什么通道就绪都立刻返回（<em>译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。</em>）。</li>
</ul>
<p>select()  方法返回的 int 值表示有多少通道已经就绪。亦即，自上次调用 select() 方法后有多少通道变成就绪状态。如果调用 select()  方法，因为有一个通道变成就绪状态，返回了 1，若再次调用 select() 方法，如果另一个通道就绪了，它会再次返回 1。如果对第一个就绪的  channel 没有做任何操作，现在就有两个就绪的通道，但在每次 select() 方法调用之间，只有一个通道就绪了。</p>
<h2 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h2><p>一旦调用了 select() 方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用 selector 的 selectedKeys() 法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set selectedKeys &#x3D; selector.selectedKeys();</span><br></pre></td></tr></table></figure>

<p>当像  Selector 注册 Channel 时，Channel.register() 方法会返回一个 SelectionKey  对象。这个对象代表了注册到该 Selector 的通道。可以通过 SelectionKey 的 selectedKeySet()  方法访问这些对象。</p>
<p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Set se&#96;</span><br></pre></td></tr></table></figure>

<p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</p>
<p>注意每次迭代末尾的 keyIterator.remove() 调用。Selector 不会自己从已选择键集中移除 SelectionKey 实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector 会再次将其放入已选择键集中。</p>
<p>SelectionKey.channel() 方法返回的通道需要转型成你要处理的类型，如 ServerSocketChannel 或 SocketChannel 等。</p>
<h2 id="wakeup"><a href="#wakeup" class="headerlink" title="wakeup()"></a>wakeup()</h2><p>某个线程调用  select() 方法后阻塞了，即使没有通道已经就绪，也有办法让其从 select() 方法返回。只要让其它线程在第一个线程调用  select() 方法的那个对象上调用 Selector.wakeup() 方法即可。阻塞在 select() 方法上的线程会立马返回。</p>
<p>如果有其它线程调用了 wakeup() 方法，但当前没有线程阻塞在 select() 方法上，下个调用 select() 方法的线程会立即“醒来（wake up）”。</p>
<h2 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h2><p>用完 Selector 后调用其 close() 方法会关闭该 Selector，且使注册到该 Selector 上的所有 SelectionKey 实例无效。通道本身并不会关闭。</p>
<h2 id="完整的实例"><a href="#完整的实例" class="headerlink" title="完整的实例"></a>完整的实例</h2><p>这里有一个完整的示例，打开一个 Selector，注册一个通道注册到这个 Selector 上(通道的初始化过程略去),然后持续监控这个 Selector 的四种事件（接受，连接，读，写）是否就绪。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Selector selector &#x3D; Selector.open();</span><br><span class="line">channel.configureBlocking(false);</span><br><span class="line">SelectionKey key &#x3D; channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">while(true) &#123;</span><br><span class="line">  int readyChannels &#x3D; selector.select();</span><br><span class="line">  if(readyChannels &#x3D;&#x3D; 0) continue;</span><br><span class="line">  Set selectedKeys &#x3D; selector.selectedKeys();</span><br><span class="line">  Iterator keyIterator &#x3D; selectedKeys.iterator();</span><br><span class="line">  while(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key &#x3D; keyIterator.next();</span><br><span class="line">    if(key.isAcceptable()) &#123;</span><br><span class="line">        &#x2F;&#x2F; a connection was accepted by a ServerSocketChannel.</span><br><span class="line">    &#125; else if (key.isConnectable()) &#123;</span><br><span class="line">        &#x2F;&#x2F; a connection was established with a remote server.</span><br><span class="line">    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">        &#x2F;&#x2F; a channel is ready for reading</span><br><span class="line">    &#125; else if (key.isWritable()) &#123;</span><br><span class="line">        &#x2F;&#x2F; a channel is ready for writing</span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h1><p>Java NIO 中的 FileChannel 是一个连接到文件的通道。可以通过文件通道读写文件。</p>
<p>FileChannel 无法设置为非阻塞模式，它总是运行在阻塞模式下。、</p>
<h2 id="FileChannel-1"><a href="#FileChannel-1" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>在使用  FileChannel 之前，必须先打开它。但是，我们无法直接打开一个 FileChannel，需要通过使用一个  InputStream、OutputStream 或 RandomAccessFile 来获取一个 FileChannel 实例。下面是通过  RandomAccessFile 打开 File Channel 的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;RandomA&#96;</span><br></pre></td></tr></table></figure>

<h2 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h2><p>调用多个 read() 方法之一从 FileChannel 中读取数据。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ByteBuffer buf &#x3D; ByteBuffer.allocate(48);int byte&#96;</span><br></pre></td></tr></table></figure>

<p>首先，分配一个 Buffer。从 FileChannel 中读取的数据将被读到 Buffer 中。</p>
<p>然后，调用 FileChannel.read() 方法。该方法将数据从 FileChannel 读取到 Buffer 中。read() 方法返回的 int 值表示了有多少字节被读到了 Buffer 中。如果返回 -1，表示到了文件末尾。</p>
<h2 id="向FileChannel中写数据"><a href="#向FileChannel中写数据" class="headerlink" title="向FileChannel中写数据"></a>向FileChannel中写数据</h2><p>使用 FileChannel.write() 方法向 FileChannel 写数据，该方法的参数是一个 Buffer。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Stri&#96;</span><br></pre></td></tr></table></figure>

<p>注意 FileChannel.write() 是在 while 循环中调用的。因为无法保证 write() 方法一次能向 FileChannel 写入多少字节，因此需要重复调用 write() 方法，直到 Buffer 中已经没有尚未写入通道的字节。</p>
<h2 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h2><p>用完 FileChannel 后必须将其关闭。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<h2 id="FileChannel-的-position-方法"><a href="#FileChannel-的-position-方法" class="headerlink" title="FileChannel 的 position 方法"></a>FileChannel 的 position 方法</h2><p>有时可能需要在 FileChannel 的某个特定位置进行数据的读/写操作。可以通过调用 position() 方法获取 FileChannel 的当前位置。</p>
<p>也可以通过调用 position(long pos) 方法设置 FileChannel 的当前位置。</p>
<p>这里有两个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long pos &#x3D; channel.position();</span><br><span class="line">channel.position(pos +123);</span><br></pre></td></tr></table></figure>

<p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回 -1 —— 文件结束标志。</p>
<p>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</p>
<h2 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h2><p>FileChannel 实例的 size() 方法将返回该实例所关联文件的大小。如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long fileSize &#x3D; channel.size();</span><br></pre></td></tr></table></figure>

<h2 id="FileChannel-的-truncate-方法"><a href="#FileChannel-的-truncate-方法" class="headerlink" title="FileChannel 的 truncate 方法"></a>FileChannel 的 truncate 方法</h2><p>可以使用 FileChannel.truncate() 方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.truncate(1024);</span><br></pre></td></tr></table></figure>

<p>这个例子截取文件的前 1024 个字节。</p>
<h2 id="FileChannel-的-force-方法"><a href="#FileChannel-的-force-方法" class="headerlink" title="FileChannel 的 force 方法"></a>FileChannel 的 force 方法</h2><p>FileChannel.force() 方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到 FileChannel 里的数据一定会即时写到磁盘上。要保证这一点，需要调用 force() 方法。</p>
<p>force() 方法有一个 boolean 类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。</p>
<p>下面的例子同时将文件数据和元数据强制写到磁盘上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.force(true);</span><br></pre></td></tr></table></figure>

<h1 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h1><p>Java NIO 中的 SocketChannel 是一个连接到 TCP 网络套接字的通道。可以通过以下 2 种方式创建 SocketChannel：</p>
<ol>
<li>打开一个 SocketChannel 并连接到互联网上的某台服务器。</li>
<li>一个新连接到达 ServerSocketChannel 时，会创建一个 SocketChannel。</li>
</ol>
<h2 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h2><p>下面是 SocketChannel 的打开方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;SocketChann&#96;</span><br></pre></td></tr></table></figure>

<h2 id="关闭-SocketChannel"><a href="#关闭-SocketChannel" class="headerlink" title="关闭 SocketChannel"></a>关闭 SocketChannel</h2><p>当用完 SocketChannel 之后调用 SocketChannel.close() 关闭 SocketChanne ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;socketChannel&#96;</span><br></pre></td></tr></table></figure>

<h2 id="从-SocketChannel-读取数据"><a href="#从-SocketChannel-读取数据" class="headerlink" title="从 SocketChannel 读取数据"></a>从 SocketChannel 读取数据</h2><p>要从 SocketChannel 中读取数据，调用一个 read() 的方法之一。以下是例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ByteBu&#96;</span><br></pre></td></tr></table></figure>

<p>首先，分配一个 Buffer。从 SocketChannel 读取到的数据将会放到这个 Buffer 中。</p>
<p>然后，调用 SocketChannel.read()。该方法将数据从 SocketChannel 读到 Buffer 中。read()方法返回的 int 值表示读了多少字节进 Buffer 里。如果返回的是 -1，表示已经读到了流的末尾（连接关闭了）。</p>
<h2 id="写入SocketChannel"><a href="#写入SocketChannel" class="headerlink" title="写入SocketChannel"></a>写入SocketChannel</h2><p>写数据到 SocketChannel 用的是 SocketChannel.write() 方法，该方法以一个 Buffer 作为参数。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Stri&#96;</span><br></pre></td></tr></table></figure>

<p>注意 SocketChannel.write() 方法的调用是在一个 while 循环中的。Write() 方法无法保证能写多少字节到 SocketChannel。所以，我们重复调用 write() 直到 Buffer 没有要写的字节为止。</p>
<h2 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h2><p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用 connect(), read() 和write() 了。</p>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h2><p>如果 SocketChannel 在非阻塞模式下，此时调用 connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用 finishConnect() 的方法。像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;sock&#96;</span><br></pre></td></tr></table></figure>

<h2 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h2><p>非阻塞模式下，write() 方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用 write()。前面已经有例子了，这里就不赘述了。</p>
<h2 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h2><p>非阻塞模式下,read() 方法在尚未读取到任何数据时可能就返回了。所以需要关注它的 int 返回值，它会告诉你读取了多少字节。</p>
<h2 id="非阻塞模式与选择器"><a href="#非阻塞模式与选择器" class="headerlink" title="非阻塞模式与选择器"></a>非阻塞模式与选择器</h2><p>非阻塞模式与选择器搭配会工作的更好，通过将一或多个 SocketChannel 注册到 Selector，可以询问选择器哪个通道已经准备好了读取，写入等。Selector 与 SocketChannel 的搭配使用会在后面详讲。</p>
<h1 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h1><p>Java NIO 中的 ServerSocketChannel 是一个可以监听新进来的 TCP 连接的通道, 就像标准 IO 中的 ServerSocket 一样。ServerSocketChannel 类在 java.nio.channels 包中。</p>
<p>这里有个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ServerSo&#96;</span><br></pre></td></tr></table></figure>

<h2 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h2><p>通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>

<h2 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h2><p>通过调用ServerSocketChannel.close() 方法来关闭 ServerSocketChannel 如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure>

<h2 id="监听新进来的连接"><a href="#监听新进来的连接" class="headerlink" title="监听新进来的连接"></a>监听新进来的连接</h2><p>通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept() 方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept() 方法会一直阻塞到有新连接到达。</p>
<p>通常不会仅仅只监听一个连接,在 while 循环中调用 accept() 方法. 如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel &#x3D;</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;do something with socketChannel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然,也可以在 while 循环中使用除了 true 以外的其它退出准则。</p>
<h2 id="非阻塞模式-1"><a href="#非阻塞模式-1" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h2><p>ServerSocketChannel 可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是 null。 因此，需要检查返回的 SocketChannel 是否是 null，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Server&#96;</span><br></pre></td></tr></table></figure>

<h1 id="Java-NIO-DatagramChannel"><a href="#Java-NIO-DatagramChannel" class="headerlink" title="Java NIO DatagramChannel"></a>Java NIO DatagramChannel</h1><p>Java NIO 中的 DatagramChannel 是一个能收发 UDP 包的通道。因为 UDP 是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p>
<h2 id="打开-DatagramChannel"><a href="#打开-DatagramChannel" class="headerlink" title="打开 DatagramChannel"></a>打开 DatagramChannel</h2><p>下面是 DatagramChannel 的打开方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Data&#96;</span><br></pre></td></tr></table></figure>

<p>这个例子打开的 DatagramChannel 可以在 UDP 端口 9999 上接收数据包。</p>
<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>通过 receive() 方法从 DatagramChannel 接收数据，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ByteB&#96;</span><br></pre></td></tr></table></figure>

<p>receive() 方法会将接收到的数据包内容复制到指定的 Buffer， 如果 Buffer 容不下收到的数据，多出的数据将被丢弃。</p>
<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>通过 send() 方法从 DatagramChannel 发送数据，如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;String&#96;</span><br></pre></td></tr></table></figure>

<p>这个例子发送一串字符到”jenkov.com”服务器的 UDP 端口 80。 因为服务端并没有监控这个端口，所以什么也不会发生。也不会通知你发出的数据包是否已收到，因为 UDP 在数据传送方面没有任何保证。</p>
<h2 id="连接到特定的地址"><a href="#连接到特定的地址" class="headerlink" title="连接到特定的地址"></a>连接到特定的地址</h2><p>可以将 DatagramChannel “连接”到网络中的特定地址的。由于 UDP 是无连接的，连接到特定地址并不会像 TCP 通道那样创建一个真正的连接。而是锁住 DatagramChannel ，让其只能从特定地址收发数据。</p>
<p>这里有个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.connect(new InetSocketAddress(&quot;jenkov.com&quot;, 80));</span><br></pre></td></tr></table></figure>

<p>当连接后，也可以使用 read() 和 write() 方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;int bytes&#96;</span><br></pre></td></tr></table></figure>

<h1 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h1><p>Java NIO 管道是 2 个线程之间的单向数据连接。Pipe 有一个 source 通道和一个 sink 通道。数据会被写到 sink 通道，从 source 通道读取。</p>
<p>这里是 Pipe 原理的图示：</p>
<p><img src="/img/NIO/pipe.bmp" alt="pipe"></p>
<h2 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h2><p>通过 Pipe.open() 方法打开管道。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pipe pipe &#x3D; Pipe.open();</span><br></pre></td></tr></table></figure>

<h2 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h2><p>要向管道写数据，需要访问 sink 通道。像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pipe.SinkChannel sinkChannel &#x3D; pipe.sink();</span><br></pre></td></tr></table></figure>

<p>通过调用 SinkChannel 的 write() 方法，将数据写入 SinkChannel,像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Str&#96;</span><br></pre></td></tr></table></figure>

<h2 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h2><p>从读取管道的数据，需要访问 source 通道，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel &#x3D; pipe.source();</span><br></pre></td></tr></table></figure>

<p>调用 source 通道的 read() 方法来读取数据，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ByteBuf&#96;</span><br></pre></td></tr></table></figure>

<p>read() 方法返回的 int 值会告诉我们多少字节被读进了缓冲区。</p>
<h1 id="Java-NIO与IO"><a href="#Java-NIO与IO" class="headerlink" title="Java NIO与IO"></a>Java NIO与IO</h1><p>当学习了 Java NIO 和 IO 的 API 后，一个问题马上涌入脑海：</p>
<p>我应该何时使用 IO，何时使用 NIO 呢？在本文中，我会尽量清晰地解析 Java NIO 和 IO 的差异、它们的使用场景，以及它们如何影响您的代码设计。</p>
<h2 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h2><p>下表总结了Java NIO 和 IO 之间的主要差别，我会更详细地描述表中每部分的差异。</p>
<table>
<thead>
<tr>
<th align="center">IO</th>
<th align="center">NIO</th>
</tr>
</thead>
<tbody><tr>
<td align="center">面向流</td>
<td align="center">面向缓冲</td>
</tr>
<tr>
<td align="center">阻塞IO</td>
<td align="center">非阻塞IO</td>
</tr>
<tr>
<td align="center">无</td>
<td align="center">选择器</td>
</tr>
</tbody></table>
<h2 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a>面向流与面向缓冲</h2><p>Java  NIO 和 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。 Java IO  面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。  Java NIO  的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<h2 id="阻塞IO与非阻塞IO"><a href="#阻塞IO与非阻塞IO" class="headerlink" title="阻塞IO与非阻塞IO"></a>阻塞IO与非阻塞IO</h2><p>Java  IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()  时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO  的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。  非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO  的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h2 id="选择器（Selectors）"><a href="#选择器（Selectors）" class="headerlink" title="选择器（Selectors）"></a>选择器（Selectors）</h2><p>Java NIO 的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来”选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<h2 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a><strong>NIO和IO如何影响应用程序的设计</strong></h2><p>无论您选择 IO 或 NIO工 具箱，可能会影响您应用程序设计的以下几个方面：</p>
<ol>
<li>对 NIO 或 IO 类的 API 调用。</li>
<li>数据处理。</li>
<li>用来处理数据的线程数。</li>
</ol>
<h3 id="API掉用"><a href="#API掉用" class="headerlink" title="API掉用"></a>API掉用</h3><p>当然，使用 NIO 的 API 调用时看起来与使用 IO 时有所不同，但这并不意外，因为并不是仅从一个 InputStream 逐字节读取，而是数据必须先读入缓冲区再处理。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>使用纯粹的 NIO 设计相较 IO 设计，数据处理也受到影响。</p>
<p>在 IO 设计中，我们从 InputStream 或 Reader 逐字节读取数据。假设你正在处理一基于行的文本数据流，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Na&#96;</span><br></pre></td></tr></table></figure>

<p>该文本行的流可以这样处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream input &#x3D; … ; &#x2F;&#x2F; get the InputStream from the client socket</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;BufferedRea&#96;</span><br></pre></td></tr></table></figure>

<p>请注意处理状态由程序执行多久决定。换句话说，一旦 reader.readLine() 方法返回，你就知道肯定文本行就已读完，  readline() 阻塞直到整行读完，这就是原因。你也知道此行包含名称；同样，第二个 readline()  调用返回的时候，你知道这行包含年龄等。  正如你可以看到，该处理程序仅在有新数据读入时运行，并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据（大多如此）。下图也说明了这条原则：</p>
<p>（<strong>Java IO: 从一个阻塞的流中读数据</strong>） 而一个 NIO 的实现会有所不同，下面是一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ByteBuffer &#96;</span><br></pre></td></tr></table></figure>

<p>注意第二行，从通道读取字节到 ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。<br>假设第一次 read(buffer) 调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，在此之前，对数据的任何处理毫无意义。</p>
<p>所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ByteBuf&#96;</span><br></pre></td></tr></table></figure>

<p>bufferFull() 方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。</p>
<p>bufferFull() 方法扫描缓冲区，但必须保持在 bufferFull() 方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。</p>
<p>如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”：</p>
<p><img src="/img/NIO/nio-vs-io-2.png" alt="nio-vs-io-2"></p>
<h3 id="用来处理数据的线程数"><a href="#用来处理数据的线程数" class="headerlink" title="用来处理数据的线程数"></a>用来处理数据的线程数</h3><p>NIO 可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</p>
<p>如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现  NIO 的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如 P2P  网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。一个线程多个连接的设计方案如下图所示：</p>
<p><img src="/img/NIO/nio-vs-io-3.png" alt="nio-vs-io-3"></p>
<p>如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的 IO 服务器实现可能非常契合。下图说明了一个典型的 IO 服务器设计：</p>
<p><img src="/img/NIO/nio-vs-io-4.png" alt="nio-vs-io-4"></p>
<h1 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h1><p>本文转载自：<a href="http://ifeve.com/overview/" target="_blank" rel="noopener">并发编程网——Java NIO系列教程</a></p>
]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
</search>
