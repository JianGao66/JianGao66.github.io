<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiangao66.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="HashMap最早出现在JDK1.2中，底层基于散列算法（Hash）实现。并且HashMap允许null键和null值，是线程非安全类，在多线程环境下可能会存在问题，与之对应的是HashTable类，HashTable是线程安全的HashMap，但是在之前由于HashTable方法都是用synchronized实现，开销比较大，所以在多线程时反而并不使用HashTable，而是使用CurrentH">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap源码分析">
<meta property="og:url" content="https://jiangao66.github.io/2020/04/07/hashMap/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="HashMap最早出现在JDK1.2中，底层基于散列算法（Hash）实现。并且HashMap允许null键和null值，是线程非安全类，在多线程环境下可能会存在问题，与之对应的是HashTable类，HashTable是线程安全的HashMap，但是在之前由于HashTable方法都是用synchronized实现，开销比较大，所以在多线程时反而并不使用HashTable，而是使用CurrentH">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiangao66.github.io/img/hashMap/HashMap.png">
<meta property="og:image" content="https://jiangao66.github.io/img/hashMap/tableSizeFor.jpg">
<meta property="article:published_time" content="2020-04-07T09:34:13.000Z">
<meta property="article:modified_time" content="2020-05-20T04:52:07.005Z">
<meta property="article:author" content="小小鱼">
<meta property="article:tag" content="”hashMap&quot;">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiangao66.github.io/img/hashMap/HashMap.png">

<link rel="canonical" href="https://jiangao66.github.io/2020/04/07/hashMap/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>HashMap源码分析 | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiangao66.github.io/2020/04/07/hashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="小小鱼">
      <meta itemprop="description" content="分享学习心得，记录学习过程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HashMap源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 17:34:13" itemprop="dateCreated datePublished" datetime="2020-04-07T17:34:13+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-20 12:52:07" itemprop="dateModified" datetime="2020-05-20T12:52:07+08:00">2020-05-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">容器</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>HashMap</code>最早出现在JDK1.2中，底层基于散列算法（Hash）实现。并且<code>HashMap</code>允许null键和null值，是线程非安全类，在多线程环境下可能会存在问题，与之对应的是<code>HashTable</code>类，<code>HashTable</code>是线程安全的<code>HashMap</code>，但是在之前由于HashTable方法都是用<code>synchronized</code>实现，开销比较大，所以在多线程时反而并不使用<code>HashTable</code>，而是使用<code>CurrentHashMap</code>。在JDK1.8后，<code>HashMap</code>和<code>CurrentHashMap</code>的数据结构都有了新变化，即加入了红黑树。</p>
<a id="more"></a>

<h3 id="JDK1-7及之前版本中的HashMap数据结构"><a href="#JDK1-7及之前版本中的HashMap数据结构" class="headerlink" title="JDK1.7及之前版本中的HashMap数据结构"></a>JDK1.7及之前版本中的HashMap数据结构</h3><p>在JDK1.6，1.7中，HashMap都是基于“拉链法”实现，即数组+链表的形式，通过不同的hash值来对键分配不同的桶（bucket）。</p>
<h3 id="JDK1-8版本的HashMap数据结构"><a href="#JDK1-8版本的HashMap数据结构" class="headerlink" title="JDK1.8版本的HashMap数据结构"></a>JDK1.8版本的HashMap数据结构</h3><p><img src="/img/hashMap/HashMap.png" alt="HashMap"></p>
<p>在JDK1.8中对HashMap的源码进行了优化，在JDK1.7中，HashMap处理“碰撞”的时候，都是采用链表来存储，当碰撞的节点很多的时候，查询时间复杂度从原来的O(1)变成了O(N)。而JDK1.8中，为了优化这种情况，HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞节点较少时，采样链表存储，当较大（默认是超过8）时，变成使用红黑树（特点是查询时间是O(logN)）存储。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><code>Node</code>是HashMap中的一个静态内部类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Node是单向链表，实现了Map.Entry接口</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line"> 	final int hash; &#x2F;&#x2F;哈希</span><br><span class="line"> 	final K key;  &#x2F;&#x2F;键值对</span><br><span class="line">   V value;</span><br><span class="line"> 	Node&lt;K,V&gt; next;  &#x2F;&#x2F;下一个节点</span><br><span class="line">    </span><br><span class="line">	 &#x2F;&#x2F;构造函数</span><br><span class="line">  Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">	 this.hash &#x3D; hash;</span><br><span class="line"> 	 this.key &#x3D; key;</span><br><span class="line"> 	 this.value &#x3D; value;</span><br><span class="line"> 	 this.next &#x3D; next;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	&#x2F;&#x2F; getter and setter ... toString ...</span><br><span class="line"> 	public final K getKey() &#123; return key; &#125;</span><br><span class="line"> 	public final V getValue() &#123; return value; &#125;</span><br><span class="line"> 	public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">	public final int hashCode() &#123;</span><br><span class="line"> 	return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue &#x3D; value;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public final boolean equals(Object o) &#123;</span><br><span class="line"> 	if (o &#x3D;&#x3D; this)</span><br><span class="line"> 	   return true;</span><br><span class="line"> 	if (o instanceof Map.Entry) &#123;</span><br><span class="line"> 	   Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"> 	if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line"> 	   Objects.equals(value, e.getValue()))</span><br><span class="line"> 	   return true;</span><br><span class="line">  &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TreeNode</code>是红黑树的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line"> 	TreeNode&lt;K,V&gt; parent; &#x2F;&#x2F; red-black tree links</span><br><span class="line"> 	TreeNode&lt;K,V&gt; left;</span><br><span class="line"> 	TreeNode&lt;K,V&gt; right;</span><br><span class="line"> 	TreeNode&lt;K,V&gt; prev; &#x2F;&#x2F; needed to unlink next upon deletion</span><br><span class="line"> 	boolean red;</span><br><span class="line"> 	TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"> 	super(hash, key, val, next);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">     * Returns root of tree containing this node.</span><br><span class="line">     *&#x2F;</span><br><span class="line"> final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line"> 	for (TreeNode&lt;K,V&gt; r &#x3D; this, p;;) &#123;</span><br><span class="line"> 		if ((p &#x3D; r.parent) &#x3D;&#x3D; null)</span><br><span class="line"> 			return r;</span><br><span class="line">         r &#x3D; p;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 默认初始容量16(必须是2的幂次方)</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 最大容量，2的30次方</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 默认加载因子，用来计算threshold</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 链表转成树的阈值，当桶中链表长度大于8时转成树 </span><br><span class="line">   threshold &#x3D; capacity * loadFactor</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 进行resize操作时，若桶中数量少于6则从树转成链表</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 桶中结构转化为红黑树对应的table的最小大小</span><br><span class="line">   当需要将解决 hash 冲突的链表转变为红黑树时，</span><br><span class="line">   需要判断下此时数组容量，</span><br><span class="line">   若是由于数组容量太小（小于　MIN_TREEIFY_CAPACITY　）</span><br><span class="line">   导致的 hash 冲突太多，则不进行链表转变为红黑树操作，</span><br><span class="line">   转为利用　resize() 函数对　hashMap 扩容</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">&#x2F;**</span><br><span class="line"> 保存Node&lt;K,V&gt;节点的数组</span><br><span class="line"> 该表在首次使用时初始化，并根据需要调整大小。 分配时，</span><br><span class="line"> 长度始终是2的幂。</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 存放具体元素的集</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 记录 hashMap 当前存储的元素的数量</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient int size;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 每次更改map结构的计数器</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient int modCount;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span><br><span class="line"> *&#x2F;</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 负载因子：要调整大小的下一个大小值（容量*加载因子）。</span><br><span class="line"> *&#x2F;</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;public HashMap(int initialCapacity, float loadFactor) &#123;    &#x2F;&#x2F; 初始容量不能&#96;</span><br></pre></td></tr></table></figure>

<h4 id="tableSizeFor方法详解"><a href="#tableSizeFor方法详解" class="headerlink" title="tableSizeFor方法详解"></a>tableSizeFor方法详解</h4><p>用位运算找到大于或等于cap的最小2的整次幂的数，比如10，则返回16。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;static final int tableSizeFor(int cap) &#123;&#96;</span><br></pre></td></tr></table></figure>

<ol>
<li>让cap-1再赋值给n的目的是使得找到的目标值大于或等于原值。例如二进制<code>0100</code>,十进制是4,若不减1而直接操作，答案是<code>0001 0000</code>十进制是16，明显不符合预期。</li>
<li>对n右移1位：001xx…xxx，再位或：011xx…xxx</li>
<li>对n右移2位：00011…xxx，再位或：01111…xxx</li>
<li>对n右移4位…</li>
<li>对n右移8位…</li>
<li>对n右移16位,因为int最大就<code>2^32</code>所以移动1、2、4、8、16位并取位或,会将最高位的1后面的位全变为1。</li>
<li>再让结果n+1，即得到了2的整数次幂的值了。</li>
</ol>
<p>附带一个实例：</p>
<p><img src="/img/hashMap/tableSizeFor.jpg" alt="tableSizeFor"></p>
<h4 id="loadFactory负载因子"><a href="#loadFactory负载因子" class="headerlink" title="loadFactory负载因子"></a>loadFactory负载因子</h4><p><strong>对于HashMap来说，负载因子是一个很重要的参数，该参数反应了HashMap桶数组的使用情况，通过调节负载因子，可以使HashMap时间和空间复杂度上有不同的表现。</strong></p>
<p>当我们调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，键的键之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间。</p>
<p>相反，如果增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间。至于负载因子怎么调节，这个看使用场景了。</p>
<p>一般情况下，我们用默认值就可以了。大多数情况下0.75在时间跟空间代价上达到了平衡所以不建议修改。</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; HashMap中的Hash方法</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">   int h;</span><br><span class="line"> &#x2F;&#x2F; 拿到key的hash值后与其无符号右移16位取“与”</span><br><span class="line"> &#x2F;&#x2F; 这种方式能混合原始hash值的高位和低位，并且混合后的低位混杂了高位的特征</span><br><span class="line"> &#x2F;&#x2F; 主要是考虑数组的table的length比较小的时候也能保证考虑到高低bit都能参与到hash中，并且效率很高</span><br><span class="line"> &#x2F;&#x2F; 通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。</span><br><span class="line">  return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line"> 	Node&lt;K,V&gt;[] tab; </span><br><span class="line"> 	Node&lt;K,V&gt; first, e; </span><br><span class="line"> 	int n; K k;</span><br><span class="line"> &#x2F;&#x2F; 定位键值对所在桶的位置</span><br><span class="line"> if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;  (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line"> &#x2F;&#x2F; 判断桶中第一项(数组元素)相等</span><br><span class="line"> if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">     ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line"> 		return first;</span><br><span class="line"> &#x2F;&#x2F; 桶中不止一个结点</span><br><span class="line"> if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line"> &#x2F;&#x2F; 是否是红黑树，是的话调用getTreeNode方法</span><br><span class="line"> if (first instanceof TreeNode)</span><br><span class="line"> 	return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"> &#x2F;&#x2F; 不是红黑树的话，在链表中遍历查找    </span><br><span class="line"> do &#123;</span><br><span class="line"> if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line"> 	return e;</span><br><span class="line"> &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> 	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap：如何有效减少碰撞</p>
<ol>
<li>扰动函数：促使元素位置分布均匀，减少碰撞几率</li>
<li>使用final对象，并采用合适的equals()和hashCode()方法</li>
</ol>
<p>注意：</p>
<ol>
<li>HashMap的hash算法(<code>hash()</code>方法)。</li>
<li><code>(n - 1) &amp;amp; hash</code>等价于对 length 取余。</li>
</ol>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">   &#x2F;&#x2F; 调用hash(key)方法来计算hash </span><br><span class="line">   return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; </span><br><span class="line">   Node&lt;K,V&gt; p; </span><br><span class="line">   int n, i;</span><br><span class="line">   &#x2F;&#x2F; 容量初始化：当table为空，则调用resize()方法来初始化容器，并且resize()方法可以扩容</span><br><span class="line">   if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">   &#x2F;&#x2F;确定元素存放在哪个桶中，桶为空，新生成结点放入桶中</span><br><span class="line">   if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">   else &#123;</span><br><span class="line">   Node&lt;K,V&gt; e; K k;</span><br><span class="line">   &#x2F;&#x2F; 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br><span class="line">   if (p.hash &#x3D;&#x3D; hash &amp;&amp;  ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">   &#x2F;&#x2F;如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值对</span><br><span class="line">       e &#x3D; p;</span><br><span class="line">   &#x2F;&#x2F; 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法</span><br><span class="line">   else if (p instanceof TreeNode)</span><br><span class="line">   &#x2F;&#x2F; 放入树中</span><br><span class="line">        e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">   else &#123;</span><br><span class="line">   &#x2F;&#x2F;对链表进行遍历，并统计链表长度</span><br><span class="line">   for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">   &#x2F;&#x2F; 到达链表的尾部</span><br><span class="line">   if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;在尾部插入新结点</span><br><span class="line">       p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">   &#x2F;&#x2F; 如果结点数量达到阈值，转化为红黑树</span><br><span class="line">   if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">       treeifyBin(tab, hash);</span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line">   &#x2F;&#x2F; 判断链表中结点的key值与插入的元素的key值是否相等</span><br><span class="line">   if (e.hash &#x3D;&#x3D; hash &amp;&amp;  ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">        break;</span><br><span class="line">        p &#x3D; e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;判断要插入的键值对是否存在 HashMap 中</span><br><span class="line">   if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">       V oldValue &#x3D; e.value;</span><br><span class="line">   &#x2F;&#x2F; onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span><br><span class="line">   if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">       e.value &#x3D; value;</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">       return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">   ++modCount;</span><br><span class="line">   &#x2F;&#x2F; 键值对数量超过阈值时，则进行扩容</span><br><span class="line">   if (++size &gt; threshold)</span><br><span class="line">     resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，<code>new HashMap();</code>完成后，如果没有<code>put</code>操作，是不会分配存储空间的。</p>
<p>HashMap：put方法的逻辑</p>
<ol>
<li>如果HashMap未被初始化过，则初始化</li>
<li>对key求hash值，然后再计算下标</li>
<li>如果没有碰撞，直接放入桶中</li>
<li>如果碰撞了，以链表的方式链接到后面</li>
<li>如果链表长度超过阈值，就把链表转换成红黑树</li>
<li>如果链表的长度低于6，就把红黑树转回链表</li>
<li>如果节点已经存在就替换旧值</li>
<li>如果桶满了（容量16*负载因子0.75），就需要resize（扩容2倍后重排）</li>
</ol>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>在  HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。  HashMap  按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"> &#x2F;&#x2F; 拿到数组桶</span><br><span class="line"> Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line"> int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line"> int oldThr &#x3D; threshold;</span><br><span class="line"> int newCap, newThr &#x3D; 0;</span><br><span class="line"> &#x2F;&#x2F; 如果数组桶的容量大与0</span><br><span class="line"> if (oldCap &gt; 0) &#123;</span><br><span class="line"> &#x2F;&#x2F; 如果比最大值还大，则赋值为最大值</span><br><span class="line"> if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line"> return oldTab;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 如果扩容后小于最大值 而且 旧数组桶大于初始容量16， 阈值左移1(扩大2倍)</span><br><span class="line"> else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 如果数组桶容量&lt;&#x3D;0 且 旧阈值 &gt;0</span><br><span class="line"> else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line"> &#x2F;&#x2F; 新容量&#x3D;旧阈值</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line"> &#x2F;&#x2F; 如果数组桶容量&lt;&#x3D;0 且 旧阈值 &lt;&#x3D;0</span><br><span class="line"> else &#123; &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line"> &#x2F;&#x2F; 新容量&#x3D;默认容量</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line"> &#x2F;&#x2F; 新阈值&#x3D; 负载因子*默认容量</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 如果新阈值为0</span><br><span class="line"> if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line"> &#x2F;&#x2F; 重新计算阈值</span><br><span class="line"> float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line"> (int)ft : Integer.MAX_VALUE);</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 更新阈值</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line"> @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line"> &#x2F;&#x2F; 创建新数组</span><br><span class="line"> Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line"> &#x2F;&#x2F; 覆盖数组桶    </span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line"> &#x2F;&#x2F; 如果旧数组桶不是空，则遍历桶数组，并将键值对映射到新的桶数组中</span><br><span class="line"> if (oldTab !&#x3D; null) &#123;</span><br><span class="line"> for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line"> Node&lt;K,V&gt; e;</span><br><span class="line"> if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line"> if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line"> &#x2F;&#x2F; 如果是红黑树</span><br><span class="line"> else if (e instanceof TreeNode)</span><br><span class="line"> &#x2F;&#x2F; 重新映射时，需要对红黑树进行拆分</span><br><span class="line"> ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line"> else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line"> &#x2F;&#x2F; 如果不是红黑树，则按链表处理</span><br><span class="line"> Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line"> Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line"> Node&lt;K,V&gt; next;</span><br><span class="line"> &#x2F;&#x2F; 遍历链表，并将链表节点按原顺序进行分组</span><br><span class="line"> do &#123;</span><br><span class="line"> next &#x3D; e.next;</span><br><span class="line"> if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line"> if (loTail &#x3D;&#x3D; null)</span><br><span class="line">     loHead &#x3D; e;</span><br><span class="line"> else</span><br><span class="line">     loTail.next &#x3D; e;</span><br><span class="line">     loTail &#x3D; e;</span><br><span class="line"> &#125;</span><br><span class="line"> else &#123;</span><br><span class="line"> if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">     hiHead &#x3D; e;</span><br><span class="line"> else</span><br><span class="line">     hiTail.next &#x3D; e;</span><br><span class="line">     hiTail &#x3D; e;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line"> &#x2F;&#x2F; 将分组后的链表映射到新桶中</span><br><span class="line"> if (loTail !&#x3D; null) &#123;</span><br><span class="line">     loTail.next &#x3D; null;</span><br><span class="line">     newTab[j] &#x3D; loHead;</span><br><span class="line"> &#125;</span><br><span class="line"> if (hiTail !&#x3D; null) &#123;</span><br><span class="line">     hiTail.next &#x3D; null;</span><br><span class="line">     newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	   &#125;</span><br><span class="line"> 	  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> 	return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>
</blockquote>
<p>HashMap扩容问题：</p>
<ol>
<li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li>
<li>rehashing是一个比较耗时的过程</li>
</ol>
<p>整体步骤：</p>
<ol>
<li>计算新桶数组的容量 newCap 和新阈值 newThr</li>
<li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li>
</ol>
<p>总结起来，一共有三种<strong>扩容方式</strong>：</p>
<ol>
<li>使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值<code>DEFAULT_INITIAL_CAPACITY</code>也就是16。同时<code>threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12</code>。</li>
<li>指定初始容量的构造方法初始化<code>HashMap</code>。那么从下面源码可以看到初始容量会等于<code>threshold</code>，接着<code>threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR</code>。</li>
<li>HashMap不是第一次扩容。如果<code>HashMap</code>已经扩容过的话，那么每次table的容量以及<code>threshold</code>量为原有的两倍。</li>
</ol>
<p>细心点的人会很好奇，为什么要判断loadFactor为0呢？</p>
<blockquote>
<p>loadFactor小数位为 0，整数位可被2整除且大于等于8时，在某次计算中就可能会导致 newThr 溢出归零。</p>
</blockquote>
<h3 id="疑问和进阶"><a href="#疑问和进阶" class="headerlink" title="疑问和进阶"></a>疑问和进阶</h3><p><strong>1. JDK1.7是基于数组+单链表实现（为什么不用双链表）</strong></p>
<p>首先，用链表是为了解决hash冲突。</p>
<p>单链表能实现为什么要用双链表呢?(双链表需要更大的存储空间)</p>
<p><strong>2. 为什么要用红黑树，而不用平衡二叉树？</strong></p>
<blockquote>
<p>插入效率比平衡二叉树高，查询效率比普通二叉树高。所以选择性能相对折中的红黑树。</p>
</blockquote>
<p><strong>3. 重写对象的Equals方法时，要重写hashCode方法，为什么？跟HashMap有什么关系？</strong></p>
<p>equals与hashcode间的关系:</p>
<ol>
<li>如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)</li>
</ol>
<p>因为在  HashMap 的链表结构中遍历判断的时候，特定情况下重写的 equals  方法比较对象是否相等的业务逻辑比较复杂，循环下来更是影响查找效率。所以这里把 hashcode 的判断放在前面，只要 hashcode  不相等就玩儿完，不用再去调用复杂的 equals 了。很多程度地提升 HashMap 的使用效率。</p>
<p>所以重写 hashcode 方法是为了让我们能够正常使用 HashMap 等集合类，因为 HashMap 判断对象是否相等既要比较 hashcode 又要使用 equals 比较。而这样的实现是为了提高 HashMap 的效率。</p>
<p><strong>4. HashMap为什么不直接使用对象的原始hash值呢?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123; int h; return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，HashMap的哈希值是通过上面的方式获取，而不是通过<code>key.hashCode()</code>方法获取。</p>
<p>原因：</p>
<blockquote>
<p>通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。</p>
</blockquote>
<p><strong>5. 既然红黑树那么好，为啥hashmap不直接采用红黑树，而是当大于8个的时候才转换红黑树？</strong></p>
<p>因为红黑树需要进行左旋，右旋操作， 而单链表不需要。</p>
<p>以下都是单链表与红黑树结构对比。</p>
<p>如果元素小于8个，查询成本高，新增成本低。</p>
<p>如果元素大于8个，查询成本低，新增成本高。</p>
<p>至于为什么选数字8，是大佬折中衡量的结果-.-，就像loadFactor默认值0.75一样。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E2%80%9DhashMap/" rel="tag"><i class="fa fa-tag"></i> ”hashMap"</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/06/doubleCheckedLocking/" rel="prev" title="Java中的双重检查锁">
      <i class="fa fa-chevron-left"></i> Java中的双重检查锁
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/08/thread/" rel="next" title="Java并发知识点总结">
      Java并发知识点总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK1-7及之前版本中的HashMap数据结构"><span class="nav-number">1.</span> <span class="nav-text">JDK1.7及之前版本中的HashMap数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK1-8版本的HashMap数据结构"><span class="nav-number">2.</span> <span class="nav-text">JDK1.8版本的HashMap数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#结构"><span class="nav-number">2.1.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类定义"><span class="nav-number">2.2.</span> <span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量"><span class="nav-number">2.3.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">2.4.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tableSizeFor方法详解"><span class="nav-number">2.5.</span> <span class="nav-text">tableSizeFor方法详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadFactory负载因子"><span class="nav-number">2.6.</span> <span class="nav-text">loadFactory负载因子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找"><span class="nav-number">2.7.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加"><span class="nav-number">2.8.</span> <span class="nav-text">添加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容机制"><span class="nav-number">2.9.</span> <span class="nav-text">扩容机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#疑问和进阶"><span class="nav-number">3.</span> <span class="nav-text">疑问和进阶</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小小鱼"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">小小鱼</p>
  <div class="site-description" itemprop="description">分享学习心得，记录学习过程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JianGao66" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JianGao66" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2517550801@qq.com" title="E-Mail → mailto:2517550801@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小小鱼</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
  
  <script type="text/javascript"
  color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
