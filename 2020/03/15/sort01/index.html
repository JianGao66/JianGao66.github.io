<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiangao66.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="各类排序算法">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法比较与梳理">
<meta property="og:url" content="https://jiangao66.github.io/2020/03/15/sort01/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="各类排序算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/sort.png">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/sort1.png">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/bubblesort.gif">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/quickSort.gif">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/quicksort1.png">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/quicksort2.png">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/quicksort3.png">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/quicksort5.png">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/insertionSort.gif">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/selectionSort.gif">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/heap-sort.png">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/849589-20171015231308699-356134237.gif">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/guibingSort.gif">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/mergesort0.png">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/mergesort2.png">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/counting-sort.gif">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/radix-sort.gif">
<meta property="og:image" content="https://jiangao66.github.io/img/01sort/shell-sort.gif">
<meta property="article:published_time" content="2020-03-15T09:27:58.000Z">
<meta property="article:modified_time" content="2020-04-26T03:53:58.537Z">
<meta property="article:author" content="小小鱼">
<meta property="article:tag" content="排序算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiangao66.github.io/img/01sort/sort.png">

<link rel="canonical" href="https://jiangao66.github.io/2020/03/15/sort01/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>排序算法比较与梳理 | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiangao66.github.io/2020/03/15/sort01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="小小鱼">
      <meta itemprop="description" content="分享学习心得，记录学习过程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          排序算法比较与梳理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-15 17:27:58" itemprop="dateCreated datePublished" datetime="2020-03-15T17:27:58+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-26 11:53:58" itemprop="dateModified" datetime="2020-04-26T11:53:58+08:00">2020-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="各类排序算法"><a href="#各类排序算法" class="headerlink" title="各类排序算法"></a>各类排序算法</h2><p><img src="/img/01sort/sort.png" alt="排序算法复杂度"></p>
<a id="more"></a>

<h2 id="排序算法一般分类"><a href="#排序算法一般分类" class="headerlink" title="排序算法一般分类"></a>排序算法一般分类</h2><p><img src="/img/01sort/sort1.png" alt="排序算法分类"></p>
<p>相关概念：</p>
<ul>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li>时间复杂度：对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。</li>
<li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>比较两个相邻的元素，将值大的元素交换至右端。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>依次比较两个相邻的数，将小数放到前面，大数放到后面</p>
<p>第一趟：首先比较第 1 个数和第 2 个数，将小数放前，大数放后。然后比较第 2 个数和第 3 个数，将小数放前，大数放后，如此一直继续下去，直到比较最后两个数，将小数放前，大数放后。然后重复第一趟步骤，直到所有排序完成。</p>
<p>第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较。</p>
<p>第二趟完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较。</p>
<p>依此类推……<br><img src="/img/01sort/bubblesort.gif" alt="冒泡排序"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        bubbleSort(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; array.length-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"排序后的数组为:"</span> + Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>排序后的数组为: [1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h3><p><em>冒泡排序的优点</em>：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。</p>
<p>用时间复杂度来说： 如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：<code>Cmin=n-1</code>;<code>Mmin=0</code>;所以，冒泡排序最好的时间复杂度为<code>O(n)</code>。如果很不幸我们的数据是反序的，则需要进行 n - 1 趟排序。每趟排序要进行 n - i 次比较(1 ≤ i ≤ n - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值。</p>
<ul>
<li>冒泡排序的最坏时间复杂度为：O(n^2)</li>
<li>冒泡排序的最好时间复杂夫为：O(n)</li>
<li>冒泡排序的平均时间复杂度：O(n)</li>
<li>冒泡排序是一种稳定的排序算法</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>从一个数组中随机选出一个数N，通过一趟排序将数组分割成三个部分，1、小于N的区域 2、等于N的区域 3、大于N的区域，然后再按照此方法对小于区的和大于区分别递归进行，从而达到整个数据变成有序数组。<br><img src="/img/01sort/quickSort.gif" alt="快速排序"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如下图：<br>假设最开始的基准数据为数组的第一个元素23，则首先用一个临时变量去存储基准数据，即 tmp=23，然后分别从数组的两端扫描数组，设两个指示标志：low 指向起始位置，high 指向末尾。<br><img src="/img/01sort/quicksort1.png" alt="快速排序"><br>首先从后半部分开始，如果扫描到的值大于基准数据就让 high - 1，如果发现有元素比该基准数据的值小，比如上面的 18 &lt;= tmp ，就让high位置的值赋值给low位置，结果如下：<br><img src="/img/01sort/quicksort2.png" alt="快速排序"><br>然后开始从前往后扫描，如果扫描到的值小于基准数据就让 low+1，如果发现有元素大于基准数据的值，比如上图 46 &gt;= tmp，就再将 low 位置的值赋值给 high 位置的值，指针移动并且数据交换后的结果如下：<br><img src="/img/01sort/quicksort3.png" alt="快速排序"><br>然后再开始从前往后遍历，直到 low=high 结束循环，此时 low 或者 high 的下标就是基准数据23在该数组中的正确索引位置，如下图所示：<br><img src="/img/01sort/quicksort5.png" alt="快速排序"><br>这样一遍遍的走下来，可以很清楚的知道，快排的本质就是把比基准数据小的都放到基准数的左边，比基准数大的数都放到基准数的右边，这样就找到了该数据在数组中的正确位置。<br>然后采用递归的方式分别对前半部分和后半部分排序，最终结果就是自然有序的了。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        quickSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="comment">//找到基准数据位置</span></span><br><span class="line">            <span class="keyword">int</span> index = getIndex(array,low,high);</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            quickSort(array,<span class="number">0</span>,index-<span class="number">1</span>);</span><br><span class="line">            quickSort(array,index+<span class="number">1</span>,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取基准数据位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="comment">//一般取第一个数作为基准数据</span></span><br><span class="line">        <span class="keyword">int</span> tmp = array[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; array[high] &gt;= tmp)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则high处元素小于基准数据，将high处赋值给low处数据</span></span><br><span class="line">            array[low] = array[high];</span><br><span class="line">            <span class="comment">//赋值完后，需要从前面开始扫描数组</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; array[low] &lt;= tmp)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">             array[high] = array[low];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整个循环结束时high=low,但是该位置处不等于基准元素</span></span><br><span class="line">        array[low] = tmp;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-1"><a href="#特点分析-1" class="headerlink" title="特点分析"></a>特点分析</h3><p>最好情况下快排每次能恰好均分序列，那么时间复杂度就是 O(nlogn)，最坏情况下，快排每次划分都只能将序列分为一个元素和其它元素两部分，这时候的快排退化成冒泡排序，时间复杂度为 O(n^2)。</p>
<ul>
<li>平均时间复杂度是 O(nlogn)</li>
<li>最坏时间复杂度是 O(n^2)</li>
<li>对于大的，乱序排列的数组来说快排一般是已知的最快的已知排序</li>
<li>快排是一种不稳定排序</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为 O(n^2)。是稳定的排序方法。<br><img src="/img/01sort/insertionSort.gif" alt="插入排序"></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>将一个数据插入到<em>已经排好序的有序数据</em>中</p>
<ul>
<li>将要排序的是一个乱的数组 int[] arrays = {3, 2, 1, 3, 3}</li>
<li>在未知道数组元素的情况下，我们只能把数组的第一个元素作为已经排好序的有序数据，也就是说，把{3}看成是已经排好序的有序数据</li>
</ul>
<p>第一趟排序：<br>用数组的第二个数与第一个数(<em>看成是已有序的数据</em>)比较</p>
<ul>
<li>如果比第一个数大，那就不管他</li>
<li>如果比第一个数小，将第一个数往后退一步，将第二个数插入第一个数去</li>
</ul>
<p>第二趟排序：<br>用数组的第三个数与已是有序的数据 {2,3} (刚才在第一趟排的)比较</p>
<ul>
<li>如果比 2 大，那就不管它</li>
<li>如果比 2 小，那就将 2 退一个位置，让第三个数和1比较</li>
</ul>
<p>在第二步中：</p>
<ul>
<li><p>如果第三个数比 1 大，那么将第三个数插入到 2 的位置上</p>
</li>
<li><p>如果第三个数比 1 小，那么将 1 后退一步，将第三个数插入到 1 的位置上</p>
</li>
</ul>
<p>…<br>后面依此类推</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        insertSort(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j-<span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                    arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//插入新的元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-2"><a href="#特点分析-2" class="headerlink" title="特点分析"></a>特点分析</h3><ul>
<li>最坏时间复杂度为O(n^2)</li>
<li>最好时间复杂度为O(n)</li>
<li>平均时间复杂度为O(n^2)</li>
<li>插入排序是一种稳定的排序算法。</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。<br><img src="/img/01sort/selectionSort.gif" alt="选择排序"></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>举例：数组 int[] arr = {5,2,8,4,9,1}<br><em>第一趟排序<em>： 原始数据：<code>5 2 8 4 9 1</code><br>最小数据1，把1放在首位，也就是1和5互换位置，<br>排序结果：<code>1 2 8 4 9 5</code><br>*第二趟排序</em>：<br>第1以外的数据<code>{2 8 4 9 5}</code>进行比较，2最小，<br>排序结果：<code>1 2 8 4 9 5</code><br><em>第三趟排序</em>：<br>除1、2以外的数据<code>{8 4 9 5}</code>进行比较，4最小，8和4交换<br>排序结果：<code>1 2 4 8 9 5</code><br>*第四趟排序</em> :<br>除第<code>1、2、4</code>以外的其他数据<code>{8 9 5}</code>进行比较，5最小，8和5交换<br>排序结果：<code>1 2 4 5 9 8</code><br><em>第五趟排序</em>：<br>除第<code>1、2、4、5</code>以外的其他数据<code>{9 8}</code>进行比较，8最小，8和9交换<br>排序结果：<code>1 2 4 5 8 9</code></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        selectionSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length -<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &lt; array[k])&#123;</span><br><span class="line">                    k = j; <span class="comment">//记下目前找到的最小值所在的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(i != k)&#123;  <span class="comment">//交换a[i]和a[k]</span></span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                array[i] = array[k];</span><br><span class="line">                array[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-3"><a href="#特点分析-3" class="headerlink" title="特点分析"></a>特点分析</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是 O(n^2) 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<ul>
<li><p>最坏时间复杂度为O(n^2)</p>
</li>
<li><p>平均时间复杂度为O(n^2)</p>
</li>
<li><p>选择排序是一种不稳定的排序</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>堆排序是对简单选择排序的改进，简单选择排序是从 n 个记录中找出一个最小的记录，需要比较 n - 1 次。但是这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。<br>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。<br><img src="/img/01sort/heap-sort.png" alt="堆排序"></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的 n - 1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次最大值。如此反复执行，就能得到一个有序序列了。<br><img src="/img/01sort/849589-20171015231308699-356134237.gif" alt="堆排序"><br>实现思路：</p>
</li>
<li><p>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区；</p>
</li>
<li><p>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1] &lt;= R[n]；</p>
</li>
<li><p>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区 (Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n - 1，则整个排序过程完成。</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;50, 10, 90, 30, 70, 40, 80, 60, 20&#125;;</span><br><span class="line">        System.out.println(&quot;排序之前：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 堆排序</span><br><span class="line">        heapSort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;排序之后：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 堆排序</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void heapSort(int[] arr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将待排序的序列构建成一个大顶堆</span><br><span class="line">        for (int i &#x3D; arr.length &#x2F; 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            heapAdjust(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 逐步将每个最大值的根节点与末尾元素交换，并且再调整二叉树，使其成为大顶堆</span><br><span class="line">        for (int i &#x3D; arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            swap(arr, 0, i); &#x2F;&#x2F; 将堆顶记录和当前未经排序子序列的最后一个记录交换</span><br><span class="line">            heapAdjust(arr, 0, i); &#x2F;&#x2F; 交换之后，需要重新检查堆是否符合大顶堆，不符合则要调整</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构建堆的过程</span><br><span class="line">     *</span><br><span class="line">     * @param arr 需要排序的数组</span><br><span class="line">     * @param i   需要构建堆的根节点的序号</span><br><span class="line">     * @param n   数组的长度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void heapAdjust(int[] arr, int i, int n) &#123;</span><br><span class="line">        int child;</span><br><span class="line">        int father;</span><br><span class="line">        for (father &#x3D; arr[i]; leftChild(i) &lt; n; i &#x3D; child) &#123;</span><br><span class="line">            child &#x3D; leftChild(i);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果左子树小于右子树，则需要比较右子树和父节点</span><br><span class="line">            if (child !&#x3D; n - 1 &amp;&amp; arr[child] &lt; arr[child + 1]) &#123;</span><br><span class="line">                child++; &#x2F;&#x2F; 序号增1，指向右子树</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果父节点小于孩子结点，则需要交换</span><br><span class="line">            if (father &lt; arr[child]) &#123;</span><br><span class="line">                arr[i] &#x3D; arr[child];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break; &#x2F;&#x2F; 大顶堆结构未被破坏，不需要调整</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] &#x3D; father;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取到左孩子结点</span><br><span class="line">    private static int leftChild(int i) &#123;</span><br><span class="line">        return 2 * i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 交换元素位置</span><br><span class="line">    private static void swap(int[] arr, int index1, int index2) &#123;</span><br><span class="line">        int tmp &#x3D; arr[index1];</span><br><span class="line">        arr[index1] &#x3D; arr[index2];</span><br><span class="line">        arr[index2] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序之前：</span><br><span class="line">50 10 90 30 70 40 80 60 20 </span><br><span class="line">排序之后：</span><br><span class="line">10 20 30 40 50 60 70 80 90</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-4"><a href="#特点分析-4" class="headerlink" title="特点分析"></a>特点分析</h3><p>堆排序时间复杂度：O(nlogn)<br>堆排序对原始记录的排序状态并不敏感，其在性能上要远远好过于冒泡、简单选择、直接插入排序。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>归并排序（merge sort）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。<br><img src="/img/01sort/guibingSort.gif" alt="归并排序"></p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>比如我们对<code>[8,4,5,7,1,3,6,2]</code>这个数组进行归并排序，我们首先利用分治思想的“分”将数组拆分。<br><img src="/img/01sort/mergesort0.png" alt="归并排序"><br>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为<code>log2n</code>。<br>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将<code>[4,5,7,8]</code>和<code>[1,2,3,6]</code>两个已经有序的子序列，合并为最终序列<code>[1,2,3,4,5,6,7,8]</code>，来看下实现步骤。<br><img src="/img/01sort/mergesort2.png" alt="归并排序"></p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        int[] array &#x3D; &#123;2,4,1,5,67,2,45,78,3,9&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sort(int []arr)&#123;</span><br><span class="line">        int []temp &#x3D; new int[arr.length];&#x2F;&#x2F;在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span><br><span class="line">        sort(arr,0,arr.length-1,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void sort(int[] arr,int left,int right,int []temp)&#123;</span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            int mid &#x3D; (left+right)&#x2F;2;</span><br><span class="line">            sort(arr,left,mid,temp);&#x2F;&#x2F;左边归并排序，使得左子序列有序</span><br><span class="line">            sort(arr,mid+1,right,temp);&#x2F;&#x2F;右边归并排序，使得右子序列有序</span><br><span class="line">            merge(arr,left,mid,right,temp);&#x2F;&#x2F;将两个有序子数组合并操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123;</span><br><span class="line">        int i &#x3D; left;&#x2F;&#x2F;左序列指针</span><br><span class="line">        int j &#x3D; mid+1;&#x2F;&#x2F;右序列指针</span><br><span class="line">        int t &#x3D; 0;&#x2F;&#x2F;临时数组指针</span><br><span class="line">        while (i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;</span><br><span class="line">            if(arr[i]&lt;&#x3D;arr[j])&#123;</span><br><span class="line">                temp[t++] &#x3D; arr[i++];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                temp[t++] &#x3D; arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&lt;&#x3D;mid)&#123;&#x2F;&#x2F;将左边剩余元素填充进temp中</span><br><span class="line">            temp[t++] &#x3D; arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;&#x3D;right)&#123;&#x2F;&#x2F;将右序列剩余元素填充进temp中</span><br><span class="line">            temp[t++] &#x3D; arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;将temp中的元素全部拷贝到原数组中</span><br><span class="line">        while(left &lt;&#x3D; right)&#123;</span><br><span class="line">            arr[left++] &#x3D; temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-5"><a href="#特点分析-5" class="headerlink" title="特点分析"></a>特点分析</h3></li>
<li><p>归并排序是一种稳定排序</p>
</li>
<li><p>Java中的<code>Arrays.sort()</code>采用了一种名为TimSort的排序算法，就是归并排序的优化版本</p>
</li>
<li><p>每次合并操作的时间复杂度为O(n)，完全二叉树的深度为<code>|log2n|</code>，总的平均时间复杂度为O(nlogn)<br>归并排序的最好、最坏、平均时间复杂度都为O(nlongn)</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为 O(n+k)，其中 k 是整数的范围。基于比较的排序算法时间复杂度最小是 O(nlogn) 的。注意：计数排序对于实数的排序是不可行的（下面会解释）。该算法于1954年由 Harold H. Seward 提出。 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br><img src="/img/01sort/counting-sort.gif" alt="归并排序"></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>实现思路：</p>
</li>
<li><p>找出待排序的数组中最大和最小的元素；</p>
</li>
<li><p>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</p>
</li>
<li><p>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</p>
</li>
<li><p>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package ttt;</span><br><span class="line"> </span><br><span class="line">public class CountingSort &#123;</span><br><span class="line">    public static int[] countingSort(int[] theArray) &#123;</span><br><span class="line">    	int[] lastArray &#x3D; new int[theArray.length];</span><br><span class="line">        for(int i &#x3D; 0; i &lt; theArray.length; i++) &#123;</span><br><span class="line">        	int count &#x3D; 0;</span><br><span class="line">        	for(int j &#x3D; 0; j &lt; theArray.length; j++) &#123;</span><br><span class="line">        		if(theArray[i] &gt; theArray[j]) &#123;</span><br><span class="line">        			count++;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	lastArray[count] &#x3D; theArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    	return lastArray;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	int []theArray &#x3D; &#123;6, 4, 5, 1, 8, 7, 2, 3&#125;;</span><br><span class="line">        System.out.print(&quot;之前的排序：&quot;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; theArray.length; i++) &#123;</span><br><span class="line">            System.out.print(theArray[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int []resultArray &#x3D; countingSort(theArray);</span><br><span class="line">        </span><br><span class="line">        System.out.print(&quot;计数排序：&quot;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; resultArray.length; i++) &#123;</span><br><span class="line">            System.out.print(resultArray[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>之前的排序：6 4 5 1 8 7 2 3 计数排序：1 2 3 4 5 6 7 8</code></p>
</li>
</ul>
<h3 id="特点分析-6"><a href="#特点分析-6" class="headerlink" title="特点分析"></a>特点分析</h3><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>实现思路：</p>
<ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void bucketSort(int[] arr)&#123;</span><br><span class="line">    </span><br><span class="line">    int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max &#x3D; Math.max(max, arr[i]);</span><br><span class="line">        min &#x3D; Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;桶数</span><br><span class="line">    int bucketNum &#x3D; (max - min) &#x2F; arr.length + 1;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr &#x3D; new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将每个元素放入桶</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        int num &#x3D; (arr[i] - min) &#x2F; (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;对每个桶进行排序</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(bucketArr.toString());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-7"><a href="#特点分析-7" class="headerlink" title="特点分析"></a>特点分析</h3>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3>数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。<br><img src="/img/01sort/radix-sort.gif" alt="基数排序"><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3>实现思路：</li>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class RadixSort &#123;</span><br><span class="line">    private static void radixSort(int[] array,int d)&#123;</span><br><span class="line">        int n&#x3D;1;&#x2F;&#x2F;代表位数对应的数：1,10,100...</span><br><span class="line">        int k&#x3D;0;&#x2F;&#x2F;保存每一位排序后的结果用于下一位的排序输入</span><br><span class="line">        int length&#x3D;array.length;</span><br><span class="line">        int[][] bucket&#x3D;new int[10][length];&#x2F;&#x2F;排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span><br><span class="line">        int[] order&#x3D;new int[length];&#x2F;&#x2F;用于保存每个桶里有多少个数字</span><br><span class="line">        while(n&lt;d)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int num:array) &#x2F;&#x2F;将数组array里的每个数字放在相应的桶里</span><br><span class="line">            &#123;</span><br><span class="line">                int digit&#x3D;(num&#x2F;n)%10;</span><br><span class="line">                bucket[digit][order[digit]]&#x3D;num;</span><br><span class="line">                order[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i&#x3D;0;i&lt;length;i++)&#x2F;&#x2F;将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span><br><span class="line">            &#123;</span><br><span class="line">                if(order[i]!&#x3D;0)&#x2F;&#x2F;这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span><br><span class="line">                &#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;order[i];j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        array[k]&#x3D;bucket[i][j];</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                order[i]&#x3D;0;&#x2F;&#x2F;将桶里计数器置0，用于下一次位排序</span><br><span class="line">            &#125;</span><br><span class="line">            n*&#x3D;10;</span><br><span class="line">            k&#x3D;0;&#x2F;&#x2F;将k置0，用于下一轮保存位排序结果</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] A&#x3D;new int[]&#123;73,22, 93, 43, 55, 14, 28, 65, 39, 81&#125;;</span><br><span class="line">        radixSort(A, 100);</span><br><span class="line">        for(int num:A)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-8"><a href="#特点分析-8" class="headerlink" title="特点分析"></a>特点分析</h3>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n) 的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n) 的时间复杂度。假如待排数据可以分为 d个关键字，则基数排序的时间复杂度将是 <code>O(d*2n)</code> ，当然 d 要远远小于 n，因此基本上还是线性级别的。<br>基数排序的空间复杂度为<code>O(n+k)</code>，其中 k 为桶的数量。一般来说 n&gt;&gt;k，因此额外空间需要大概 n 个左右。</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><img src="/img/01sort/shell-sort.gif" alt="希尔排序"></p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void ShellSort(int num[]) &#123;</span><br><span class="line">    int temp;</span><br><span class="line">    &#x2F;&#x2F;默认步长为数组长度除以2</span><br><span class="line">    int step &#x3D; num.length;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        step &#x3D; step &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F;确定分组数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; step; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;对分组数据进行直接插入排序</span><br><span class="line">            for ( int j &#x3D; i + step; j &lt; num.length; j &#x3D; j + step) &#123;</span><br><span class="line">                temp&#x3D;num[j];</span><br><span class="line">                int k;</span><br><span class="line">                for( k&#x3D;j-step;k&gt;&#x3D;0;k&#x3D;k-step)&#123;</span><br><span class="line">                    if(num[k]&gt;temp)&#123;</span><br><span class="line">                        num[k+step]&#x3D;num[k];</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num[k+step]&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (step &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-9"><a href="#特点分析-9" class="headerlink" title="特点分析"></a>特点分析</h3>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 排序算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/03/17/http01/" rel="next" title="HTTP与HTTPS">
      HTTP与HTTPS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#各类排序算法"><span class="nav-number">1.</span> <span class="nav-text">各类排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法一般分类"><span class="nav-number">2.</span> <span class="nav-text">排序算法一般分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序"><span class="nav-number">3.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">3.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路"><span class="nav-number">3.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现"><span class="nav-number">3.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析"><span class="nav-number">3.4.</span> <span class="nav-text">特点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-number">4.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-1"><span class="nav-number">4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-1"><span class="nav-number">4.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-1"><span class="nav-number">4.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析-1"><span class="nav-number">4.4.</span> <span class="nav-text">特点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-number">5.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-2"><span class="nav-number">5.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-2"><span class="nav-number">5.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-2"><span class="nav-number">5.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析-2"><span class="nav-number">5.4.</span> <span class="nav-text">特点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-number">6.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-3"><span class="nav-number">6.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-3"><span class="nav-number">6.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-3"><span class="nav-number">6.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出结果"><span class="nav-number">6.4.</span> <span class="nav-text">输出结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析-3"><span class="nav-number">6.5.</span> <span class="nav-text">特点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序"><span class="nav-number">7.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-4"><span class="nav-number">7.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-4"><span class="nav-number">7.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-4"><span class="nav-number">7.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析-4"><span class="nav-number">7.4.</span> <span class="nav-text">特点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序"><span class="nav-number">8.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-5"><span class="nav-number">8.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-5"><span class="nav-number">8.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-5"><span class="nav-number">8.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析-5"><span class="nav-number">8.4.</span> <span class="nav-text">特点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计数排序"><span class="nav-number">9.</span> <span class="nav-text">计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-6"><span class="nav-number">9.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-6"><span class="nav-number">9.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-6"><span class="nav-number">9.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析-6"><span class="nav-number">9.4.</span> <span class="nav-text">特点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桶排序"><span class="nav-number">10.</span> <span class="nav-text">桶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-7"><span class="nav-number">10.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-7"><span class="nav-number">10.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-7"><span class="nav-number">10.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析-7"><span class="nav-number">10.4.</span> <span class="nav-text">特点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序"><span class="nav-number">11.</span> <span class="nav-text">基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-8"><span class="nav-number">11.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-8"><span class="nav-number">11.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-8"><span class="nav-number">11.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析-8"><span class="nav-number">11.4.</span> <span class="nav-text">特点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序"><span class="nav-number">12.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-9"><span class="nav-number">12.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-9"><span class="nav-number">12.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-9"><span class="nav-number">12.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点分析-9"><span class="nav-number">12.4.</span> <span class="nav-text">特点分析</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小小鱼"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">小小鱼</p>
  <div class="site-description" itemprop="description">分享学习心得，记录学习过程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JianGao66" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JianGao66" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2517550801@qq.com" title="E-Mail → mailto:2517550801@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小小鱼</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
  
  <script type="text/javascript"
  color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
