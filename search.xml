<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>剑指offer题解笔记：树</title>
    <url>/2020/03/23/0ffer03/</url>
    <content><![CDATA[<h3 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h3><blockquote>
<p>题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>其中树的结构代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TreeLinkNode &#123;</span><br><span class="line">   int val;</span><br><span class="line">   TreeLinkNode left &#x3D; null;</span><br><span class="line">   TreeLinkNode right &#x3D; null;</span><br><span class="line">   TreeLinkNode next &#x3D; null; &#x2F;&#x2F;指向父节点</span><br><span class="line"></span><br><span class="line">   TreeLinkNode(int val) &#123;</span><br><span class="line">       this.val &#x3D; val;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先，注明了是中序遍历的下一个节点，那么需要先研究中序遍历树的特征。比如如下二叉树：<br><img src="/img/03offer/tree-example.png" alt="tree-example"><br>显然中序遍历结果为：9 5 8 2 1 3 6 7 3 4 10<br>那么将凌乱的思路整理一下，其实我们再想一想，其实我们只需要抓住一个关键点进行突破就可以了，那就是给定的节点是否有右子树，分为两种情况：</p>
<ol>
<li>若给定的节点有右子树，如上图的节点5，那么显然5的下一个节点的值应该是8，也就是其右子树的最后一层的左子节点的值。这个实现可以使用递归获取值即可，那么这个问题就轻而易举的解决了。</li>
<li>另外一种情况就是给定的节点没有右子树，这个情况就比较复杂了，也很难想到（所以为啥要刷算法题，毕竟算法又不是你发明的…解决问题的思路还是得学一学的）。最简单的情况就是上面的左下角的9，显然9是没有右子树的，那么它的下一个节点实际上就是它的父节点5；最复杂的情况，就是2的右子节点1，它也没有右子树，但是它的下一个节点应该是根节点3。<br>所以针对上面的第二种情况，最终需要将这两种简单和复杂情况合并，那么有没有这种方法呢？<br>那么当然是可以有的，由于题目特别说明这个树的节点是包含指向父节点的指针的，那么根据这个特性，我们可以再思考一下：<br>实际上只要循环找到当前节点的父节点的左子节点等于当前节点，那么这个问题就被KO了<br>局部代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (pNode.next !&#x3D; null) &#123;</span><br><span class="line">     TreeLinkNode parent &#x3D; pNode.next;</span><br><span class="line">     if (parent.left &#x3D;&#x3D; pNode) &#123;</span><br><span class="line">         return parent;</span><br><span class="line">     &#125;</span><br><span class="line">     pNode &#x3D; pNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中pNode是给定的节点，我们最终是要找pNode的下一个节点。<br>根据上述代码，对于节点9，上面显然可以得其下一个节点是5，结果正确。<br>对于节点1，根据上面循环往上找，最终确实找到了其下一个节点是3，结果正确。<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4>综合上述思路，最终可以整理代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public TreeLinkNode GetNext(TreeLinkNode pNode) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果有右子树，则找右子树的最左节点</span><br><span class="line">   if (pNode.right !&#x3D; null) &#123;</span><br><span class="line">       TreeLinkNode node &#x3D; pNode.right;</span><br><span class="line">        while (node.left !&#x3D; null) &#123;</span><br><span class="line">             node &#x3D; node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F;没有右子树，向上找第一个左链接指向的树包含该节点的祖先节点</span><br><span class="line">       while (pNode.next !&#x3D; null) &#123;</span><br><span class="line">          TreeLinkNode parent &#x3D; pNode.next;</span><br><span class="line">          if (parent.left &#x3D;&#x3D; pNode) &#123;</span><br><span class="line">              return parent;</span><br><span class="line">          &#125;</span><br><span class="line">          pNode &#x3D; pNode.next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><blockquote>
<p>题目描述：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题其实思路上难度不是很大，只要画个图，就可以看明白一半。<br><img src="/img/03offer/tree-sym.png" alt="tree-sym"><br>如上图就属于题目描述的对称二叉树的一种，那么显然，只需要我们确定一个根节点下的左子节点的值和右子节点的值是否相同就可以，只要有一个不同，那么就不是对称二叉树。具体过程可以使用递归来完成。</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isSymmetrical(TreeNode pRoot) &#123;</span><br><span class="line">    if(pRoot &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">     return isSym(pRoot,pRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否相等</span><br><span class="line">private boolean isSym(TreeNode root1,TreeNode root2)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果递归中root1为null，root2不为null，那么说明不对称</span><br><span class="line">    &#x2F;&#x2F;如果root1&#x3D;root2&#x3D;null，那么说明递归完成后没有返回false说明完全对称，即返回true</span><br><span class="line">   if(root1 &#x3D;&#x3D; null)&#123;</span><br><span class="line">      return root2 &#x3D;&#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;由于上面先判断了root1&#x3D;&#x3D;null，所以如果进入了这一步，说明root1 !&#x3D; null</span><br><span class="line">    &#x2F;&#x2F;但是root2先到null了，这说明存在不对称的部分，直接返回false</span><br><span class="line">   if(root2 &#x3D;&#x3D; null)&#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;判断值是否相同</span><br><span class="line">   if(root1.val !&#x3D; root2.val)&#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;递归调用</span><br><span class="line">   return isSym(root1.left,root2.right) &amp;&amp; isSym(root1.right,root2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h3><blockquote>
<p>题目描述：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题本质上就是层序遍历，不过一般我们只使用了前序遍历、中序遍历、后序遍历，对于层序遍历，涉及的不是很多。并且这个题还需要将输出结果转换成ArrayList存储的形式，即每行的结果都是一个ArrayList，这是这个题目稍微需要拐弯的地方。<br>那么对于树，其实绝大多数情况下都可以使用递归来解决问题。这个题需要解决的问题有：</p>
<ol>
<li>先确定这颗二叉树的深度，即有多少行，这样才可以创建ArrayList的个数</li>
<li>剩下的添加节点完全可以使用递归实现<h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    depth(pRoot, 1, list);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void depth(TreeNode root, int depth, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list) &#123;</span><br><span class="line">   if (root &#x3D;&#x3D; null) return;</span><br><span class="line">   if (depth &gt; list.size())&#123;</span><br><span class="line">       list.add(new ArrayList&lt;&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   list.get(depth - 1).add(root.val);</span><br><span class="line"></span><br><span class="line">   depth(root.left, depth + 1, list);  </span><br><span class="line">   depth(root.right, depth + 1, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="二叉搜索树的第k个节点"><a href="#二叉搜索树的第k个节点" class="headerlink" title="二叉搜索树的第k个节点"></a>二叉搜索树的第k个节点</h3><blockquote>
<p>题目描述：给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p>
</blockquote>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>对于一颗二叉搜索树而言，其实际结构就是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   7</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">2  4 6  8</span><br></pre></td></tr></table></figure>
<p>这种情况下有一个非常好的特点，那就是二叉搜索树的中序遍历的结果恰好是按照大小顺序排列的。</p>
<h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><p>基于上述结论，实际上可以立马写出如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：中序遍历二叉搜索树</span><br><span class="line">TreeNode KthNode(TreeNode pRoot, int k) &#123;</span><br><span class="line">   if(pRoot &#x3D;&#x3D; null) return null;</span><br><span class="line"></span><br><span class="line">   ArrayList&lt;TreeNode&gt; arr &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">   midSeek(pRoot,arr);</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F;获取节点的个数，并与k比较</span><br><span class="line">   if(k &lt;&#x3D; 0 || k &gt; arr.size())&#123;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return arr.get(k-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">private void midSeek(TreeNode pRoot,ArrayList&lt;TreeNode&gt; arr)&#123;</span><br><span class="line">     if(pRoot.left !&#x3D; null)&#123;</span><br><span class="line">        midSeek(pRoot.left,arr);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     arr.add(pRoot);</span><br><span class="line">    </span><br><span class="line">     if(pRoot.right !&#x3D; null)&#123;</span><br><span class="line">        midSeek(pRoot.right,arr);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上面代码实际上有一些冗余，并不是最优解，因为是先将中序遍历结果全部找出来，再挑第k个值。那么按照老套路，是不是可以想个办法，在中序遍历的时候就直接一次性找出第k个值呢？答案是显然可以的。<br>优化后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   int index &#x3D; 0; &#x2F;&#x2F;计数器</span><br><span class="line">    TreeNode KthNode(TreeNode root, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root !&#x3D; null)&#123; &#x2F;&#x2F;中序遍历寻找第k个</span><br><span class="line">            TreeNode node &#x3D; KthNode(root.left,k);</span><br><span class="line">            if(node !&#x3D; null)</span><br><span class="line">                return node;</span><br><span class="line">            index ++;</span><br><span class="line">            if(index &#x3D;&#x3D; k)</span><br><span class="line">                return root;</span><br><span class="line">            node &#x3D; KthNode(root.right,k);</span><br><span class="line">            if(node !&#x3D; null)</span><br><span class="line">                return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：递归与循环</title>
    <url>/2020/03/21/0ffer02/</url>
    <content><![CDATA[<h3 id="斐波拉契数列"><a href="#斐波拉契数列" class="headerlink" title="斐波拉契数列"></a>斐波拉契数列</h3><blockquote>
<p>题目描述：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p>
</blockquote>
<p>斐波拉契数列应该是很多学生大一学习C语言时解决的一个问题，我记得那时候好像是用递归算法去解决的，然鹅稍微懂一些数据结构的小伙伴应该都知道，斐波拉契数列是最好不使用递归算法的，为什么呢，因为递归计算斐波拉契数列的时候重复计算项很多，而且越到后面计算量越来越爆炸，最后会导致运行超时，比如栈溢出等exception，如果我们使用递归，代码确实简洁了，比如下面：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int Fibonacci(int n)&#123;</span><br><span class="line">    if(n &lt; 1)  return 0;</span><br><span class="line">    if(n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是比如我们想求解第10项数据的时候，我们以f(10)表示第10项斐波拉契结果，那么用递归运行时会出现下面结构：<br><img src="/img/02offer/fib.png" alt="fib"><br>不难看出，重复的节点会随着n的增大而急剧增大，事实上也是，用递归方法计算的时间复杂度是以n的指数方式递增的，不妨可以使用递归计算一下Fibonacci的第100项，看看会慢到什么程度。<br>所以实用解法肯定不是这种啦。<br>而改进方法，实际上目的就是为了避免上面的重复计算，那么我们实际上用一个数列保存已经计算过的数。于是我们可以写出如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">   if(n &lt; 1)&#123;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2)&#123;</span><br><span class="line">       return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   if(n &#x3D;&#x3D; 3)&#123;</span><br><span class="line">       return 2;</span><br><span class="line">   &#125;</span><br><span class="line">   int fib1 &#x3D; 1;</span><br><span class="line">   int fib2 &#x3D; 2;</span><br><span class="line">   int result &#x3D; 0;</span><br><span class="line">   for(int i &#x3D; 3 ; i &lt; n ; i++)&#123;</span><br><span class="line">       result &#x3D; fib1 + fib2;</span><br><span class="line">       fib1 &#x3D; fib2;</span><br><span class="line">       fib2 &#x3D; result;</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就可以简约的搞定问题了！</p>
<h3 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h3><blockquote>
<p>题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<p>首先我们可以从最简单的情况开始考虑，如果只有一级台阶，那显然只能跳一次。如果有两级台阶，那么就有两种跳法：一种是每次跳一级；另一种是一次跳两级。<br>然后我们将这种情况一般化，假如有n级台阶，可以把跳n级台阶的跳法看作是n的函数f(n)。当n&gt;2时，第一次跳的时候就有两种选择：<br>第一次跳一级，那么跳法数目等于后面的n-1级台阶的跳法数目，即为f(n-1)。<br>第一次跳两级，那么跳法数目等于后面的n-2级台阶的跳法数目，即为f(n-2)。<br>因此，n级台阶的不同跳法数目的总数为f(n)=f(n-1)+f(n-2)，到这里应该可以看出，说到底这个问题就是一个包装的斐波拉契数列问题。<br>那么代码其实跟上面的没啥区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public int JumpFloor(int target) &#123;</span><br><span class="line">    if(target &lt;&#x3D; 2)&#123;</span><br><span class="line">       return target;</span><br><span class="line">    &#125;</span><br><span class="line">    int pre1 &#x3D; 1;</span><br><span class="line">    int pre2 &#x3D; 2;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 2;i &lt; target; i++)&#123;</span><br><span class="line">        result &#x3D; pre1 + pre2;</span><br><span class="line">        pre1 &#x3D; pre2;</span><br><span class="line">        pre2 &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="变态青蛙跳台阶"><a href="#变态青蛙跳台阶" class="headerlink" title="变态青蛙跳台阶"></a>变态青蛙跳台阶</h3><blockquote>
<p>题目描述：这次这只青蛙很变态，一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>这个其实问题更不大，这本质上就是一个简单的数学问题，我们可以根据上面那个问题归纳这个问题：<br>跳n级台阶时，这时候跳法就很多了：<br>第一次跳一级，那么剩下的就是f(n-1)<br>第一次跳两级，那么剩下的就是f(n-2)<br>第一次跳三级，那么剩下的就是f(n-3)<br>….<br>第一次跳n-1级，那么剩下就是f(1).<br>那么实际上就是f(n)=f(n-1)+f(n-2)+f(n-3)+…+f(1)，又因为f(n-1)=f(n-2)+f(n-3)+…+f(1)<br>，所以f(n)=2f(n-1)。<br>到这里应该可以看出来了吧？这不就是一个等比数列吗，并且f(1)=1。<br>那么实际上f(n)=2^(n-1)，完事！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int JumpFloorII1(int target)&#123;</span><br><span class="line">   return (int)java.util.Math.pow(2,target-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h3><blockquote>
<p>题目描述：我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？</p>
</blockquote>
<p>这个就借用<code>牛客网答题者csdong</code>的回答，很简单易懂：<br><img src="/img//02offer/juxing.png" alt="juxing"></p>
<p>所以跟上面的还是没区别。。。依然是老瓶装新酒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int RectCover(int target) &#123;</span><br><span class="line">   if(target &lt;&#x3D; 2)&#123;</span><br><span class="line">       return target;</span><br><span class="line">   &#125;</span><br><span class="line">   int pre1 &#x3D; 1,pre2 &#x3D; 2;</span><br><span class="line">   int result &#x3D; 0;</span><br><span class="line">   for(int i &#x3D; 3; i &lt;&#x3D; target;i++)&#123;</span><br><span class="line">        result &#x3D; pre1 + pre2;</span><br><span class="line">        pre1 &#x3D; pre2;</span><br><span class="line">        pre2 &#x3D; result;</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>递归与循环</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：位操作</title>
    <url>/2020/03/25/0ffer04/</url>
    <content><![CDATA[<h3 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a>位1的个数</h3><blockquote>
<p>题目描述： 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数。</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题的解法比较多，有位移法、位操作法、查表法、二次查表法等方法。甚至在java的工具类下面有一个bitCount()方法可以直接返回一个整数的二进制表达式中1的个数。<br>但是一般如果面试题中遇到这题，往往还是考察对位操作的使用。</p>
<a id="more"></a>
<p>观察一下 n 与 n-1 这两个数的二进制表示：对于 n-1这个数的二进制来说，相对于n的二进制，它的最末位的一个 1 会变成 0，最末位一个 1之后的0 会全部变成 1，其它位相同不变。<br>比如<code>n = 8888</code>，其二进制为 <code>10001010111000</code><br>则 <code>n - 1 = 8887</code> ，其二进制为<code>10001010110111</code><br>通过按位与操作后：<code>n &amp; (n-1) = 10001010110000</code><br>也就是说：通过<code>n&amp;(n-1)</code>这个操作，可以起到消除最后一个1的作用。所以可以通过执行 <code>n&amp;(n-1)</code> 操作来消除 n 末尾的 1 ，消除了多少次，就说明有多少个 1 。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">    int cnt &#x3D; 0;</span><br><span class="line">    while (n !&#x3D; 0) &#123;</span><br><span class="line">       cnt++;</span><br><span class="line">       n &amp;&#x3D; (n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者可以直接用jdk自带函数解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int NumberOf11(int n) &#123;</span><br><span class="line">   return Integer.bitCount(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h3><blockquote>
<p>题目描述：给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先，先来分析一下 2 的次方数的二进制写法：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">4</th>
<th align="center">8</th>
<th align="center">16</th>
<th align="center">···</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">10</td>
<td align="center">100</td>
<td align="center">1000</td>
<td align="center">10000</td>
<td align="center">···</td>
</tr>
</tbody></table>
<p>仔细观察，可以看出 2 的次方数都只有一个 1 ，剩下的都是 0 。根据这个特点，只需要每次判断最低位是否为 1 ，然后向右移位，最后统计 1 的个数即可判断是否是 2 的次方数。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isPowerOfTwo(int n)&#123;</span><br><span class="line">    int cnt &#x3D; 0;</span><br><span class="line">    while(n &gt; 0)&#123;</span><br><span class="line">        cnt +&#x3D; (n &amp; 1);</span><br><span class="line">        n &gt;&gt;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt &#x3D;&#x3D; 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该题还有一种巧妙的解法。再观察上面的表格，如果一个数是 2 的次方数的话，那么它的二进数必然是最高位为1，其它都为 0 ，那么如果此时我们减 1 的话，则最高位会降一位，其余为 0 的位现在都为变为 1，那么我们把两数相与，就会得到 0。<br>比如 2 的 3 次方为 8，二进制位 1000 ，那么 8 - 1 = 7，其中 7 的二进制位0111。<br>利用这个性质，只需一行代码就可以搞定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isPowerOfTwo(int n)&#123;</span><br><span class="line">    return (n &gt; 0) &amp;&amp; (!(n &amp; (n - 1)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数字的范围按位与"><a href="#数字的范围按位与" class="headerlink" title="数字的范围按位与"></a>数字的范围按位与</h3><blockquote>
<p>题目描述：给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
</blockquote>
<p>比如：输入<code>[26,30]</code><br>输出：24</p>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先，将<code>[ 26 , 30 ]</code> 的范围数字用二进制表示出来：<br>11010　　11011　　11100　　11101　　11110<br>而输出 24 的二进制是 11000 。<br>可以发现，只要找到二进制的 左边公共部分 即可。<br>所以，可以先建立一个 32 位都是 1 的 mask，然后每次向左移一位，比较 m 和 n 是否相同，不同再继续左移一位，直至相同，然后把 m 和 mask 相与就是最终结果。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int rangeBitwiseAnd(int m,int n)&#123;</span><br><span class="line">        int d &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        while ((m &amp; d) !&#x3D; (n &amp; d)) &#123;</span><br><span class="line">            d &lt;&lt;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return m &amp; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重复的DNA序列"><a href="#重复的DNA序列" class="headerlink" title="重复的DNA序列"></a>重复的DNA序列</h3><blockquote>
<p>题目描述：所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。编写一个函数来查找 DNA 分子中所有出现超过一次的 10 个字母长的序列（子串）</p>
</blockquote>
<p>例如：<br>输入:<code>s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</code><br>输出:<code>[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]</code></p>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先，依旧先将 A , C , G , T 的 ASCII 码用二进制来表示：<br>A: 0100 0001　　C: 0100 0011　　G: 0100 0111　　T: 0101 0100<br>通过观察发现每个字符的后三位都不相同，因此可以用末尾的三位来区分这四个字符。<br>题目要求是查找 10 个字母长的序列，这里我们将每个字符用三位来区分的话，10 个字符就需要 30 位 ，在32位机上也 OK 。<br>为了提取出后 30 位，需要使用 mask ，取值为 0x7ffffff（二进制表示含有 27 个 1） ，先用此 mask 可取出整个序列的后 27 位，然后再向左平移三位可取出 10 个字母长的序列 （ 30 位）。<br>为了保存子串的频率，这里使用哈希表。<br>首先当取出第十个字符时，将其存在哈希表里，和该字符串出现频率映射，之后每向左移三位替换一个字符，查找新字符串在哈希表里出现次数，如果之前刚好出现过一次，则将当前字符串存入返回值的数组并将其出现次数加一，如果从未出现过，则将其映射到 1。<br>举个栗子：<br>根据题意，第一个操作：首先取出前九个字符 AAAAACCCC ，根据上面的分析，用三位来表示一个字符，所以这九个字符可以用二进制表示为 001001001001001011011011011，<br>第二个操作：开始遍历字符串，下一个进来的是 C ，则当前字符为 AAAAACCCCC ，二进制表示为001001001001001011011011011011，然后将其存入哈希表中。然后再读入下一个字符 A，则此时字符串为AAAACCCCCA，依旧使用二进制进行表示。<br>以此类推，当某个序列之前已经出现过了，只需要将其存入结果 res 中即可 。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if (s.size() &lt;&#x3D; 10) return res;</span><br><span class="line">        int mask &#x3D; 0x7ffffff, cur &#x3D; 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; m;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;</span><br><span class="line">            cur &#x3D; (cur &lt;&lt; 3) | (s[i] &amp; 7);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 9; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            cur &#x3D; ((cur &amp; mask) &lt;&lt; 3) | (s[i] &amp; 7);</span><br><span class="line">            if (m.count(cur)) &#123;</span><br><span class="line">                if (m[cur] &#x3D;&#x3D; 1) res.push_back(s.substr(i - 9, 10));</span><br><span class="line">                ++m[cur]; </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                m[cur] &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>位操作</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：数组</title>
    <url>/2020/03/28/0ffer05/</url>
    <content><![CDATA[<h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><blockquote>
<p>题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>数组类题目解题往往是存在直观解法的，因为不管是一维数组还是二维数组，都可以直接通过双重for循环之类方法进行直接求解，但是这种解法的时间复杂度都是很高的，为此，在算法类题目中涉及到数组，往往不会使用多重循环求解。</p>
<a id="more"></a>

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度为O(n^2)</span><br><span class="line">public static boolean duplicate(int[] numbers, int length, int[] duplication) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; length; j++) &#123;</span><br><span class="line">           if(numbers[i] &#x3D;&#x3D; numbers[j])&#123;</span><br><span class="line">               duplication[0] &#x3D; numbers[i];</span><br><span class="line">               return true;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个双重for循环可以直接搞定，但是问题来了，上面解法时间复杂度显然为O(n^2)，这种复杂度对于海量数据求解来说，是很不可取的。<br>那么我们可以再次进行优化一下，我们可以对数组进行排序，这样算法复杂度会降低，于是可以以下面代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度为O(nlogn)</span><br><span class="line">public static boolean duplicate(int[] numbers, int length, int[] duplication) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; length ; i++)&#123;</span><br><span class="line">        list.add(numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list); &#x2F;&#x2F;时间复杂度为O(NlogN)</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; list.size() ; i++)&#123;</span><br><span class="line">        if(i+1 &lt; list.size())&#123;</span><br><span class="line">            if(list.get(i) &#x3D;&#x3D; list.get(i+1))&#123;</span><br><span class="line">               duplication[0] &#x3D; list.get(i);</span><br><span class="line">               return true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上述还不是最优解，假如我们要求时间复杂度为O(n)，空间复杂度为O(1)，在这个前提下，我们需要再寻求一种最优解。<br>那么我们需要注意到题目中有一个条件是<em>长度为n的数组里面所有数字都在0~n-1范围内</em>，这个条件肯定不是白给的，上面两种解题思路都没有用到这个条件，那么这个条件肯定就是解题的关键。<br>根据上面思路，如果这个数组中没有重复的数字，那么当数组排序后，数字i将出现在下标为i的位置，但是由于数组中一定有重复的数字，那么有些位置可能存在多个数字，同时有些位置可能没有数字。<br>比如对于数组<code>[2,3,1,0,2,5,3]</code></p>
<ol>
<li>首先从头到尾扫描这个数组，当扫描到下标为i 的数字时，比较这个数字（比如为m）是不是等于i</li>
<li>如果是，那么接着扫描下一个数字</li>
<li>如果不是，那么拿这个数字跟第m个数字进行比较。</li>
<li>如果这个数字跟第m个数字相等，那么这个数字就是其中一个重复数字，结束寻找</li>
<li>如果不等，将把第i个数字和第m个数字交换，即把m放到属于它的位置</li>
<li>重复上述过程，直到发现一个重复的数字。<br>根据上述思路，我们可以写出最终优化的代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean duplicate(int[] numbers,int length,int[] duplication) &#123;</span><br><span class="line">      &#x2F;&#x2F;考虑边界条件</span><br><span class="line">      if(numbers &#x3D;&#x3D; null || length &lt;&#x3D; 0)&#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      for (int i &#x3D; 0; i &lt; length-1; i++)&#123;</span><br><span class="line">          while (numbers[i] !&#x3D; i)&#123;</span><br><span class="line">              if(numbers[i] &#x3D;&#x3D; numbers[numbers[i]])&#123;</span><br><span class="line">                  duplication[0] &#x3D; numbers[i];</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">              swap(numbers,i,numbers[i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void swap(int[] nums,int i,int j)&#123;</span><br><span class="line">      int temp &#x3D; nums[i];</span><br><span class="line">      nums[j] &#x3D; nums[i];</span><br><span class="line">      nums[i] &#x3D; temp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="二维数组的查找"><a href="#二维数组的查找" class="headerlink" title="二维数组的查找"></a>二维数组的查找</h3><blockquote>
<p>题目描述：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>那么显然同上一题，这个题还是可以通过双重for循环直接解决，并且代码十分简洁。但是还是那个问题，最直观的解法往往不是最优解，题目给了那么多条件，仅仅通过一个双重for循环完成，时间复杂度是非常高的。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>根据题目条件，实际上不难想出另外一种解法：<br>比如对于如下二维数组，我们要查找数字7：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2  8  9</span><br><span class="line">2  4  9  12</span><br><span class="line">4  7  10 13</span><br><span class="line">6  8  11 15</span><br></pre></td></tr></table></figure>
<p>由于数组从左到右递增，从上到下递增，我们可以试图先选一个边角的值，比如右上角的9，这个值比它左边的值都要大，比它下面的值都要小。<br>那么这个值比要找的7要大，说明7不可能在9这一列了，于是我们把这一列去掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2  8</span><br><span class="line">2  4  9</span><br><span class="line">4  7  10</span><br><span class="line">6  8  11</span><br></pre></td></tr></table></figure>
<p>继续选取右上角的值，我们发现8还是比7要大，于是8这一列的值也可以删掉了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2</span><br><span class="line">2  4</span><br><span class="line">4  7</span><br><span class="line">6  8</span><br></pre></td></tr></table></figure>
<p>然后选取右上角的值2，由于2比7小，那么说明2所在的一行不可能包括7，那么把这一行删掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2  4</span><br><span class="line">4  7</span><br><span class="line">6  8</span><br></pre></td></tr></table></figure>
<p>由于右上角的4比7要小，那么同样可以删掉这一行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4  7</span><br><span class="line">6  8</span><br></pre></td></tr></table></figure>
<p>最终右上角的值就是我们要找的值，那么这种办法实际上避免了双重循环的冗余度，可以很快的找到是否包括需要查找的值。并且在数据量越大的时候，越能体会到这种算法的时间优越性。这就是算法的实用性所在。<br>基于上述思路，代码实现可以如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">    boolean flag &#x3D; false;</span><br><span class="line">    if(array !&#x3D; null &amp;&amp; array.length &gt; 0 &amp;&amp; array[0].length &gt; 0)&#123;</span><br><span class="line">        int row &#x3D; 0 ;</span><br><span class="line">        int columns &#x3D; array[0].length;</span><br><span class="line">        int column &#x3D;  columns - 1;</span><br><span class="line">        while(row &lt; array.length &amp;&amp; column &gt;&#x3D; 0)&#123;</span><br><span class="line">            if(array[row][column] &#x3D;&#x3D; target)&#123;</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(array[row][column] &gt; target)&#123;</span><br><span class="line">                &#x2F;&#x2F;如果右上角元素的值比目标值要大，就删除最后一列</span><br><span class="line">                column--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;如果右上角元素的值比目标值要小，就删除最上面一行</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h3><blockquote>
<p>题目描述：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果没有不能使用除法的限制，那么这个题目可以直接使用公式解出来，即将<code>(A[0]*A[1]*...*A[n-1])/A[i]</code>即可得到结果。<br>既然不能用除法，那么只能寻找其他思路。</p>
<ol>
<li>直接按题目要求连乘，显然时间复杂度为O(n^2)</li>
<li>有吗？<br>当然有，我们基于题目算法可以构建矩阵如下：<br><img src="/img/03offer/array-multi.png" alt="array-multi"><br>其中B[i]的值可以看作下图的矩阵中每行的乘积。<br>下三角用连乘可以很容求得，上三角，从下向上也是连乘。<br>因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] multiply(int[] A) &#123;</span><br><span class="line">        int length &#x3D; A.length;</span><br><span class="line">        int[] B &#x3D; new int[length];</span><br><span class="line">        if(length !&#x3D; 0 )&#123;</span><br><span class="line">            B[0] &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F;计算下三角连乘</span><br><span class="line">            for(int i &#x3D; 1; i &lt; length; i++)&#123;</span><br><span class="line">                B[i] &#x3D; B[i-1] * A[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            int temp &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F;计算上三角</span><br><span class="line">            for(int j &#x3D; length-2; j &gt;&#x3D; 0; j--)&#123;</span><br><span class="line">                temp *&#x3D; A[j+1];</span><br><span class="line">                B[j] *&#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：时间效率</title>
    <url>/2020/04/01/0ffer06/</url>
    <content><![CDATA[<h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><blockquote>
<p>题目描述：HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>第一次看到这个题的时候，最直观的思路应该是想办法枚举所有子数组并求其和，但是一个长度为n的数组，枚举的子数组共有n(n+1)/2个，因此最快也需要O(n^2)时间。在算法题目中，凡是面对这种复杂度的解法，往往是不考虑这种解法的。</p>
<a id="more"></a>
<p>以下解法均以数组<code>aray = {1，-2，3，10，-4，7，2，-5}</code>为例，该数组的最大和数组为<code>{3,10,-4,7,2}</code>，最大和为18。</p>
<h4 id="解法一：分析数组的规律"><a href="#解法一：分析数组的规律" class="headerlink" title="解法一：分析数组的规律"></a>解法一：分析数组的规律</h4><p>可以先试着从头到尾累加数组中的每个数字。初始化和为0，第一次加上1，此时和为1。第二步加上-2，和变成了-1，如果再加上第三个数字3，我们注意到此前累加的和是-1，加上3后和为2，累加和的结果比3本身还要小。也就是说，从第一个数字开始的子数组的和比从第三个数字开始的子数组的和要小。因此，我们完全没有必要考虑从第一个数字开始的子数组，并且之前累加的和也可以抛弃。<br>然后我们从第三个数字开始累加，此时的和为3，第四步加10后和为13。第五步加上-4后和为9，这时我们发现由于-4是一个负数，那么累加之后的结果比原来的和还要小，因此我们需要把之前得到的累加和13保存下来，因为它有可能是最大子数组的和。然后第六步加上数字7得到和为16比保存的13要大，因此把最大子数组的和从13更新为16，然后再加2得到和为18，那么继续更新最大子数组的和为18。依此类推，最终结果为18。<br>那么我们用表总结一下上述过程：</p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>操作</strong></th>
<th><strong>累加的子数组和</strong></th>
<th><strong>最大的子数组和</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>加1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>加-2</td>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>抛弃前面的和-1，加3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>加10</td>
<td>13</td>
<td>13</td>
</tr>
<tr>
<td>5</td>
<td>加-4</td>
<td>9</td>
<td>13</td>
</tr>
<tr>
<td>6</td>
<td>加7</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>7</td>
<td>加2</td>
<td>18</td>
<td>18</td>
</tr>
<tr>
<td>8</td>
<td>加-5</td>
<td>13</td>
<td>18</td>
</tr>
</tbody></table>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">    if (array.length &#x3D;&#x3D; 0 || array &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int curSum &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;设置一个32位int型整数的最小值(-2)^32，保证第一次一定可以更新最大值</span><br><span class="line">    int greatestSum &#x3D; 0x80000000;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果加的值小于0，保持之前的最大值</span><br><span class="line">        if (curSum &lt;&#x3D; 0) &#123;</span><br><span class="line">            curSum &#x3D; array[i]; &#x2F;&#x2F;记录当前最大值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F;当array[i]为正数时，加上之前的最大值并更新最大值。</span><br><span class="line">            curSum +&#x3D; array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;更新最大值</span><br><span class="line">        if (curSum &gt; greatestSum) &#123;</span><br><span class="line">            greatestSum &#x3D; curSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return greatestSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h4><p>这个题显然还可以使用DP来做，但是DP的状态转移方程比较难想到。<br>f(i)：以<code>array[i]</code>为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变 。<br>那么可以列出转移方程：<code>f(i) = max( f(i-1)+array[i] ，array[i] )</code><br>res：所有子数组的和的最大值 ，那么<code>res=max(res, f(i))</code>。<br>比如对于<code>aray = {1，-2，3，10，-4，7，2，-5}</code>：<br>初始状态：<code>f(0)=1</code>，<code>res=1</code>。</p>
<ol>
<li>当i=1时，<code>f(1)=max(f(0)-2,-2)=-1</code>，那么<code>res=max(1,-2)=1</code>。</li>
<li>当i=2时，f(2)=<code>max(f(1)+3,3)=3</code>，那么<code>res=max(1,3)=3</code>。</li>
<li>当i=3时，f(3)=<code>max(f(2)+10,10)=13</code>，那么<code>res=max(3,13)=13</code>。</li>
<li>当i=4时，<code>f(4)=max(f(3)-4,-4)=9</code>，那么<code>res=max(13,9)=13</code>。</li>
<li>当i=5时，f(5)=<code>max(f(4)+7,7)=16</code>，那么<code>res=max(16,13)=16</code>。</li>
<li>当i=6时，f(6)=<code>max(f(5)+2,2)=18</code>，那么res=<code>max(18,16)=18</code>。</li>
<li>当i=7时，f(7)=<code>max(f(6)-5,-5)=13</code>，那么<code>res=max(13,18)=18</code>。<br>因此最终结果为18。<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int FindGreatestSumOfSubArray1(int[] array) &#123;</span><br><span class="line">    int res &#x3D; array[0]; &#x2F;&#x2F;记录当前所有子数组的和的最大值</span><br><span class="line">    int max &#x3D; array[0];   &#x2F;&#x2F;包含array[i]的连续数组最大值</span><br><span class="line">    for (int i &#x3D; 1; i &lt; array.length; i++) &#123;</span><br><span class="line">        max &#x3D; Math.max(max + array[i], array[i]);</span><br><span class="line">        res &#x3D; Math.max(max, res);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述两种思路的时间复杂度均为O(n)。</li>
</ol>
<h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h3><blockquote>
<p>题目描述：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题最直观的思路，也是能够直接解决问题的解法就是直接对数组进行排序，然后取最小的前k个数就可以了。这种思路的平均时间复杂度为O(nlong)，并且不适合用于海量数据，面试的时候会提示有更快的解法。<br>还有一种思路就是用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，然后新数入堆。这种思路下时间复杂度为O(nlogk)，并且可以处理海量数据。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="解法一：对数组进行排序实现"><a href="#解法一：对数组进行排序实现" class="headerlink" title="解法一：对数组进行排序实现"></a>解法一：对数组进行排序实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123;</span><br><span class="line">    if(input &#x3D;&#x3D; null || input.length &lt;&#x3D; 0 || k &lt;&#x3D; 0 || k &gt; input.length)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; array &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; input.length ; i++)&#123;</span><br><span class="line">        array.add(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(array);</span><br><span class="line">    ArrayList&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; k ; i++)&#123;</span><br><span class="line">        result.add(array.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二：基于最大堆实现"><a href="#解法二：基于最大堆实现" class="headerlink" title="解法二：基于最大堆实现"></a>解法二：基于最大堆实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution1(int[] input, int k) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    int length &#x3D; input.length;</span><br><span class="line">    if(k &gt; length || k &lt; 1)&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;基于最大堆实现</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap &#x3D; new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            return o2.compareTo(o1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (maxHeap.size() !&#x3D; k) &#123;</span><br><span class="line">            maxHeap.offer(input[i]);</span><br><span class="line">        &#125; else if (maxHeap.peek() &gt; input[i]) &#123;</span><br><span class="line">            Integer temp &#x3D; maxHeap.poll();</span><br><span class="line">            temp &#x3D; null;</span><br><span class="line">            maxHeap.offer(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (Integer integer : maxHeap) &#123;</span><br><span class="line">        result.add(integer);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h3><blockquote>
<p>题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>刚看到这个题的时候，最直观的思路应该还是使用排序，这样时间复杂度为O(nlogn)，但是还是那句话，最直观的思路往往不是面试官满意的算法。<br>首先在思路上可以想到，能够使用HashMap，由于HashMap不能存储相同的键，那么把数组中的数字作为键，如果相同，则其值加1，这样最后直接判断HashMap中的键对应的值是否超过了数组的一半即可，并且这种解法时间复杂度为O(n)。<br>除去HashMap之外，针对数组本身，我们还可以想到一种O(n)的解法，那就是只遍历一次数组，在这次遍历中找到其中重复次数最多的数字，然后跟数组长度的一半进行比较。这种解法的时间复杂度也为O(n)。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="解法一：对数组进行排序"><a href="#解法一：对数组进行排序" class="headerlink" title="解法一：对数组进行排序"></a>解法一：对数组进行排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">    Arrays.sort(array);</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">        if(array[i]&#x3D;&#x3D;array[array.length&#x2F;2])&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(count&gt;array.length&#x2F;2)&#123;</span><br><span class="line">        return array[array.length&#x2F;2];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二：使用HashMap"><a href="#解法二：使用HashMap" class="headerlink" title="解法二：使用HashMap"></a>解法二：使用HashMap</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int MoreThanHalfNum_Solution(int[] array) &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">        if(!map.containsKey(array[i]))&#123;</span><br><span class="line">            map.put(array[i],1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int count &#x3D; map.get(array[i]);</span><br><span class="line">            map.put(array[i],++count);</span><br><span class="line">            if(map.get(array[i]) &gt; array.length&#x2F;2)&#123;</span><br><span class="line">                return array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法三：-基于数组本身的特点"><a href="#解法三：-基于数组本身的特点" class="headerlink" title="解法三： 基于数组本身的特点"></a>解法三： 基于数组本身的特点</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">    if(array &#x3D;&#x3D; null || array.length &lt;&#x3D; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    int len &#x3D; array.length;</span><br><span class="line">    int times &#x3D; 1;</span><br><span class="line">    int res &#x3D; array[0];</span><br><span class="line">    &#x2F;&#x2F; 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1</span><br><span class="line">    for(int i &#x3D; 1; i &lt; len; i++)&#123;</span><br><span class="line">        if(times &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            &#x2F;&#x2F; 更新result的值为当前元素，并置次数为1</span><br><span class="line">            res &#x3D; array[i];</span><br><span class="line">            times &#x3D; 1;</span><br><span class="line">        &#125;else if(array[i] &#x3D;&#x3D; res)</span><br><span class="line">            times++;</span><br><span class="line">        else</span><br><span class="line">            times--;</span><br><span class="line">    &#125;</span><br><span class="line">    times &#x3D; 0;</span><br><span class="line">    for(int num : array)</span><br><span class="line">        if(num &#x3D;&#x3D; res)</span><br><span class="line">            times++;</span><br><span class="line">    return (times &gt; len &#x2F; 2)? res : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="整数中1出现的次数"><a href="#整数中1出现的次数" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h3><blockquote>
<p>题目描述：输入一个整数n，求1<del>n中这n个整数的十进制表示中1出现的次数。例如：输入12，则1</del>12的整数中1出现的数字有1、10、11和12，1一共出现了5次。</p>
</blockquote>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>设N = abcde ,其中abcde分别为十进制中各位上的数字。 如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字、百位以下（低位）的数字、百位以上（高位）的数字。</p>
<ol>
<li>如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100<del>199，1100</del>1199,2100<del>2199，，…，11100</del>11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。</li>
<li>如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100<del>199，1100</del>1199,2100<del>2199，，….，11100</del>11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~12113,一共114个，等于低位数字（113）+1。</li>
<li>如果百位上数字大于1（2<del>9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100</del>199,1100<del>1199，2100</del>2199，…，11100<del>11199,12100</del>12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int NumberOf1Between1AndN_Solution(int n) &#123;</span><br><span class="line">    int count &#x3D; 0;&#x2F;&#x2F;1的个数</span><br><span class="line">    int i &#x3D; 1;&#x2F;&#x2F;当前位</span><br><span class="line">    int current &#x3D; 0,after &#x3D; 0,before &#x3D; 0;</span><br><span class="line">    while((n&#x2F;i)!&#x3D; 0)&#123;           </span><br><span class="line">        current &#x3D; (n&#x2F;i)%10; &#x2F;&#x2F;高位数字</span><br><span class="line">        before &#x3D; n&#x2F;(i*10); &#x2F;&#x2F;当前位数字</span><br><span class="line">        after &#x3D; n-(n&#x2F;i)*i; &#x2F;&#x2F;低位数字</span><br><span class="line">        &#x2F;&#x2F;如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数</span><br><span class="line">        if (current &#x3D;&#x3D; 0)</span><br><span class="line">            count +&#x3D; before*i;</span><br><span class="line">        &#x2F;&#x2F;如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1</span><br><span class="line">        else if(current &#x3D;&#x3D; 1)</span><br><span class="line">            count +&#x3D; before * i + after + 1;</span><br><span class="line">        &#x2F;&#x2F;如果大于1,出现1的次数由高位决定,&#x2F;&#x2F;（高位数字+1）* 当前位数</span><br><span class="line">        else&#123;</span><br><span class="line">            count +&#x3D; (before + 1) * i;</span><br><span class="line">        &#125;    </span><br><span class="line">        &#x2F;&#x2F;前移一位</span><br><span class="line">        i &#x3D; i*10;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><blockquote>
<p>题目描述：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题目拿到手会有一个直接思路，那就是直接获取所有可能的结果，然后排序获取其中最小的数就可以了，这种暴力解法肯定是零分解法，所以直接pass掉这种思路。<br>其实再仔细想一想，问题实际上并不复杂，要找到这个数组排序的最小值，我们只需要对这个数组进行遍历的时候，找到相邻值进行相加，然后以升序重新排列这个数组即可，最后再按照排序后的结果依次相加即可得到最终的结果。</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String PrintMinNumber(int [] numbers) &#123;</span><br><span class="line">    if(numbers &#x3D;&#x3D; null || numbers.length &lt; 1)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int number : numbers) &#123;</span><br><span class="line">        list.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            String str1 &#x3D; o1 + &quot;&quot; + o2;</span><br><span class="line">            String str2 &#x3D; o2 + &quot;&quot; + o1;</span><br><span class="line">            return str1.compareTo(str2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">    for(int i : list)&#123;</span><br><span class="line">        sb.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：时间效率和空间效率的平衡</title>
    <url>/2020/04/04/0ffer07/</url>
    <content><![CDATA[<h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><blockquote>
<p>题目描述：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>所谓一个数m是另一个数n的因子，是指n能被m整除，也就是n % m == 0。根据丑数的定义，丑数只能被2、3、5整除，也就是说，如果一个数能被2整除，就连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就连续除以5。如果最后得到的是1，那么这个数就是丑数，否则就不是。</p>
<a id="more"></a>
<p>那么实际上我们可以写出一个函数来判断一个数是不是丑数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean isUglyNumber(int number)&#123;</span><br><span class="line">    while(number % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    while(number % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">    while(number % 5 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return number &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后题目让我们输出从小到大的第N个丑数，这很简单，我们只要对从小到大每个数做一次判断，判断其是否是丑数，如果是，那么统计丑数的次数加1，这样到第N个数就是我们需要的结果了。<br>那么显然你能看出来，这种方法虽然可行，但是效率上来说是十分低下的，因为里面有太多的冗余，那么我们能不能想出更好的办法呢？<br>答案是显然的，由于丑数只包含质因子2、3、5，那么丑数跟丑数相乘的结果肯定是丑数，即一个丑数P = 2^x * 3 ^ y * 5 ^ z，我们可以从2、3、5出发，作为基准数。然后再乘以基准数，就得到4、6、10，6、9、15，10、15、25九个丑数，但是这种乘出来的结果有重复，并且结果是无序的，那么我们只需要处理这个问题就可以。<br>这个问题的处理需要思考一下，实际上1、2、3、4、5、6都是丑数，首先可以想到利用HashSet去重解决问题，但是结果是无序的，这就需要我们重新想办法。<br>其实每次我们只用比较3个数：用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的数。也就是比较(2x , 3y, 5z) ，x&gt;=y&gt;=z的，那么最终就可以依次按照顺序排列了。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="第一种解题思路：暴力解法"><a href="#第一种解题思路：暴力解法" class="headerlink" title="第一种解题思路：暴力解法"></a>第一种解题思路：暴力解法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;判断每个数是不是丑数,效率非常低</span><br><span class="line">public int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">    if(index &lt;&#x3D; 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(index &lt; 7) return index;</span><br><span class="line">    int number &#x3D; 0;</span><br><span class="line">    int uglyFound &#x3D; 0;</span><br><span class="line">    while(uglyFound &lt; index)&#123;</span><br><span class="line">        number++;</span><br><span class="line"></span><br><span class="line">        if(isUglyNumber(number))&#123;</span><br><span class="line">            uglyFound++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isUglyNumber(int number)&#123;</span><br><span class="line">    while(number % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    while(number % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">    while(number % 5 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        number &#x2F;&#x3D; 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return number &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二种解法：时间复杂度O-n"><a href="#第二种解法：时间复杂度O-n" class="headerlink" title="第二种解法：时间复杂度O(n)"></a>第二种解法：时间复杂度O(n)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int GetUglyNumber_Solution(int n) &#123;</span><br><span class="line">    if (n &lt;&#x3D; 0) return 0;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;第一个丑数是1</span><br><span class="line">    list.add(1);</span><br><span class="line">    &#x2F;&#x2F;以2 3 5 作为基准数</span><br><span class="line">    int i2 &#x3D; 0, i3 &#x3D; 0, i5 &#x3D; 0;</span><br><span class="line">    while (list.size() &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        int m2 &#x3D; list.get(i2) * 2;</span><br><span class="line">        int m3 &#x3D; list.get(i3) * 3;</span><br><span class="line">        int m5 &#x3D; list.get(i5) * 5;</span><br><span class="line">        int min &#x3D; Math.min(m2, Math.min(m3, m5));</span><br><span class="line">        list.add(min);</span><br><span class="line">        if (min &#x3D;&#x3D; m2) i2++;</span><br><span class="line">        if (min &#x3D;&#x3D; m3) i3++;</span><br><span class="line">        if (min &#x3D;&#x3D; m5) i5++;</span><br><span class="line">    &#125;</span><br><span class="line">    return list.get(list.size() - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h3><blockquote>
<p>题目描述：在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题目比较简单，可以使用Map存储结构解决问题，键为字符，值为字符出现的次数，最终输出第一个值为1的键就行，那么由于有顺序，所以需要使用LinkedHashMap结构进行存储。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line">    if(str &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] cs &#x3D; str.toCharArray();</span><br><span class="line">    Map&lt;Character,Integer&gt; map &#x3D; new LinkedHashMap&lt;&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; cs.length; i++)&#123;</span><br><span class="line">        if(!map.containsKey(cs[i]))&#123;</span><br><span class="line">            map.put(cs[i],1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int val &#x3D; map.get(cs[i]);</span><br><span class="line">            map.put(cs[i],val+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(Map.Entry&lt;Character,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">        if(entry.getValue() &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            return str.indexOf(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><blockquote>
<p>题目描述：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题目有点难度，最终实现是归并排序的改进，把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，合并数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时；则前面数组array[i]~array[mid]都是大于array[j]的，count += mid+1 - i，参考剑指offer书上解析。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int InversePairs(int [] array) &#123;</span><br><span class="line">    if(array&#x3D;&#x3D;null||array.length&#x3D;&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] copy &#x3D; new int[array.length];</span><br><span class="line">    for(int i&#x3D;0;i&lt;array.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[i] &#x3D; array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int count &#x3D; InversePairsCore(array,copy,0,array.length-1);&#x2F;&#x2F;数值过大求余</span><br><span class="line">    return count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int InversePairsCore(int[] array,int[] copy,int low,int high) &#123;</span><br><span class="line">    if(low&#x3D;&#x3D;high)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid &#x3D; (low+high)&gt;&gt;1;</span><br><span class="line">    int leftCount &#x3D; InversePairsCore(array,copy,low,mid)%1000000007;</span><br><span class="line">    int rightCount &#x3D; InversePairsCore(array,copy,mid+1,high)%1000000007;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    int i&#x3D;mid;</span><br><span class="line">    int j&#x3D;high;</span><br><span class="line">    int locCopy &#x3D; high;</span><br><span class="line">    while(i&gt;&#x3D;low&amp;&amp;j&gt;mid)</span><br><span class="line">    &#123;</span><br><span class="line">        if(array[i]&gt;array[j])</span><br><span class="line">        &#123;</span><br><span class="line">            count +&#x3D; j-mid;</span><br><span class="line">            copy[locCopy--] &#x3D; array[i--];</span><br><span class="line">            if(count&gt;&#x3D;1000000007)&#x2F;&#x2F;数值过大求余</span><br><span class="line">            &#123;</span><br><span class="line">                count%&#x3D;1000000007;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            copy[locCopy--] &#x3D; array[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(;i&gt;&#x3D;low;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[locCopy--]&#x3D;array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(;j&gt;mid;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[locCopy--]&#x3D;array[j];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int s&#x3D;low;s&lt;&#x3D;high;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        array[s] &#x3D; copy[s];</span><br><span class="line">    &#125;</span><br><span class="line">    return (leftCount+rightCount+count)%1000000007;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h3><blockquote>
<p>题目描述：输入两个单向链表，找出它们的第一个公共结点。</p>
</blockquote>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先我们需要知道具有公共节点的链表有什么特性。<br><img src="img/03offer/offer-list.png" alt="offer-list"><br>可以看到，这两个单向链表从公共节点开始，后面的节点都是相同的。<br>很多人第一反应是暴力解法，就是第一个链表上顺序遍历每个节点，每遍历一个节点，就在第二个链表上顺序遍历每个节点。这样的找法的时间复杂度是O(mn)，其中链表的长度分别为m、n。<br>那么显然需要换一种思路了，这种两个链表的题目，其实很多时候都用的双指针解法思路，即一个指针先走多少步，达到某个条件的时候另外一个指针就开始遍历，这样只用遍历一次链表就可以完成，这是常用的解决办法，当然也适用于本题。我们可以先遍历获取两个链表的长度，然后再根据长的链表进行遍历，先让第一个指针走长度差步，然后第二个节点开始走，当两个节点走到第一个相同节点就是第一个公共节点。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">    ListNode current1 &#x3D; pHead1;&#x2F;&#x2F; 链表1</span><br><span class="line">    ListNode current2 &#x3D; pHead2;&#x2F;&#x2F; 链表2</span><br><span class="line">    if (pHead1 &#x3D;&#x3D; null || pHead2 &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    int length1 &#x3D; getLength(current1);</span><br><span class="line">    int length2 &#x3D; getLength(current2);</span><br><span class="line">    &#x2F;&#x2F; 两链表的长度差</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果链表1的长度大于链表2的长度</span><br><span class="line">    if (length1 &gt;&#x3D; length2) &#123;</span><br><span class="line">        int len &#x3D; length1 - length2;</span><br><span class="line">        &#x2F;&#x2F; 先遍历链表1，遍历的长度就是两链表的长度差</span><br><span class="line">        while (len &gt; 0) &#123;</span><br><span class="line">            current1 &#x3D; current1.next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果链表2的长度大于链表1的长度</span><br><span class="line">    else if (length1 &lt; length2) &#123;</span><br><span class="line">        int len &#x3D; length2 - length1;</span><br><span class="line">        &#x2F;&#x2F; 先遍历链表1，遍历的长度就是两链表的长度差</span><br><span class="line">        while (len &gt; 0) &#123;</span><br><span class="line">            current2 &#x3D; current2.next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;开始齐头并进，直到找到第一个公共结点</span><br><span class="line">    while (current1 !&#x3D; current2) &#123;</span><br><span class="line">        current1 &#x3D; current1.next;</span><br><span class="line">        current2 &#x3D; current2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return current1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 求指定链表的长度</span><br><span class="line">public static int getLength(ListNode pHead) &#123;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    ListNode current &#x3D; pHead;</span><br><span class="line">    while (current !&#x3D; null) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        current &#x3D; current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二：同样思路，使用HashMap实现"><a href="#解法二：同样思路，使用HashMap实现" class="headerlink" title="解法二：同样思路，使用HashMap实现"></a>解法二：同样思路，使用HashMap实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">    ListNode current1 &#x3D; pHead1;</span><br><span class="line">    ListNode current2 &#x3D; pHead2;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;ListNode, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    while (current1 !&#x3D; null) &#123;</span><br><span class="line">        hashMap.put(current1, null);</span><br><span class="line">        current1 &#x3D; current1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (current2 !&#x3D; null) &#123;</span><br><span class="line">        if (hashMap.containsKey(current2))</span><br><span class="line">            return current2;</span><br><span class="line">        current2 &#x3D; current2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>时间效率</tag>
        <tag>空间效率</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法比较与梳理</title>
    <url>/2020/03/15/sort01/</url>
    <content><![CDATA[<h2 id="各类排序算法"><a href="#各类排序算法" class="headerlink" title="各类排序算法"></a>各类排序算法</h2><p><img src="/img/01sort/sort.png" alt="排序算法复杂度"></p>
<a id="more"></a>

<h2 id="排序算法一般分类"><a href="#排序算法一般分类" class="headerlink" title="排序算法一般分类"></a>排序算法一般分类</h2><p><img src="/img/01sort/sort1.png" alt="排序算法分类"></p>
<p>相关概念：</p>
<ul>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li>时间复杂度：对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。</li>
<li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>比较两个相邻的元素，将值大的元素交换至右端。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>依次比较两个相邻的数，将小数放到前面，大数放到后面</p>
<p>第一趟：首先比较第 1 个数和第 2 个数，将小数放前，大数放后。然后比较第 2 个数和第 3 个数，将小数放前，大数放后，如此一直继续下去，直到比较最后两个数，将小数放前，大数放后。然后重复第一趟步骤，直到所有排序完成。</p>
<p>第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较。</p>
<p>第二趟完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较。</p>
<p>依此类推……<br><img src="/img/01sort/bubblesort.gif" alt="冒泡排序"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        bubbleSort(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; array.length-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"排序后的数组为:"</span> + Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>排序后的数组为: [1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h3><p><em>冒泡排序的优点</em>：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。</p>
<p>用时间复杂度来说： 如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：<code>Cmin=n-1</code>;<code>Mmin=0</code>;所以，冒泡排序最好的时间复杂度为<code>O(n)</code>。如果很不幸我们的数据是反序的，则需要进行 n - 1 趟排序。每趟排序要进行 n - i 次比较(1 ≤ i ≤ n - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值。</p>
<ul>
<li>冒泡排序的最坏时间复杂度为：O(n^2)</li>
<li>冒泡排序的最好时间复杂夫为：O(n)</li>
<li>冒泡排序的平均时间复杂度：O(n)</li>
<li>冒泡排序是一种稳定的排序算法</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>从一个数组中随机选出一个数N，通过一趟排序将数组分割成三个部分，1、小于N的区域 2、等于N的区域 3、大于N的区域，然后再按照此方法对小于区的和大于区分别递归进行，从而达到整个数据变成有序数组。<br><img src="/img/01sort/quickSort.gif" alt="快速排序"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如下图：<br>假设最开始的基准数据为数组的第一个元素23，则首先用一个临时变量去存储基准数据，即 tmp=23，然后分别从数组的两端扫描数组，设两个指示标志：low 指向起始位置，high 指向末尾。<br><img src="/img/01sort/quicksort1.png" alt="快速排序"><br>首先从后半部分开始，如果扫描到的值大于基准数据就让 high - 1，如果发现有元素比该基准数据的值小，比如上面的 18 &lt;= tmp ，就让high位置的值赋值给low位置，结果如下：<br><img src="/img/01sort/quicksort2.png" alt="快速排序"><br>然后开始从前往后扫描，如果扫描到的值小于基准数据就让 low+1，如果发现有元素大于基准数据的值，比如上图 46 &gt;= tmp，就再将 low 位置的值赋值给 high 位置的值，指针移动并且数据交换后的结果如下：<br><img src="/img/01sort/quicksort3.png" alt="快速排序"><br>然后再开始从前往后遍历，直到 low=high 结束循环，此时 low 或者 high 的下标就是基准数据23在该数组中的正确索引位置，如下图所示：<br><img src="/img/01sort/quicksort5.png" alt="快速排序"><br>这样一遍遍的走下来，可以很清楚的知道，快排的本质就是把比基准数据小的都放到基准数的左边，比基准数大的数都放到基准数的右边，这样就找到了该数据在数组中的正确位置。<br>然后采用递归的方式分别对前半部分和后半部分排序，最终结果就是自然有序的了。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        quickSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="comment">//找到基准数据位置</span></span><br><span class="line">            <span class="keyword">int</span> index = getIndex(array,low,high);</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            quickSort(array,<span class="number">0</span>,index-<span class="number">1</span>);</span><br><span class="line">            quickSort(array,index+<span class="number">1</span>,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取基准数据位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="comment">//一般取第一个数作为基准数据</span></span><br><span class="line">        <span class="keyword">int</span> tmp = array[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; array[high] &gt;= tmp)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则high处元素小于基准数据，将high处赋值给low处数据</span></span><br><span class="line">            array[low] = array[high];</span><br><span class="line">            <span class="comment">//赋值完后，需要从前面开始扫描数组</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; array[low] &lt;= tmp)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">             array[high] = array[low];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整个循环结束时high=low,但是该位置处不等于基准元素</span></span><br><span class="line">        array[low] = tmp;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-1"><a href="#特点分析-1" class="headerlink" title="特点分析"></a>特点分析</h3><p>最好情况下快排每次能恰好均分序列，那么时间复杂度就是 O(nlogn)，最坏情况下，快排每次划分都只能将序列分为一个元素和其它元素两部分，这时候的快排退化成冒泡排序，时间复杂度为 O(n^2)。</p>
<ul>
<li>平均时间复杂度是 O(nlogn)</li>
<li>最坏时间复杂度是 O(n^2)</li>
<li>对于大的，乱序排列的数组来说快排一般是已知的最快的已知排序</li>
<li>快排是一种不稳定排序</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为 O(n^2)。是稳定的排序方法。<br><img src="/img/01sort/insertionSort.gif" alt="插入排序"></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>将一个数据插入到<em>已经排好序的有序数据</em>中</p>
<ul>
<li>将要排序的是一个乱的数组 int[] arrays = {3, 2, 1, 3, 3}</li>
<li>在未知道数组元素的情况下，我们只能把数组的第一个元素作为已经排好序的有序数据，也就是说，把{3}看成是已经排好序的有序数据</li>
</ul>
<p>第一趟排序：<br>用数组的第二个数与第一个数(<em>看成是已有序的数据</em>)比较</p>
<ul>
<li>如果比第一个数大，那就不管他</li>
<li>如果比第一个数小，将第一个数往后退一步，将第二个数插入第一个数去</li>
</ul>
<p>第二趟排序：<br>用数组的第三个数与已是有序的数据 {2,3} (刚才在第一趟排的)比较</p>
<ul>
<li>如果比 2 大，那就不管它</li>
<li>如果比 2 小，那就将 2 退一个位置，让第三个数和1比较</li>
</ul>
<p>在第二步中：</p>
<ul>
<li><p>如果第三个数比 1 大，那么将第三个数插入到 2 的位置上</p>
</li>
<li><p>如果第三个数比 1 小，那么将 1 后退一步，将第三个数插入到 1 的位置上</p>
</li>
</ul>
<p>…<br>后面依此类推</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        insertSort(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j-<span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                    arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//插入新的元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-2"><a href="#特点分析-2" class="headerlink" title="特点分析"></a>特点分析</h3><ul>
<li>最坏时间复杂度为O(n^2)</li>
<li>最好时间复杂度为O(n)</li>
<li>平均时间复杂度为O(n^2)</li>
<li>插入排序是一种稳定的排序算法。</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。<br><img src="/img/01sort/selectionSort.gif" alt="选择排序"></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>举例：数组 int[] arr = {5,2,8,4,9,1}<br><em>第一趟排序<em>： 原始数据：<code>5 2 8 4 9 1</code><br>最小数据1，把1放在首位，也就是1和5互换位置，<br>排序结果：<code>1 2 8 4 9 5</code><br>*第二趟排序</em>：<br>第1以外的数据<code>{2 8 4 9 5}</code>进行比较，2最小，<br>排序结果：<code>1 2 8 4 9 5</code><br><em>第三趟排序</em>：<br>除1、2以外的数据<code>{8 4 9 5}</code>进行比较，4最小，8和4交换<br>排序结果：<code>1 2 4 8 9 5</code><br>*第四趟排序</em> :<br>除第<code>1、2、4</code>以外的其他数据<code>{8 9 5}</code>进行比较，5最小，8和5交换<br>排序结果：<code>1 2 4 5 9 8</code><br><em>第五趟排序</em>：<br>除第<code>1、2、4、5</code>以外的其他数据<code>{9 8}</code>进行比较，8最小，8和9交换<br>排序结果：<code>1 2 4 5 8 9</code></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        selectionSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length -<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &lt; array[k])&#123;</span><br><span class="line">                    k = j; <span class="comment">//记下目前找到的最小值所在的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(i != k)&#123;  <span class="comment">//交换a[i]和a[k]</span></span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                array[i] = array[k];</span><br><span class="line">                array[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-3"><a href="#特点分析-3" class="headerlink" title="特点分析"></a>特点分析</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是 O(n^2) 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<ul>
<li><p>最坏时间复杂度为O(n^2)</p>
</li>
<li><p>平均时间复杂度为O(n^2)</p>
</li>
<li><p>选择排序是一种不稳定的排序</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>堆排序是对简单选择排序的改进，简单选择排序是从 n 个记录中找出一个最小的记录，需要比较 n - 1 次。但是这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。<br>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。<br><img src="/img/01sort/heap-sort.png" alt="堆排序"></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的 n - 1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次最大值。如此反复执行，就能得到一个有序序列了。<br><img src="/img/01sort/849589-20171015231308699-356134237.gif" alt="堆排序"><br>实现思路：</p>
</li>
<li><p>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区；</p>
</li>
<li><p>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1] &lt;= R[n]；</p>
</li>
<li><p>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区 (Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n - 1，则整个排序过程完成。</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;50, 10, 90, 30, 70, 40, 80, 60, 20&#125;;</span><br><span class="line">        System.out.println(&quot;排序之前：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 堆排序</span><br><span class="line">        heapSort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;排序之后：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 堆排序</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void heapSort(int[] arr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将待排序的序列构建成一个大顶堆</span><br><span class="line">        for (int i &#x3D; arr.length &#x2F; 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            heapAdjust(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 逐步将每个最大值的根节点与末尾元素交换，并且再调整二叉树，使其成为大顶堆</span><br><span class="line">        for (int i &#x3D; arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            swap(arr, 0, i); &#x2F;&#x2F; 将堆顶记录和当前未经排序子序列的最后一个记录交换</span><br><span class="line">            heapAdjust(arr, 0, i); &#x2F;&#x2F; 交换之后，需要重新检查堆是否符合大顶堆，不符合则要调整</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构建堆的过程</span><br><span class="line">     *</span><br><span class="line">     * @param arr 需要排序的数组</span><br><span class="line">     * @param i   需要构建堆的根节点的序号</span><br><span class="line">     * @param n   数组的长度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void heapAdjust(int[] arr, int i, int n) &#123;</span><br><span class="line">        int child;</span><br><span class="line">        int father;</span><br><span class="line">        for (father &#x3D; arr[i]; leftChild(i) &lt; n; i &#x3D; child) &#123;</span><br><span class="line">            child &#x3D; leftChild(i);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果左子树小于右子树，则需要比较右子树和父节点</span><br><span class="line">            if (child !&#x3D; n - 1 &amp;&amp; arr[child] &lt; arr[child + 1]) &#123;</span><br><span class="line">                child++; &#x2F;&#x2F; 序号增1，指向右子树</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果父节点小于孩子结点，则需要交换</span><br><span class="line">            if (father &lt; arr[child]) &#123;</span><br><span class="line">                arr[i] &#x3D; arr[child];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break; &#x2F;&#x2F; 大顶堆结构未被破坏，不需要调整</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] &#x3D; father;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取到左孩子结点</span><br><span class="line">    private static int leftChild(int i) &#123;</span><br><span class="line">        return 2 * i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 交换元素位置</span><br><span class="line">    private static void swap(int[] arr, int index1, int index2) &#123;</span><br><span class="line">        int tmp &#x3D; arr[index1];</span><br><span class="line">        arr[index1] &#x3D; arr[index2];</span><br><span class="line">        arr[index2] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">排序之前：</span><br><span class="line">50 10 90 30 70 40 80 60 20 </span><br><span class="line">排序之后：</span><br><span class="line">10 20 30 40 50 60 70 80 90</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-4"><a href="#特点分析-4" class="headerlink" title="特点分析"></a>特点分析</h3><p>堆排序时间复杂度：O(nlogn)<br>堆排序对原始记录的排序状态并不敏感，其在性能上要远远好过于冒泡、简单选择、直接插入排序。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>归并排序（merge sort）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。<br><img src="/img/01sort/guibingSort.gif" alt="归并排序"></p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>比如我们对<code>[8,4,5,7,1,3,6,2]</code>这个数组进行归并排序，我们首先利用分治思想的“分”将数组拆分。<br><img src="/img/01sort/mergesort0.png" alt="归并排序"><br>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为<code>log2n</code>。<br>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将<code>[4,5,7,8]</code>和<code>[1,2,3,6]</code>两个已经有序的子序列，合并为最终序列<code>[1,2,3,4,5,6,7,8]</code>，来看下实现步骤。<br><img src="/img/01sort/mergesort2.png" alt="归并排序"></p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        int[] array &#x3D; &#123;2,4,1,5,67,2,45,78,3,9&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sort(int []arr)&#123;</span><br><span class="line">        int []temp &#x3D; new int[arr.length];&#x2F;&#x2F;在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span><br><span class="line">        sort(arr,0,arr.length-1,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void sort(int[] arr,int left,int right,int []temp)&#123;</span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            int mid &#x3D; (left+right)&#x2F;2;</span><br><span class="line">            sort(arr,left,mid,temp);&#x2F;&#x2F;左边归并排序，使得左子序列有序</span><br><span class="line">            sort(arr,mid+1,right,temp);&#x2F;&#x2F;右边归并排序，使得右子序列有序</span><br><span class="line">            merge(arr,left,mid,right,temp);&#x2F;&#x2F;将两个有序子数组合并操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123;</span><br><span class="line">        int i &#x3D; left;&#x2F;&#x2F;左序列指针</span><br><span class="line">        int j &#x3D; mid+1;&#x2F;&#x2F;右序列指针</span><br><span class="line">        int t &#x3D; 0;&#x2F;&#x2F;临时数组指针</span><br><span class="line">        while (i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;</span><br><span class="line">            if(arr[i]&lt;&#x3D;arr[j])&#123;</span><br><span class="line">                temp[t++] &#x3D; arr[i++];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                temp[t++] &#x3D; arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&lt;&#x3D;mid)&#123;&#x2F;&#x2F;将左边剩余元素填充进temp中</span><br><span class="line">            temp[t++] &#x3D; arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;&#x3D;right)&#123;&#x2F;&#x2F;将右序列剩余元素填充进temp中</span><br><span class="line">            temp[t++] &#x3D; arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;将temp中的元素全部拷贝到原数组中</span><br><span class="line">        while(left &lt;&#x3D; right)&#123;</span><br><span class="line">            arr[left++] &#x3D; temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>[1, 2, 2, 3, 4, 5, 9, 45, 67, 78]</code></p>
<h3 id="特点分析-5"><a href="#特点分析-5" class="headerlink" title="特点分析"></a>特点分析</h3></li>
<li><p>归并排序是一种稳定排序</p>
</li>
<li><p>Java中的<code>Arrays.sort()</code>采用了一种名为TimSort的排序算法，就是归并排序的优化版本</p>
</li>
<li><p>每次合并操作的时间复杂度为O(n)，完全二叉树的深度为<code>|log2n|</code>，总的平均时间复杂度为O(nlogn)<br>归并排序的最好、最坏、平均时间复杂度都为O(nlongn)</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为 O(n+k)，其中 k 是整数的范围。基于比较的排序算法时间复杂度最小是 O(nlogn) 的。注意：计数排序对于实数的排序是不可行的（下面会解释）。该算法于1954年由 Harold H. Seward 提出。 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br><img src="/img/01sort/counting-sort.gif" alt="归并排序"></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>实现思路：</p>
</li>
<li><p>找出待排序的数组中最大和最小的元素；</p>
</li>
<li><p>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</p>
</li>
<li><p>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</p>
</li>
<li><p>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package ttt;</span><br><span class="line"> </span><br><span class="line">public class CountingSort &#123;</span><br><span class="line">    public static int[] countingSort(int[] theArray) &#123;</span><br><span class="line">    	int[] lastArray &#x3D; new int[theArray.length];</span><br><span class="line">        for(int i &#x3D; 0; i &lt; theArray.length; i++) &#123;</span><br><span class="line">        	int count &#x3D; 0;</span><br><span class="line">        	for(int j &#x3D; 0; j &lt; theArray.length; j++) &#123;</span><br><span class="line">        		if(theArray[i] &gt; theArray[j]) &#123;</span><br><span class="line">        			count++;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	lastArray[count] &#x3D; theArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    	return lastArray;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	int []theArray &#x3D; &#123;6, 4, 5, 1, 8, 7, 2, 3&#125;;</span><br><span class="line">        System.out.print(&quot;之前的排序：&quot;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; theArray.length; i++) &#123;</span><br><span class="line">            System.out.print(theArray[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int []resultArray &#x3D; countingSort(theArray);</span><br><span class="line">        </span><br><span class="line">        System.out.print(&quot;计数排序：&quot;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; resultArray.length; i++) &#123;</span><br><span class="line">            System.out.print(resultArray[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><code>之前的排序：6 4 5 1 8 7 2 3 计数排序：1 2 3 4 5 6 7 8</code></p>
</li>
</ul>
<h3 id="特点分析-6"><a href="#特点分析-6" class="headerlink" title="特点分析"></a>特点分析</h3><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>实现思路：</p>
<ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void bucketSort(int[] arr)&#123;</span><br><span class="line">    </span><br><span class="line">    int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max &#x3D; Math.max(max, arr[i]);</span><br><span class="line">        min &#x3D; Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;桶数</span><br><span class="line">    int bucketNum &#x3D; (max - min) &#x2F; arr.length + 1;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr &#x3D; new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将每个元素放入桶</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        int num &#x3D; (arr[i] - min) &#x2F; (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;对每个桶进行排序</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(bucketArr.toString());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-7"><a href="#特点分析-7" class="headerlink" title="特点分析"></a>特点分析</h3>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3>数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。<br><img src="/img/01sort/radix-sort.gif" alt="基数排序"><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3>实现思路：</li>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RadixSort &#123;</span><br><span class="line">    private static void radixSort(int[] array,int d)&#123;</span><br><span class="line">        int n&#x3D;1;&#x2F;&#x2F;代表位数对应的数：1,10,100...</span><br><span class="line">        int k&#x3D;0;&#x2F;&#x2F;保存每一位排序后的结果用于下一位的排序输入</span><br><span class="line">        int length&#x3D;array.length;</span><br><span class="line">        int[][] bucket&#x3D;new int[10][length];&#x2F;&#x2F;排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span><br><span class="line">        int[] order&#x3D;new int[length];&#x2F;&#x2F;用于保存每个桶里有多少个数字</span><br><span class="line">        while(n&lt;d)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int num:array) &#x2F;&#x2F;将数组array里的每个数字放在相应的桶里</span><br><span class="line">            &#123;</span><br><span class="line">                int digit&#x3D;(num&#x2F;n)%10;</span><br><span class="line">                bucket[digit][order[digit]]&#x3D;num;</span><br><span class="line">                order[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i&#x3D;0;i&lt;length;i++)&#x2F;&#x2F;将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span><br><span class="line">            &#123;</span><br><span class="line">                if(order[i]!&#x3D;0)&#x2F;&#x2F;这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span><br><span class="line">                &#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;order[i];j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        array[k]&#x3D;bucket[i][j];</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                order[i]&#x3D;0;&#x2F;&#x2F;将桶里计数器置0，用于下一次位排序</span><br><span class="line">            &#125;</span><br><span class="line">            n*&#x3D;10;</span><br><span class="line">            k&#x3D;0;&#x2F;&#x2F;将k置0，用于下一轮保存位排序结果</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] A&#x3D;new int[]&#123;73,22, 93, 43, 55, 14, 28, 65, 39, 81&#125;;</span><br><span class="line">        radixSort(A, 100);</span><br><span class="line">        for(int num:A)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-8"><a href="#特点分析-8" class="headerlink" title="特点分析"></a>特点分析</h3>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n) 的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n) 的时间复杂度。假如待排数据可以分为 d个关键字，则基数排序的时间复杂度将是 <code>O(d*2n)</code> ，当然 d 要远远小于 n，因此基本上还是线性级别的。<br>基数排序的空间复杂度为<code>O(n+k)</code>，其中 k 为桶的数量。一般来说 n&gt;&gt;k，因此额外空间需要大概 n 个左右。</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><img src="/img/01sort/shell-sort.gif" alt="希尔排序"></p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void ShellSort(int num[]) &#123;</span><br><span class="line">    int temp;</span><br><span class="line">    &#x2F;&#x2F;默认步长为数组长度除以2</span><br><span class="line">    int step &#x3D; num.length;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        step &#x3D; step &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F;确定分组数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; step; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;对分组数据进行直接插入排序</span><br><span class="line">            for ( int j &#x3D; i + step; j &lt; num.length; j &#x3D; j + step) &#123;</span><br><span class="line">                temp&#x3D;num[j];</span><br><span class="line">                int k;</span><br><span class="line">                for( k&#x3D;j-step;k&gt;&#x3D;0;k&#x3D;k-step)&#123;</span><br><span class="line">                    if(num[k]&gt;temp)&#123;</span><br><span class="line">                        num[k+step]&#x3D;num[k];</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num[k+step]&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (step &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点分析-9"><a href="#特点分析-9" class="headerlink" title="特点分析"></a>特点分析</h3>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer题解笔记：链表</title>
    <url>/2020/03/20/offer01/</url>
    <content><![CDATA[<h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><blockquote>
<p>题目描述：输入一个链表，输出该链表中倒数第k个节点。</p>
</blockquote>
<p>虽然最直观的思路往往不是最优解，但是我们在做算法题的时候还是需要从最直观的解法出发，不断优化现有思路或者参考他人解法来获取新的idea来解决问题，这样才能达到思维层面上的进步。<br>就这题而言，最直观的解法显然是先遍历链表，找到链表的长度length,然后再找到第length-k+1位置处的节点，就是需要的倒数第k个节点。那么可以很快的写出下面代码：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 解题思路一：找到链表的长度n，再从头开始找n-k+1的链表的位置就是第k个节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;边界条件</span><br><span class="line">    if(head &#x3D;&#x3D; null || k &lt; 1)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int index &#x3D; 1;</span><br><span class="line">    ListNode pNext &#x3D; head;</span><br><span class="line">    while(pNext !&#x3D; null)&#123;</span><br><span class="line">        pNext &#x3D; pNext.next;</span><br><span class="line">        index ++;</span><br><span class="line">    &#125;</span><br><span class="line">    int len &#x3D; index;</span><br><span class="line">    &#x2F;&#x2F;如果倒数第k个节点不存在的边界条件</span><br><span class="line">    if(k &gt; len)&#123;</span><br><span class="line">       return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;找到第n-k+1个节点的值返回</span><br><span class="line">    int count &#x3D; 1;</span><br><span class="line">    ListNode pn &#x3D; head;</span><br><span class="line">     while(count &lt;&#x3D; len-k+1)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        pn &#x3D; pn.next;</span><br><span class="line">        if(count &#x3D;&#x3D; len-k+1)&#123;</span><br><span class="line">           return pn;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做完之后，结果当然是可以通过的，但是需要优化的地方也很明显，那就是上述解法遍历了两次链表，这显然是造成了冗余，那么优化的方向就是只遍历一次就可以获取我们需要的结果，根据这个思路，我们实际上可以想到双指针思路，这个在链表题目中经常遇到的思路显然也适合这里。</p>
<p>于是我们可以使用双指针，第一个指针先遍历链表到第k-1个节点位置，然后当第一个指针到第k个节点位置时，第二个指针开始从第一个节点处遍历，这样当第一个指针遍历到最后一个节点时，第二个指针的位置刚好是第length-k+1的位置，也就是倒数第k个节点的位置。这样一次遍历就可以完成我们需要的结果。</p>
<p>然后就不假思索的写出以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode FindKthToTail1(ListNode head,int k)&#123;</span><br><span class="line">  if(head &#x3D;&#x3D; null || k &lt; 1)&#123;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode pFast &#x3D; head;</span><br><span class="line">  ListNode pLow &#x3D; head;</span><br><span class="line">  int index &#x3D; 1;</span><br><span class="line">  while(pFast.next !&#x3D; null)&#123;</span><br><span class="line">     pFast &#x3D; pFast.next;</span><br><span class="line">     if(index &gt;&#x3D; k)&#123;</span><br><span class="line">         pLow &#x3D; pLow.next;</span><br><span class="line">      &#125;</span><br><span class="line">     index++;</span><br><span class="line">   &#125;</span><br><span class="line">    return pLow;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>然后就发现只能通过测试用例的50%，为什么呢，呵呵……其实稍微注意一点应该能看到，在最开始的思路中我们是判断过边界条件k &lt; length的，而下面这种做法显然是没有判断这个边界条件的。。。这就导致如果k是大于链表的长度的，那么就会出现NullPointerException，然而上面的方法是不会抛出空指针异常的，但是跟预期的null结果也是不一样的。这就需要我们处理一下这个问题。<br>那么怎么处理呢？反正不能再遍历链表了，不然跟第一种方法相比就没啥区别，于是我们可以想到一种巧妙的解法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public ListNode FindKthToTail1(ListNode head,int k) &#123;</span><br><span class="line">   if(head &#x3D;&#x3D; null || k &lt; 1)&#123;</span><br><span class="line">        return null;</span><br><span class="line">   &#125;</span><br><span class="line">   ListNode p1 &#x3D; head;</span><br><span class="line">   &#x2F;&#x2F;两个指针移动的代码不放在一起，先让第一个指针走k步</span><br><span class="line">   while(p1 !&#x3D; null &amp;&amp; k-- &gt; 0)&#123;</span><br><span class="line">        p1 &#x3D; p1.next;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;然后在这里就可以加上判空条件了</span><br><span class="line">   &#x2F;&#x2F;如果这时候k不等于0，那么只能说明k有问题了，直接返回null</span><br><span class="line">    if(k &gt; 0) return null;</span><br><span class="line">    ListNode p2 &#x3D; head;</span><br><span class="line">    while(p1 !&#x3D; null)&#123;</span><br><span class="line">        p1 &#x3D; p1.next;</span><br><span class="line">        p2 &#x3D; p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">      return p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h3><blockquote>
<p>题目描述：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
</blockquote>
<p>这个题没什么直观性思路，主要是看知不知道方法，我们需要获取以下几个思路并证明：</p>
<ol>
<li>设置快慢指针，假如有环，他们最后一定相遇。</li>
<li>两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇于环入口。<br>先证明一下：设置快慢指针fast和low，fast每次走两步，low每次走一步。假如有环，两者一定会相遇（因为low一旦进环，可看作fast在后面追赶low的过程，每次两者都接近一步，最后一定能追上）。<br>设：<br>链表头到环入口长度为–a<br>环入口到相遇点长度为–b<br>相遇点到环入口长度为–c<br>则：相遇时<br><code>快指针路程=a+(b+c)k+b</code>，k&gt;=1 其中b+c为环的长度，k为绕环的圈数（k&gt;=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。<br><code>慢指针路程=a+b</code><br>快指针走的路程是慢指针的两倍，所以：<br><code>（a+b）\*2=a+(b+c)k+b</code><br>化简可得：<br><code>a=(k-1)(b+c)+c</code> 这个式子的意思是： <em>链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度</em>。其中<code>k&gt;=1</code>,所以<code>k-1&gt;=0</code>圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode EntryNodeOfLoop(ListNode pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead &#x3D;&#x3D; null || pHead.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow &#x3D; pHead;</span><br><span class="line">        ListNode fast &#x3D; pHead;</span><br><span class="line">        while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next.next;</span><br><span class="line">            &#x2F;&#x2F;到相遇点</span><br><span class="line">            if(slow &#x3D;&#x3D; fast)&#123;</span><br><span class="line">                fast &#x3D; pHead;</span><br><span class="line">                while(slow !&#x3D; fast)&#123;</span><br><span class="line">                    slow &#x3D; slow.next;</span><br><span class="line">                    fast &#x3D; fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if(slow &#x3D;&#x3D; fast)&#123;</span><br><span class="line">                    return slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><blockquote>
<p>题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<p>这个题目的话思路就比较简单，借助一个栈来解决问题的话就只需要遍历一次链表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if(listNode &#x3D;&#x3D; null)&#123;</span><br><span class="line">         return list;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    while(listNode !&#x3D; null)&#123;</span><br><span class="line">       stack.push(listNode.val);</span><br><span class="line">       listNode &#x3D; listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">       list.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中的重复节点"><a href="#删除链表中的重复节点" class="headerlink" title="删除链表中的重复节点"></a>删除链表中的重复节点</h3><blockquote>
<p>删除链表中的重复节点</p>
</blockquote>
<p>这个题的话，我们需要处理两个问题：</p>
<ol>
<li>判断多节点重复问题</li>
<li>将重复节点的前一个不重复节点的next指向下一个不重复的节点<br>如果上面两个问题能解决的话，那么这个问题就迎刃而解了。<br>为了解决第一个问题，比较好的思路应该是递归查找，即如果有两个节点重复了，那么我们在这两个节点重复的基础上继续往下查找看是否重复，这样找到所有重复的节点后，我们就可以解决第二个问题了，那么整个问题就可以解决了。<br>基于上述思路，我们可以写出如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode deleteDuplication(ListNode pHead)&#123;</span><br><span class="line">   &#x2F;&#x2F;边界条件</span><br><span class="line">   if(pHead &#x3D;&#x3D; null || pHead.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">       return pHead;</span><br><span class="line">   &#125;</span><br><span class="line">   ListNode next &#x3D; pHead.next;</span><br><span class="line">   if(pHead.val &#x3D;&#x3D; next.val)&#123;</span><br><span class="line">       &#x2F;&#x2F;保证重复的节点的前一个节点与后面比重复节点的值要大的节点相连</span><br><span class="line">       &#x2F;&#x2F;判断多节点重复</span><br><span class="line">       while(next !&#x3D; null &amp;&amp; pHead.val &#x3D;&#x3D; next.val)&#123;</span><br><span class="line">           &#x2F;&#x2F;跳过值与当前节点相同的全部节点，找到第一个值不同的节点</span><br><span class="line">           next &#x3D; next.next;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;从第一个与当前不同的节点开始递归</span><br><span class="line">       return deleteDuplication(next);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;当前节点不是重复节点</span><br><span class="line">        pHead.next &#x3D; deleteDuplication(pHead.next); &#x2F;&#x2F;保留当前节点，从下一个节点开始递归</span><br><span class="line">        return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
