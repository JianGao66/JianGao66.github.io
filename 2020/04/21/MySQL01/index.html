<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiangao66.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="索引概述   MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。    索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL  必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL  能够快速到达一个位置去搜索数据文件，">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL中的索引">
<meta property="og:url" content="https://jiangao66.github.io/2020/04/21/MySQL01/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="索引概述   MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。    索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL  必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL  能够快速到达一个位置去搜索数据文件，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/binary-search-tree.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/binary-search-tree-2.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/binary-tree-1.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/avl-2.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/1355319681_6107.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/20180305203757434.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/20180305204104694.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/111.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/222.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/12.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/13.png">
<meta property="og:image" content="https://jiangao66.github.io/img/MySQL/14.png">
<meta property="article:published_time" content="2020-04-21T09:34:13.000Z">
<meta property="article:modified_time" content="2020-05-20T05:31:11.241Z">
<meta property="article:author" content="小小鱼">
<meta property="article:tag" content="索引">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiangao66.github.io/img/MySQL/binary-search-tree.png">

<link rel="canonical" href="https://jiangao66.github.io/2020/04/21/MySQL01/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL中的索引 | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiangao66.github.io/2020/04/21/MySQL01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="小小鱼">
      <meta itemprop="description" content="分享学习心得，记录学习过程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL中的索引
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 17:34:13" itemprop="dateCreated datePublished" datetime="2020-04-21T17:34:13+08:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-20 13:31:11" itemprop="dateModified" datetime="2020-05-20T13:31:11+08:00">2020-05-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>   MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>   索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL  必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL  能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。</p>
<p>   我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear  search），这种复杂度为 O(n)  的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary  search）、二叉树查找（binary tree  search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>   索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。由于  MySQL 默认存储引擎为 InnoDB，因此下文只讨论 InnoDB  存储引擎下索引的实现。索引是应用程序设计和开发中的一个重要方面，若索引太多，应用程序的性能可能会受到影响，而索引太少，对查询性能又会产生影响。要找到一个合适的平衡点，这对应用程序性能至关重要。</p>
<a id="more"></a>

<h3 id="InnoDB存储引擎索引概述"><a href="#InnoDB存储引擎索引概述" class="headerlink" title="InnoDB存储引擎索引概述"></a>InnoDB存储引擎索引概述</h3><p>InnoDB 存储引擎支持以下几种常见的索引：</p>
<ul>
<li>B+ 树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<p>其中，InnoDB 存储引擎支持的哈希索引是自适应的， InnoDB 存储引擎会根据表的使用情况自动生成哈希索引，不能人为干预是否在一张表中生成哈希索引。<br>而 B+ 树索引就是传统意义上的索引，这是目前关系型数据库系统中查找最为常用和最为有效的索引，B+ 树索引的构造类似于二叉树，根据键值（key value）快速找到数据。</p>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>在介绍 B+ 树原理之前，有必要先介绍与其相近的二叉树相关知识，以便于更好的理解为什么数据库要选择 B+ 树作为索引的数据结构的原理。</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉查找树也称为有序二叉查找树，满足二叉查找树的一般性质，是指一棵空树具有如下性质：</p>
<ol>
<li>任意节点左子树不为空，则左子树的值均小于根节点的值；</li>
<li>任意节点右子树不为空，则右子树的值均大于于根节点的值；</li>
<li>任意节点的左右子树也分别是二叉查找树；</li>
<li>没有键值相等的节点；</li>
</ol>
<p><img src="/img/MySQL/binary-search-tree.png" alt="binary-search-tree"></p>
<p>上图为一个普通的二叉查找树，按照中序遍历的方式可以从小到大的顺序排序输出：2、3、5、6、7、8。</p>
<p>对上述二叉树进行查找，如查键值为  5 的记录，先找到根，其键值是 6，6 大于 5，因此查找 6 的左子树，找到 3；而 5 大于 3，再找其右子树；一共找了 3 次。如果按  2、3、5、6、7、8 的顺序来找同样需求 3 次。用同样的方法在查找键值为 8 的这个记录，这次用了 3 次查找，而顺序查找需要  6次。计算平均查找次数得：顺序查找的平均查找次数为<code>（1+2+3+4+5+6）/ 6 = 3.3</code>次，二叉查找树的平均查找次数为<code>（3+3+3+2+2+1）/ 6= 2.3</code>次。二叉查找树的平均查找速度比顺序查找来得更快。</p>
<p>二叉查找树可以任意构造，同样是上述数字，也可以构造为如下：</p>
<p><img src="/img/MySQL/binary-search-tree-2.png" alt=""></p>
<p>而上图的平均查找次数为<code>(1+2+3+4+5+5) / 6 = 3.16</code>次，和顺序查找差不多，显然这样构造的查询效率就比较低了。因此若想最大性能的构造一颗二叉查找树，需要这个二叉树是平衡的，也就是必须是平衡二叉树（AVL 树）。</p>
<h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>AVL  树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过  1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过  1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道 AVL  树适合用于插入删除次数比较少，但查找多的情况。</p>
<p>如下是插入新值 9 后平衡二叉树的变化：</p>
<p><img src="/img/MySQL/binary-tree-1.png" alt="binary-tree-1"></p>
<p>如下是需要多次旋转的 AVL 树：</p>
<p><img src="/img/MySQL/avl-2.png" alt="avl-2"></p>
<p>由上可知，由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么 AVL 还是较优于红黑树。</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是  red 或  black。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是若平衡，可以推出，相同的节点情况下，AVL  树的高度低于红黑树)，相对于要求严格的 AVL 树来说，它的旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。</p>
<p>红黑树具有以下性质：</p>
<ul>
<li>每个节点非红即黑；</li>
<li>根节点是黑的；</li>
<li>每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；</li>
<li>如果一个节点是红的,那么它的两儿子都是黑的；</li>
<li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；</li>
<li>每条路径都包含相同的黑节点；</li>
</ul>
<p>红黑树构造如下：</p>
<p><img src="/img/MySQL/1355319681_6107.png" alt="1355319681_6107"></p>
<p>其应用较为广泛：</p>
<ol>
<li>广泛用于 C++ 的 STL 中，Map 和 Set 都是用红黑树实现的；</li>
<li>著名的 Linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间；</li>
<li>IO 多路复用 epoll 的实现采用红黑树组织管理 sockfd，以支持快速的增删改查；</li>
<li>Nginx 中用红黑树管理 timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器；</li>
<li>Java 中 TreeMap、HashMap、ConcurrentHashMap 的实现；</li>
</ol>
<h3 id="B-B-树"><a href="#B-B-树" class="headerlink" title="B/B+ 树"></a>B/B+ 树</h3><p>说了上述的三种树：二叉查找树、AVL和红黑树，似乎我们还没有摸到 MySQL 为什么要使用 B+ 树作为索引的实现，不要急，接下来我们就先探讨一下什么是 B 树。</p>
<p>我们在  MySQL  中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过  B 树进行优化，提高磁盘读取时定位的效率。</p>
<p>为什么 B 类树可以进行优化呢？我们可以根据 B 类树的特点，构造一个多阶的 B  类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的 I/O 操作也少一些，而且 B  类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p>
<p>总的来说，B/B+  树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B 树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗  B/B+ 树的高度远远小于红黑树的高度(在下面 B/B+ 树的性能分析中会提到)。B/B+ 树上操作的时间通常由存取磁盘的时间和 CPU  计算时间这两部分构成，而 CPU 的速度非常快，所以 B 树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下 B 树的高度越小，磁盘  I/O 所花的时间越少。</p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B 树的性质：</p>
<ol>
<li>定义任意非叶子结点最多只有M个儿子，且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<p><img src="/img/MySQL/20180305203757434.png" alt="20180305203757434"></p>
<p>这里只是一个简单的 B 树，在实际中 B 树节点中关键字很多的，上面的图中比如 35 节点，35 代表一个 key (索引)，而小黑块代表的是这个 key 所指向的内容在内存中实际的存储位置，是一个指针。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+ 树是应文件系统所需而产生的一种 B 树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，这不就是文件系统文件的查找吗?</p>
<p>我们就举个文件查找的例子：有 3 个文件夹a、b、c， a包含b，b包含c，一个文件 yang.c，a、b、c就是索引（存储在非叶子节点）， a、b、c只是要找到的 yang.c 的key，而实际的数据 yang.c 存储在叶子节点上。</p>
<p>所有的非叶子节点都可以看成索引部分！</p>
<p>B+ 树有以下性质：</p>
<ol>
<li>非叶子节点的子树指针与关键字个数相同；</li>
<li>非叶子节点的子树指针 p[i] ,指向关键字值属于 [k[i],k[i+1]] 的子树。(B 树是开区间,也就是说B树不允许关键字重复，B+ 树允许重复)；</li>
<li>为所有叶子节点增加一个链指针；</li>
<li>所有关键字都在叶子节点出现（稠密索引）。 (且链表中的关键字恰好是有序的)；</li>
<li>非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据的数据层；</li>
<li>更适合于文件系统；</li>
</ol>
<p><img src="/img/MySQL/20180305204104694.png" alt="20180305204104694"></p>
<p>非叶子节点（比如5，28，65）只是一个key（索引），实际的数据存在叶子节点上（5，8，9）才是真正的数据或指向真实数据的指针。</p>
<h4 id="为什么说B-树比B树更适合数据库索引？"><a href="#为什么说B-树比B树更适合数据库索引？" class="headerlink" title="为什么说B+树比B树更适合数据库索引？"></a>为什么说B+树比B树更适合数据库索引？</h4><ol>
<li>B+  树的磁盘读写代价更低：B+  树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对  I/O 读写次数就降低了。</li>
<li>B+ 树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
<li>由于  B+ 树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是  B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以 B+ 树更加适合在区间查询的情况，所以通常 B+  树用于数据库索引。</li>
</ol>
<p>简而言之，数据库索引采用 B+ 树的主要原因是：B树在提高了 I/O  性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+ 树应用而生。B+  树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作或者说效率太低。</p>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>以下使用的 MySQL 数据库为 5.7.26 版本，不同版本显示结果略有不同。</p>
<h5 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a>创建表的时候创建索引</h5><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名[字段名 数据类型]  [UNIQUE|FULLTEXT|SPATIAL|...] [INDEX|KEY] [索引名字] (字段名[length]) 　　[ASC|DESC]</span><br></pre></td></tr></table></figure>

<p>对应意思如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通创建表语句　　设置什么样的索引(唯一、全文等)　　索引关键字　 索引名字　对哪个字段设置索引　　对索引进行排序</span><br></pre></td></tr></table></figure>

<h6 id="创建普通索引"><a href="#创建普通索引" class="headerlink" title="创建普通索引"></a>创建普通索引</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE book</span><br><span class="line">(</span><br><span class="line">   bookid INT NOT NULL,</span><br><span class="line">   bookname VARCHAR(255) NOT NULL,</span><br><span class="line">   authors VARCHAR(255) NULL,</span><br><span class="line">   info VARCHAR(255) NULL,</span><br><span class="line">   comment VARCHAR(255) NULL,</span><br><span class="line">   year_publication YEAR NOT NULL,</span><br><span class="line">   </span><br><span class="line">   INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者使用如下命令：</p>
<p>CREATE TABLE book<br>(<br>   bookid INT NOT NULL,<br>   bookname VARCHAR(255) NOT NULL,<br>   authors VARCHAR(255) NULL,<br>   info VARCHAR(255) NULL,<br>   comment VARCHAR(255) NULL,<br>   year_publication YEAR NOT NULL,</p>
<p>   KEY(year_publication)<br>);</p>
<p>创建之后，我们使用<code>Explain</code>查看创建的索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM book WHERE year_publication &#x3D; 2019\G;</span><br></pre></td></tr></table></figure>

<p>其输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM book where year_publication &#x3D; 2019\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: book</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: year_publication</span><br><span class="line">          key: year_publication</span><br><span class="line">      key_len: 1</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>其中每个符号代表的意义如下：</p>
<ol>
<li>id：SELECT 识别符。这是 SELECT 的查询序列号,也就是一条语句中，该 select 是第几次出现。在次语句中，select 就只有一个，所以是 1。</li>
<li>select_type：所使用的 SELECT 查询类型，SIMPLE 表示为简单的 SELECT，不实用 UNION 或子查询，就为简单的 SELECT。也就是说在该 SELECT 查询时会使用索引。其他取值，<code>PRIMARY</code>：最外面的 SELECT。拥有子查询时，就会出现两个以上的 SELECT。<code>UNION</code>：union (两张表连接)中的第二个或后面的 select 语句 <code>SUBQUERY</code>：在子查询中，第二 SELECT。</li>
<li>table：数据表的名字。他们按被读取的先后顺序排列，这里因为只查询一张表，所以只显示 book。</li>
<li>type：指定本数据表和其他数据表之间的关联关系，该表中所有符合检索值的记录都会被取出来和从上一个表中取出来的记录作联合。ref  用于连接程序使用键的最左前缀或者是该键不是 primary key 或  unique索引（换句话说，就是连接程序无法根据键值只取得一条记录）的情况。当根据键值只查询到少数几条匹配的记录时，这就是一个不错的连接类型。(注意，个人这里不是很理解，百度了很多资料，全是大白话，等以后用到了这类信息时，在回过头来补充，这里不懂对后面的影响不大。)可能的取值有  system、const、eq_ref、index和All。</li>
<li>possible_keys：MySQL 在搜索数据记录时可以选用的各个索引，该表中就只有一个索引 year_publication。</li>
<li>key：实际选用的索引</li>
<li>key_len：显示了  MySQL 使用索引的长度(也就是使用的索引个数)，当 key 字段的值为 null 时，索引的长度就是 null。注意，key_len  的值可以告诉你在联合索引中 mysql 会真正使用了哪些索引。这里就使用了 1 个索引，所以为 1。</li>
<li>ref：给出关联关系中另一个数据表中数据列的名字。常量（const），这里使用的是 1990，就是常量。</li>
<li>rows：MySQL 在执行这个查询时预计会从这个数据表里读出的数据行的个数。</li>
<li>extra：提供了与关联操作有关的信息，没有则什么都不写。　　　</li>
</ol>
<p>上面的一大堆东西能看懂多少看多少，我们最主要的是看 possible_keys 和 key 这两个属性，上面显示了 key 为year_publication。说明使用了索引。</p>
<h6 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;CREATE TABLE t1&#96;</span><br></pre></td></tr></table></figure>

<p>解释：对 id 字段使用了索引，并且索引名字为 UniqIdx。</p>
<p>我们使用命令<code>SHOW CREATE TABLE t1\G</code>查看建表语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;mysql&gt; SHOW CREATE TABLE t1\G********&#96;</span><br></pre></td></tr></table></figure>

<p>要查看其中查询时使用的索引，必须先往表中插入数据，然后在查询数据，不然查找一个没有的id值，是不会使用索引的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;INSE&#96;</span><br></pre></td></tr></table></figure>

<p>上述 EXPLAIN 结果为：</p>
<p><img src="/img/MySQL/111.png" alt="111"></p>
<p>可以看到，通过id查询时，会使用唯一索引。</p>
<h6 id="创建主键索引"><a href="#创建主键索引" class="headerlink" title="创建主键索引"></a>创建主键索引</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;CREATE TABLE &#96;</span><br></pre></td></tr></table></figure>

<p>分析后结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;mys&#96;</span><br></pre></td></tr></table></figure>

<p>通过这个主键索引，我们就应该反应过来，其实我们以前声明的主键约束，就是一个主键索引，只是之前我们没学过，不知道而已。</p>
<h6 id="创建单列索引"><a href="#创建单列索引" class="headerlink" title="创建单列索引"></a>创建单列索引</h6><p>这个其实就不用在说了，前面几个就是单列索引。</p>
<h6 id="创建组合索引"><a href="#创建组合索引" class="headerlink" title="创建组合索引"></a>创建组合索引</h6><p>组合索引就是在多个字段上创建一个索引。</p>
<p>创建一个表 t3，在表中的 id、name 和 age 字段上建立组合索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t3</span><br><span class="line">(</span><br><span class="line">  id INT NOT NULL,</span><br><span class="line">  name CHAR(30) NOT NULL,</span><br><span class="line">  age INT NOT NULL,</span><br><span class="line">  info VARCHAR(255),</span><br><span class="line">  INDEX MultiIdx(id,name,age)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW CREATE TABLE t3\G;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;mysq&#96;</span><br></pre></td></tr></table></figure>

<p>解释最左前缀：组合索引就是遵从了最左前缀，利用索引中最左边的列集来匹配行，这样的列集称为最左前缀，不明白没关系，举几个例子就明白了，例如，这里由id、name  和 age 3 个字段构成的索引，索引行中就按id/name/age  的顺序存放，索引可以索引下面字段组合(id，name，age)、(id，name)或者(id)。如果要查询的字段不构成索引最左面的前缀，那么就不会是用索引，比如，age  或者（name，age）组合就不会使用索引查询。</p>
<p>在 t3 表中，查询 id 和 name 字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t3 where id &#x3D; 1 AND name &#x3D; &quot;zuoxiang&quot;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t3</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: MultiIdx   &#x2F;&#x2F;使用了组合索引</span><br><span class="line">          key: MultiIdx   &#x2F;&#x2F;使用了组合索引</span><br><span class="line">      key_len: 34</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>而 在t3表中，查询(age，name)字段，这样就不会使用索引查询。来看看结果 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;m&#96;</span><br></pre></td></tr></table></figure>

<h6 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h6><p>全文索引可以用于全文搜索，但只有 MyISAM 存储引擎支持 FULLTEXT 索引，并且只为 CHAR、VARCHAR 和TEXT 列服务。索引总是对整个列进行，不支持前缀索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;CREAT&#96;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;m&#96;</span><br></pre></td></tr></table></figure>

<p>使用一下什么叫做全文搜索。就是在很多文字中，通过关键字就能够找到该记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t4 VALUES(8,&#39;AAA&#39;,3,&#39;text is so good，hei，my name is bob&#39;),(9,&#39;BBB&#39;,4,&#39;my name is gorlr&#39;);</span><br></pre></td></tr></table></figure>

<p>分析一下：</p>
<p><img src="/img/MySQL/222.png" alt="222"></p>
<p>注意：在使用全文搜索时，需要借助 MATCH 函数，并且其全文搜索的限制比较多，比如只能通过 MyISAM 引擎，比如只能在 CHAR ,  VARCHAR , TEXT 上设置全文索引。比如搜索的关键字默认至少要 4 个字符，比如搜索的关键字太短就会被忽略掉。</p>
<h6 id="创建空间索引"><a href="#创建空间索引" class="headerlink" title="创建空间索引"></a>创建空间索引</h6><p>空间索引也必须使用 MyISAM 引擎， 并且空间类型的字段必须为非空。 这个空间索引具体能干嘛我也不知道，可能跟游戏开发有关，可能跟别的东西有关，等遇到了自然就知道了，现在只要求能够创建出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;CREAT&#96;</span><br></pre></td></tr></table></figure>

<h5 id="在已经存在的表上创建索引"><a href="#在已经存在的表上创建索引" class="headerlink" title="在已经存在的表上创建索引"></a>在已经存在的表上创建索引</h5><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：ALTER TABLE 表名 ADD[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [索引名] (索引字段名)[ASC|DESC]</span><br></pre></td></tr></table></figure>

<p>有了上面的基础，这里就不用过多陈述了。</p>
<h6 id="为表添加索引"><a href="#为表添加索引" class="headerlink" title="为表添加索引"></a>为表添加索引</h6><p>就拿上面的book表来说。本来已经有了一个year_publication，现在我们为该表在加一个普通索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX BkNameIdx(bookname(30));</span><br></pre></td></tr></table></figure>

<p>看一下 book 表的索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;mysql&gt; s&#96;</span><br></pre></td></tr></table></figure>

<p>看输出结果，就能知道，添加索引成功了。</p>
<p>这里只是拿普通索引做个例子，添加其他索引也是一样的。依葫芦画瓢而已。这里就不一一做讲解了。</p>
<h6 id="使用CREATE-INDEX创建索引"><a href="#使用CREATE-INDEX创建索引" class="headerlink" title="使用CREATE INDEX创建索引"></a>使用CREATE INDEX创建索引</h6><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：CREATE [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] 索引名称 ON 表名(创建索引的字段名[length])[ASC|DESC]</span><br></pre></td></tr></table></figure>

<p>解释：其实就是换汤不换药，格式改变了一下而已，做的事情跟上面完全一样，做一个例子：在为 book 表增加一个普通索引，字段为 authors。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX BkBookNameIdx ON book(bookname);</span><br><span class="line">SHOW INDEX FROM book\G;　　&#x2F;&#x2F;查看book表中的索引</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM book\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: book</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: year_publication</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: year_publication</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: book</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: BkBookNameIdx</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: bookname</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><h5 id="ALTER-TABLE-表名-DROP-INDEX-索引名。"><a href="#ALTER-TABLE-表名-DROP-INDEX-索引名。" class="headerlink" title="ALTER TABLE 表名 DROP INDEX 索引名。"></a>ALTER TABLE 表名 DROP INDEX 索引名。</h5><p>很简单的语句，现在通过一个例子来看看，还是对book表进行操作，删除我们刚才为其添加的索引。</p>
<p>删除 book 表中的名称为 BkBookNameIdx 的索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ALTER TABL&#96;</span><br></pre></td></tr></table></figure>

<h5 id="DROP-INDEX-索引名-ON-表名；"><a href="#DROP-INDEX-索引名-ON-表名；" class="headerlink" title="DROP INDEX 索引名 ON 表名；"></a>DROP INDEX 索引名 ON 表名；</h5><p>删除book表中名为BkNameIdx的索引 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX BkNameIdx ON book;</span><br><span class="line">SHOW INDEX FROM book\G;</span><br></pre></td></tr></table></figure>

<h3 id="索引使用策略及优化"><a href="#索引使用策略及优化" class="headerlink" title="索引使用策略及优化"></a>索引使用策略及优化</h3><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。</p>
<h4 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h4><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p>
<p><img src="/img/MySQL/12.png" alt="12"></p>
<p>MySQL官方文档中关于此数据库的页面为<a href="http://dev.mysql.com/doc/employee/en/employee.html。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。" target="_blank" rel="noopener">http://dev.mysql.com/doc/employee/en/employee.html。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。</a></p>
<h4 id="最左前缀原理与相关优化"><a href="#最左前缀原理与相关优化" class="headerlink" title="最左前缀原理与相关优化"></a>最左前缀原理与相关优化</h4><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和 B+Tree 中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p>
<p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL  中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …,  an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p>
<p>以 employees.titles 表为例，下面先查看其上都有哪些索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM employees.titles;</span><br><span class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br><span class="line">| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |</span><br><span class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br><span class="line">| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |</span><br><span class="line">| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |</span><br><span class="line">| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |</span><br><span class="line">| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |</span><br><span class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br></pre></td></tr></table></figure>

<p>从结果中可以到titles表的主索引为&lt;emp_no, title,<br>from_date&gt;，还有一个辅助索引<emp_no>。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employees.titles DROP INDEX emp_no;</span><br></pre></td></tr></table></figure>

<p>这样就可以专心分析索引PRIMARY的行为了。</p>
<h5 id="情况一：全列匹配。"><a href="#情况一：全列匹配。" class="headerlink" title="情况一：全列匹配。"></a>情况一：全列匹配。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title&#x3D;&#39;Senior Engineer&#39; AND from_date&#x3D;&#39;1986-06-26&#39;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br></pre></td></tr></table></figure>

<p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;EXP&#96;</span><br></pre></td></tr></table></figure>

<p>效果是一样的。</p>
<h5 id="情况二：最左前缀匹配。"><a href="#情况二：最左前缀匹配。" class="headerlink" title="情况二：最左前缀匹配。"></a>情况二：最左前缀匹配。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;EXPLAIN SELECT * FR&#96;</span><br></pre></td></tr></table></figure>

<p>当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或&lt;emp_no,  title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p>
<h5 id="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"><a href="#情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。" class="headerlink" title="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"></a>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;EXPLAIN&#96;</span><br></pre></td></tr></table></figure>

<p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no,   from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p>
<p>首先我们看下title一共有几种不同的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;SE&#96;</span><br></pre></td></tr></table></figure>

<p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;EX&#96;</span><br></pre></td></tr></table></figure>

<p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;SH&#96;</span><br></pre></td></tr></table></figure>

<p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p>
<h5 id="情况四：查询条件没有指定索引第一列。"><a href="#情况四：查询条件没有指定索引第一列。" class="headerlink" title="情况四：查询条件没有指定索引第一列。"></a>情况四：查询条件没有指定索引第一列。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;EXPLAI&#96;</span><br></pre></td></tr></table></figure>

<p>由于不是最左前缀，索引这样的查询显然用不到索引。</p>
<h5 id="情况五：匹配某列的前缀字符串。"><a href="#情况五：匹配某列的前缀字符串。" class="headerlink" title="情况五：匹配某列的前缀字符串。"></a>情况五：匹配某列的前缀字符串。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;EXPL&#96;</span><br></pre></td></tr></table></figure>

<p>此时可以用到索引，<del>但是如果通配符不是只出现在末尾，则无法使用索引。</del>（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p>
<h5 id="情况六：范围查询。"><a href="#情况六：范围查询。" class="headerlink" title="情况六：范围查询。"></a>情况六：范围查询。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; &#39;10010&#39; and title&#x3D;&#39;Senior Engineer&#39;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;EXPLAIN SE&#96;</span><br></pre></td></tr></table></figure>

<p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;EXPL&#96;</span><br></pre></td></tr></table></figure>

<p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p>
<h5 id="情况七：查询条件中含有函数或表达式。"><a href="#情况七：查询条件中含有函数或表达式。" class="headerlink" title="情况七：查询条件中含有函数或表达式。"></a>情况七：查询条件中含有函数或表达式。</h5><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND left(title, 6)&#x3D;&#39;Senior&#39;;</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+&#96;EXPLAIN SELECT * &#96;</span><br></pre></td></tr></table></figure>

<p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1&#x3D;&#39;10000&#39;;</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure>

<p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p>
<h4 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h4><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p>
<p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p>
<p>Index Selectivity = Cardinality / #T</p>
<p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;SELECT&#96;</span><br></pre></td></tr></table></figure>

<p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p>
<p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p>
<p>从图12可以看到employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;EXP&#96;</span><br></pre></td></tr></table></figure>

<p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;SELE&#96;</span><br></pre></td></tr></table></figure>

<p><first_name>显然选择性太低，&lt;first_name,  last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name,  left(last_name, 3)&gt;，看看其选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;SELE&#96;</span><br></pre></td></tr></table></figure>

<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))&#x2F;count(*) AS Selectivity FROM employees.employees;+--&#96;</span><br></pre></td></tr></table></figure>

<p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;AL&#96;</span><br></pre></td></tr></table></figure>

<p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;SHO&#96;</span><br></pre></td></tr></table></figure>

<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<h4 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h4><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>
<p><img src="/img/MySQL/13.png" alt="13"></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p>
<p><img src="/img/MySQL/14.png" alt="14"></p>
<p>此时 MySQL  不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过  OPTIMIZE TABLE 来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在 InnoDB 上采用自增字段做主键。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag"><i class="fa fa-tag"></i> 索引</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/20/threadPool/" rel="prev" title="Java中的线程池分析">
      <i class="fa fa-chevron-left"></i> Java中的线程池分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/22/tcp01/" rel="next" title="TCP为什么是三次握手，而不是两次或者四次？">
      TCP为什么是三次握手，而不是两次或者四次？ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引概述"><span class="nav-number">1.</span> <span class="nav-text">索引概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB存储引擎索引概述"><span class="nav-number">2.</span> <span class="nav-text">InnoDB存储引擎索引概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构与算法"><span class="nav-number">3.</span> <span class="nav-text">数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉查找树"><span class="nav-number">3.1.</span> <span class="nav-text">二叉查找树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AVL树"><span class="nav-number">3.2.</span> <span class="nav-text">AVL树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#红黑树"><span class="nav-number">3.3.</span> <span class="nav-text">红黑树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-B-树"><span class="nav-number">4.</span> <span class="nav-text">B&#x2F;B+ 树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B树"><span class="nav-number">4.1.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树"><span class="nav-number">4.2.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么说B-树比B树更适合数据库索引？"><span class="nav-number">4.3.</span> <span class="nav-text">为什么说B+树比B树更适合数据库索引？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引操作"><span class="nav-number">5.</span> <span class="nav-text">索引操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建索引"><span class="nav-number">5.1.</span> <span class="nav-text">创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建表的时候创建索引"><span class="nav-number">5.1.1.</span> <span class="nav-text">创建表的时候创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#创建普通索引"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">创建普通索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建唯一索引"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">创建唯一索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建主键索引"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">创建主键索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建单列索引"><span class="nav-number">5.1.1.4.</span> <span class="nav-text">创建单列索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建组合索引"><span class="nav-number">5.1.1.5.</span> <span class="nav-text">创建组合索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建全文索引"><span class="nav-number">5.1.1.6.</span> <span class="nav-text">创建全文索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建空间索引"><span class="nav-number">5.1.1.7.</span> <span class="nav-text">创建空间索引</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在已经存在的表上创建索引"><span class="nav-number">5.1.2.</span> <span class="nav-text">在已经存在的表上创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#为表添加索引"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">为表添加索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#使用CREATE-INDEX创建索引"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">使用CREATE INDEX创建索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除索引"><span class="nav-number">5.2.</span> <span class="nav-text">删除索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ALTER-TABLE-表名-DROP-INDEX-索引名。"><span class="nav-number">5.2.1.</span> <span class="nav-text">ALTER TABLE 表名 DROP INDEX 索引名。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DROP-INDEX-索引名-ON-表名；"><span class="nav-number">5.2.2.</span> <span class="nav-text">DROP INDEX 索引名 ON 表名；</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引使用策略及优化"><span class="nav-number">6.</span> <span class="nav-text">索引使用策略及优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例数据库"><span class="nav-number">6.1.</span> <span class="nav-text">示例数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最左前缀原理与相关优化"><span class="nav-number">6.2.</span> <span class="nav-text">最左前缀原理与相关优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#情况一：全列匹配。"><span class="nav-number">6.2.1.</span> <span class="nav-text">情况一：全列匹配。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#情况二：最左前缀匹配。"><span class="nav-number">6.2.2.</span> <span class="nav-text">情况二：最左前缀匹配。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"><span class="nav-number">6.2.3.</span> <span class="nav-text">情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#情况四：查询条件没有指定索引第一列。"><span class="nav-number">6.2.4.</span> <span class="nav-text">情况四：查询条件没有指定索引第一列。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#情况五：匹配某列的前缀字符串。"><span class="nav-number">6.2.5.</span> <span class="nav-text">情况五：匹配某列的前缀字符串。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#情况六：范围查询。"><span class="nav-number">6.2.6.</span> <span class="nav-text">情况六：范围查询。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#情况七：查询条件中含有函数或表达式。"><span class="nav-number">6.2.7.</span> <span class="nav-text">情况七：查询条件中含有函数或表达式。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引选择性与前缀索引"><span class="nav-number">6.3.</span> <span class="nav-text">索引选择性与前缀索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB的主键选择与插入优化"><span class="nav-number">6.4.</span> <span class="nav-text">InnoDB的主键选择与插入优化</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小小鱼"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">小小鱼</p>
  <div class="site-description" itemprop="description">分享学习心得，记录学习过程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JianGao66" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JianGao66" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2517550801@qq.com" title="E-Mail → mailto:2517550801@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小小鱼</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
  
  <script type="text/javascript"
  color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
